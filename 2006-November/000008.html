<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Libsecondlife-commits] r650 - in branches/aditi: . SLProxy SLProxy/legacy applications applications/Decoder applications/FollowBot applications/SLIRC applications/TestBot applications/sceneviewer applications/sceneviewer/Prims applications/sceneviewer/Properties bin libjaspernet libsecondlife-cs libsecondlife-cs/AssetSystem libsecondlife-cs/InventorySystem libsecondlife-cs/JSON libsecondlife-cs/XmlRpcCS libsecondlife-cs/examples libsecondlife-cs/examples/AnimationSample libsecondlife-cs/examples/BodyPartMorphGenerator libsecondlife-cs/examples/IA_ImageTool libsecondlife-cs/examples/IA_InventoryManager libsecondlife-cs/examples/IA_MultiImageUpload libsecondlife-cs/examples/IA_NotecardTool libsecondlife-cs/examples/IA_SimpleInventory libsecondlife-cs/examples/IA_TestAsyncImage libsecondlife-cs/examples/ParcelDownload libsecondlife-cs/examples/Teleport libsecondlife-cs/examples/TestClient libsecondlife-cs/examples/groupmanager libsecondlife-cs/examples/name2key libsecondlife-cs/examples/prim! export libsecondlife-cs/examples/slaccountant libsecondlife-cs/examples/sldump libsecondlife-cs/mapgenerator libsecondlife-cs/tests
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/libsecondlife-commits/2006-November/index.html" >
   <LINK REL="made" HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r650%20-%20in%20branches/aditi%3A%20.%20SLProxy%0A%20SLProxy/legacy%20applications%20applications/Decoder%20applications/FollowBot%0A%20applications/SLIRC%20applications/TestBot%20applications/sceneviewer%0A%20applications/sceneviewer/Prims%20applications/sceneviewer/Properties%20bin%0A%20libjaspernet%20libsecondlife-cs%20libsecondlife-cs/AssetSystem%0A%20libsecondlife-cs/InventorySystem%20libsecondlife-cs/JSON%0A%20libsecondlife-cs/XmlRpcCS%20libsecondlife-cs/examples%0A%20libsecondlife-cs/examples/AnimationSample%0A%20libsecondlife-cs/examples/BodyPartMorphGenerator%0A%20libsecondlife-cs/examples/IA_ImageTool%0A%20libsecondlife-cs/examples/IA_InventoryManager%0A%20libsecondlife-cs/examples/IA_MultiImageUpload%0A%20libsecondlife-cs/examples/IA_NotecardTool%0A%20libsecondlife-cs/examples/IA_SimpleInventory%0A%20libsecondlife-cs/examples/IA_TestAsyncImage%0A%20libsecondlife-cs/examples/ParcelDownload%20libsecondlife-cs/examples/Teleport%0A%20libsecondlife-cs/examples/TestClient%20libsecondlife-cs/examples/groupmanager%0A%20libsecondlife-cs/examples/name2key%20libsecondlife-cs/examples/prim%21%20export%0A%20libsecondlife-cs/examples/slaccountant%20libsecondlife-cs/examples/sldump%0A%20libsecondlife-cs/mapgenerator%20libsecondlife-cs/tests&In-Reply-To=%3C200611290054.kAT0sxhe003198%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000005.html">
   <LINK REL="Next"  HREF="000006.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Libsecondlife-commits] r650 - in branches/aditi: . SLProxy SLProxy/legacy applications applications/Decoder applications/FollowBot applications/SLIRC applications/TestBot applications/sceneviewer applications/sceneviewer/Prims applications/sceneviewer/Properties bin libjaspernet libsecondlife-cs libsecondlife-cs/AssetSystem libsecondlife-cs/InventorySystem libsecondlife-cs/JSON libsecondlife-cs/XmlRpcCS libsecondlife-cs/examples libsecondlife-cs/examples/AnimationSample libsecondlife-cs/examples/BodyPartMorphGenerator libsecondlife-cs/examples/IA_ImageTool libsecondlife-cs/examples/IA_InventoryManager libsecondlife-cs/examples/IA_MultiImageUpload libsecondlife-cs/examples/IA_NotecardTool libsecondlife-cs/examples/IA_SimpleInventory libsecondlife-cs/examples/IA_TestAsyncImage libsecondlife-cs/examples/ParcelDownload libsecondlife-cs/examples/Teleport libsecondlife-cs/examples/TestClient libsecondlife-cs/examples/groupmanager libsecondlife-cs/examples/name2key libsecondlife-cs/examples/prim! export libsecondlife-cs/examples/slaccountant libsecondlife-cs/examples/sldump libsecondlife-cs/mapgenerator libsecondlife-cs/tests</H1>
    <B>jhurliman at BerliOS</B> 
    <A HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r650%20-%20in%20branches/aditi%3A%20.%20SLProxy%0A%20SLProxy/legacy%20applications%20applications/Decoder%20applications/FollowBot%0A%20applications/SLIRC%20applications/TestBot%20applications/sceneviewer%0A%20applications/sceneviewer/Prims%20applications/sceneviewer/Properties%20bin%0A%20libjaspernet%20libsecondlife-cs%20libsecondlife-cs/AssetSystem%0A%20libsecondlife-cs/InventorySystem%20libsecondlife-cs/JSON%0A%20libsecondlife-cs/XmlRpcCS%20libsecondlife-cs/examples%0A%20libsecondlife-cs/examples/AnimationSample%0A%20libsecondlife-cs/examples/BodyPartMorphGenerator%0A%20libsecondlife-cs/examples/IA_ImageTool%0A%20libsecondlife-cs/examples/IA_InventoryManager%0A%20libsecondlife-cs/examples/IA_MultiImageUpload%0A%20libsecondlife-cs/examples/IA_NotecardTool%0A%20libsecondlife-cs/examples/IA_SimpleInventory%0A%20libsecondlife-cs/examples/IA_TestAsyncImage%0A%20libsecondlife-cs/examples/ParcelDownload%20libsecondlife-cs/examples/Teleport%0A%20libsecondlife-cs/examples/TestClient%20libsecondlife-cs/examples/groupmanager%0A%20libsecondlife-cs/examples/name2key%20libsecondlife-cs/examples/prim%21%20export%0A%20libsecondlife-cs/examples/slaccountant%20libsecondlife-cs/examples/sldump%0A%20libsecondlife-cs/mapgenerator%20libsecondlife-cs/tests&In-Reply-To=%3C200611290054.kAT0sxhe003198%40sheep.berlios.de%3E"
       TITLE="[Libsecondlife-commits] r650 - in branches/aditi: . SLProxy SLProxy/legacy applications applications/Decoder applications/FollowBot applications/SLIRC applications/TestBot applications/sceneviewer applications/sceneviewer/Prims applications/sceneviewer/Properties bin libjaspernet libsecondlife-cs libsecondlife-cs/AssetSystem libsecondlife-cs/InventorySystem libsecondlife-cs/JSON libsecondlife-cs/XmlRpcCS libsecondlife-cs/examples libsecondlife-cs/examples/AnimationSample libsecondlife-cs/examples/BodyPartMorphGenerator libsecondlife-cs/examples/IA_ImageTool libsecondlife-cs/examples/IA_InventoryManager libsecondlife-cs/examples/IA_MultiImageUpload libsecondlife-cs/examples/IA_NotecardTool libsecondlife-cs/examples/IA_SimpleInventory libsecondlife-cs/examples/IA_TestAsyncImage libsecondlife-cs/examples/ParcelDownload libsecondlife-cs/examples/Teleport libsecondlife-cs/examples/TestClient libsecondlife-cs/examples/groupmanager libsecondlife-cs/examples/name2key libsecondlife-cs/examples/prim! export libsecondlife-cs/examples/slaccountant libsecondlife-cs/examples/sldump libsecondlife-cs/mapgenerator libsecondlife-cs/tests">jhurliman at mail.berlios.de
       </A><BR>
    <I>Wed Nov 29 01:54:59 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000005.html">[Libsecondlife-commits] r649 - in trunk/libsecondlife-cs: .	examples/TestClient examples/TestClient/Commands
</A></li>
        <LI>Next message: <A HREF="000006.html">[Libsecondlife-commits] r651 - branches/aditi/libsecondlife-cs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8">[ date ]</a>
              <a href="thread.html#8">[ thread ]</a>
              <a href="subject.html#8">[ subject ]</a>
              <a href="author.html#8">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jhurliman
Date: 2006-11-29 01:53:56 +0100 (Wed, 29 Nov 2006)
New Revision: 650

Added:
   branches/aditi/applications/FollowBot/
   branches/aditi/applications/SLIRC/Meebey.SmartIrc4net.dll
   branches/aditi/applications/TestBot/
   branches/aditi/applications/libslupdater/
   branches/aditi/applications/sceneviewer/
   branches/aditi/applications/sceneviewer/Camera.cs
   branches/aditi/applications/sceneviewer/Prims/
   branches/aditi/applications/sceneviewer/Prims/CrossSection.cs
   branches/aditi/applications/sceneviewer/Prims/LinearPrimVisual.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisual.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualBox.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualCylinder.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualPrism.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualRing.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualSphere.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualTorus.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualTube.cs
   branches/aditi/applications/sceneviewer/Properties/
   branches/aditi/applications/sceneviewer/Properties/AssemblyInfo.cs
   branches/aditi/applications/sceneviewer/README.txt
   branches/aditi/applications/sceneviewer/sceneviewer.csproj
   branches/aditi/applications/sceneviewer/sceneviewer.sln
   branches/aditi/libsecondlife-cs/AssetSystem/AssetRequestDownload.cs
   branches/aditi/libsecondlife-cs/AssetSystem/AssetRequestUpload.cs
   branches/aditi/libsecondlife-cs/AssetSystem/BodyPart.cs
   branches/aditi/libsecondlife-cs/AssetSystem/BodyShape/
   branches/aditi/libsecondlife-cs/Helpers.cs
   branches/aditi/libsecondlife-cs/ParticleSystem.cs
   branches/aditi/libsecondlife-cs/examples/BodyPartMorphGenerator/
   branches/aditi/libsecondlife-cs/examples/IA_ImageTool/KakaduWrap.cs
   branches/aditi/libsecondlife-cs/examples/IA_MultiImageUpload/
   branches/aditi/libsecondlife-cs/examples/IA_TestAsyncImage/
   branches/aditi/libsecondlife-cs/examples/TestClient/
   branches/aditi/libsecondlife-cs/tests/PacketTests.cs
   branches/aditi/libsecondlife-cs/tests/PrimObjectTests.cs
   branches/aditi/libsecondlife-cs/tests/TypeTests.cs
   branches/aditi/libsecondlife.nunit
Removed:
   branches/aditi/applications/SecondSuite/
   branches/aditi/applications/Template2Keywords/
   branches/aditi/applications/sceneviewer/
   branches/aditi/applications/sceneviewer/Camera.cs
   branches/aditi/applications/sceneviewer/Prims/
   branches/aditi/applications/sceneviewer/Prims/CrossSection.cs
   branches/aditi/applications/sceneviewer/Prims/LinearPrimVisual.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisual.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualBox.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualCylinder.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualPrism.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualRing.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualSphere.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualTorus.cs
   branches/aditi/applications/sceneviewer/Prims/PrimVisualTube.cs
   branches/aditi/applications/sceneviewer/Properties/
   branches/aditi/applications/sceneviewer/Properties/AssemblyInfo.cs
   branches/aditi/applications/sceneviewer/README.txt
   branches/aditi/applications/sceneviewer/sceneviewer.csproj
   branches/aditi/applications/sceneviewer/sceneviewer.sln
   branches/aditi/applications/snowcrash/
   branches/aditi/libsecondlife-cs/AssetSystem/FastImageTool.cs
   branches/aditi/libsecondlife-cs/examples/FastImageApp/
   branches/aditi/libsecondlife-cs/examples/IA_ImageTool/KakaduWrap.cs
   branches/aditi/libsecondlife-cs/examples/botmanager/
   branches/aditi/libsecondlife-cs/examples/primexport/primexport.cs
   branches/aditi/libsecondlife-cs/tests/DebugServer.cs
Modified:
   branches/aditi/SLProxy/
   branches/aditi/SLProxy/Analyst.cs
   branches/aditi/SLProxy/SLProxy.cs
   branches/aditi/SLProxy/legacy/ProtocolManager.cs
   branches/aditi/SLProxy/legacy/Types.cs
   branches/aditi/SLProxy/legacy/XmlRpcDeserializer.cs
   branches/aditi/applications/Decoder/
   branches/aditi/applications/Decoder/Decoder.cs
   branches/aditi/applications/SLIRC/
   branches/aditi/applications/SLIRC/SLIRC.csproj
   branches/aditi/applications/SLIRC/frmSLIRC.cs
   branches/aditi/bin/
   branches/aditi/libjaspernet/
   branches/aditi/libjaspernet/JasperWrapper.cs
   branches/aditi/libjaspernet/libjasper.dll
   branches/aditi/libsecondlife-cs/
   branches/aditi/libsecondlife-cs/AssetSystem/AssetManager.cs
   branches/aditi/libsecondlife-cs/AssetSystem/AssetPacketHelpers.cs
   branches/aditi/libsecondlife-cs/AssetSystem/ImageManager.cs
   branches/aditi/libsecondlife-cs/AssetSystem/ImagePacketHelpers.cs
   branches/aditi/libsecondlife-cs/Avatar.cs
   branches/aditi/libsecondlife-cs/AvatarManager.cs
   branches/aditi/libsecondlife-cs/GridManager.cs
   branches/aditi/libsecondlife-cs/GroupManager.cs
   branches/aditi/libsecondlife-cs/InventorySystem/InventoryFolder.cs
   branches/aditi/libsecondlife-cs/InventorySystem/InventoryImage.cs
   branches/aditi/libsecondlife-cs/InventorySystem/InventoryItem.cs
   branches/aditi/libsecondlife-cs/InventorySystem/InventoryManager.cs
   branches/aditi/libsecondlife-cs/InventorySystem/InventoryNotecard.cs
   branches/aditi/libsecondlife-cs/InventorySystem/InventoryPacketHelper.cs
   branches/aditi/libsecondlife-cs/JSON/JSONTokener.cs
   branches/aditi/libsecondlife-cs/NetworkManager.cs
   branches/aditi/libsecondlife-cs/ObjectManager.cs
   branches/aditi/libsecondlife-cs/Parcel.cs
   branches/aditi/libsecondlife-cs/Prims.cs
   branches/aditi/libsecondlife-cs/README.txt
   branches/aditi/libsecondlife-cs/Region.cs
   branches/aditi/libsecondlife-cs/SecondLife.cs
   branches/aditi/libsecondlife-cs/Textures.cs
   branches/aditi/libsecondlife-cs/Types.cs
   branches/aditi/libsecondlife-cs/XmlRpcCS/XmlRpcDeserializer.cs
   branches/aditi/libsecondlife-cs/examples/AnimationSample/
   branches/aditi/libsecondlife-cs/examples/AnimationSample/AnimationSample.cs
   branches/aditi/libsecondlife-cs/examples/IA_ImageTool/
   branches/aditi/libsecondlife-cs/examples/IA_ImageTool/IA_ImageTool.csproj
   branches/aditi/libsecondlife-cs/examples/IA_ImageTool/ImageTool.cs
   branches/aditi/libsecondlife-cs/examples/IA_InventoryManager/IA_InventoryManager.csproj
   branches/aditi/libsecondlife-cs/examples/IA_InventoryManager/iManager.cs
   branches/aditi/libsecondlife-cs/examples/IA_NotecardTool/
   branches/aditi/libsecondlife-cs/examples/IA_SimpleInventory/IA_SimpleInventory.cs
   branches/aditi/libsecondlife-cs/examples/ParcelDownload/ParcelDownload.cs
   branches/aditi/libsecondlife-cs/examples/Teleport/
   branches/aditi/libsecondlife-cs/examples/Teleport/Teleport.cs
   branches/aditi/libsecondlife-cs/examples/examples.build
   branches/aditi/libsecondlife-cs/examples/groupmanager/
   branches/aditi/libsecondlife-cs/examples/groupmanager/frmGroupInfo.cs
   branches/aditi/libsecondlife-cs/examples/name2key/name2key.cs
   branches/aditi/libsecondlife-cs/examples/primexport/
   branches/aditi/libsecondlife-cs/examples/primexport/frmPrimExport.cs
   branches/aditi/libsecondlife-cs/examples/primexport/primexport.csproj
   branches/aditi/libsecondlife-cs/examples/slaccountant/frmSLAccountant.cs
   branches/aditi/libsecondlife-cs/examples/sldump/sldump.cs
   branches/aditi/libsecondlife-cs/libsecondlife.csproj
   branches/aditi/libsecondlife-cs/libsecondlife.sln
   branches/aditi/libsecondlife-cs/mapgenerator/
   branches/aditi/libsecondlife-cs/mapgenerator/mapgenerator.cs
   branches/aditi/libsecondlife-cs/mapgenerator/template.cs
   branches/aditi/libsecondlife-cs/tests/
   branches/aditi/libsecondlife-cs/tests/Tests.cs
   branches/aditi/libsecondlife-cs/tests/libsecondlife.Tests.csproj
   branches/aditi/libsecondlife.build
Log:
Backporting r649 to aditi


Property changes on: branches/aditi/SLProxy
___________________________________________________________________
Name: svn:ignore
   + obj


Modified: branches/aditi/SLProxy/Analyst.cs
===================================================================
--- branches/aditi/SLProxy/Analyst.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/SLProxy/Analyst.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -487,18 +487,16 @@
 							Array.Copy(BitConverter.GetBytes(vector4S), 0, vector4Bytes, 12, 4);
 							return new LLVector4(vector4Bytes, 0);
 						case FieldType.LLQuaternion:
-							Match quaternionMatch = (new Regex(@&quot;&lt;\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*&gt;&quot;)).Match(value);
+							Match quaternionMatch = (new Regex(@&quot;&lt;\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*&gt;&quot;)).Match(value);
 							if (!quaternionMatch.Success)
 								throw new Exception();
 							float quaternionX = Convert.ToSingle(quaternionMatch.Groups[1].Captures[0].ToString());
 							float quaternionY = Convert.ToSingle(quaternionMatch.Groups[2].Captures[0].ToString());
 							float quaternionZ = Convert.ToSingle(quaternionMatch.Groups[3].Captures[0].ToString());
-							float quaternionS = Convert.ToSingle(quaternionMatch.Groups[4].Captures[0].ToString());
-							byte[] quaternionBytes = new byte[16];
+							byte[] quaternionBytes = new byte[12];
 							Array.Copy(BitConverter.GetBytes(quaternionX), 0, quaternionBytes,  0, 4);
 							Array.Copy(BitConverter.GetBytes(quaternionY), 0, quaternionBytes,  4, 4);
 							Array.Copy(BitConverter.GetBytes(quaternionZ), 0, quaternionBytes,  8, 4);
-							Array.Copy(BitConverter.GetBytes(quaternionS), 0, quaternionBytes, 12, 4);
 							return new LLQuaternion(quaternionBytes, 0);
 						case FieldType.IPADDR:
 							return IPAddress.Parse(value);

Modified: branches/aditi/SLProxy/SLProxy.cs
===================================================================
--- branches/aditi/SLProxy/SLProxy.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/SLProxy/SLProxy.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,1164 +1,1164 @@
-/*
- * SLProxy.cs: implementation of Second Life proxy library
- *
- * Copyright (c) 2006 Austin Jennings
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-//#define DEBUG_SEQUENCE
-
-using Nwc.XmlRpc;
-using System;
-using System.Collections;
-using System.IO;
-using System.Net;
-using System.Net.Sockets;
-using System.Text;
-using System.Text.RegularExpressions;
-using System.Threading;
-using System.Xml;
-using libsecondlife;
-
-// SLProxy: proxy library for Second Life
-namespace SLProxy {
-	// ProxyConfig: configuration for proxy objects
-	public class ProxyConfig {
-		// userAgent: name of the proxy application
-		public string userAgent;
-		// author: email address of the proxy application's author
-		public string author;
-		// protocol: libsecondlife ProtocolManager
-		public ProtocolManager protocol;
-		// loginPort: port that the login proxy will listen on
-		public ushort loginPort = 8080;
-		// clientFacingAddress: address from which to communicate with the client
-		public IPAddress clientFacingAddress = IPAddress.Loopback;
-		// remoteFacingAddress: address from which to communicate with the server
-		public IPAddress remoteFacingAddress = IPAddress.Any;
-		// remoteLoginUri: URI for Second Life's login server
-		public Uri remoteLoginUri = new Uri(&quot;<A HREF="https://login.agni.lindenlab.com/cgi-bin/login.cgi">https://login.agni.lindenlab.com/cgi-bin/login.cgi</A>&quot;);
-		// verbose: whether or not to print informative messages
-		public bool verbose = true;
-
-		// ProxyConfig: construct a default proxy configuration with the specified userAgent, author, and protocol
-		public ProxyConfig(string userAgent, string author, ProtocolManager protocol) {
-			this.userAgent = userAgent;
-			this.author = author;
-			this.protocol = protocol;
-		}
-
-		// ProxyConfig: construct a default proxy configuration, parsing command line arguments (try --proxy-help)
-		public ProxyConfig(string userAgent, string author, ProtocolManager protocol, string[] args) : this(userAgent, author, protocol) {
-			Hashtable argumentParsers = new Hashtable();
-			argumentParsers[&quot;proxy-help&quot;] = new ArgumentParser(ParseHelp);
-			argumentParsers[&quot;proxy-login-port&quot;] = new ArgumentParser(ParseLoginPort);
-			argumentParsers[&quot;proxy-client-facing-address&quot;] = new ArgumentParser(ParseClientFacingAddress);
-			argumentParsers[&quot;proxy-remote-facing-address&quot;] = new ArgumentParser(ParseRemoteFacingAddress);
-			argumentParsers[&quot;proxy-remote-login-uri&quot;] = new ArgumentParser(ParseRemoteLoginUri);
-			argumentParsers[&quot;proxy-verbose&quot;] = new ArgumentParser(ParseVerbose);
-			argumentParsers[&quot;proxy-quiet&quot;] = new ArgumentParser(ParseQuiet);
-
-			foreach (string arg in args)
-				foreach (string argument in argumentParsers.Keys) {
-					Match match = (new Regex(&quot;^--&quot; + argument + &quot;(?:=(.*))?$&quot;)).Match(arg);
-					if (match.Success) {
-						string value;
-						if (match.Groups[1].Captures.Count == 1)
-							value = match.Groups[1].Captures[0].ToString();
-						else
-							value = null;
-						try {
-							((ArgumentParser)argumentParsers[argument])(value);
-						} catch {
-							Console.WriteLine(&quot;invalid value for --&quot; + argument);
-							ParseHelp(null);
-						}
-					}
-				}
-		}
-
-		private delegate void ArgumentParser(string value);
-
-		private void ParseHelp(string value) {
-			Console.WriteLine(&quot;Proxy command-line arguments:&quot;                                                   );
-			Console.WriteLine(&quot;  --proxy-help                        display this help&quot;                         );
-			Console.WriteLine(&quot;  --proxy-login-port=&lt;port&gt;           listen for logins on &lt;port&gt;&quot;               );
-			Console.WriteLine(&quot;  --proxy-client-facing-address=&lt;IP&gt;  communicate with client via &lt;IP&gt;&quot;          );
-			Console.WriteLine(&quot;  --proxy-remote-facing-address=&lt;IP&gt;  communicate with server via &lt;IP&gt;&quot;          );
-			Console.WriteLine(&quot;  --proxy-remote-login-uri=&lt;URI&gt;      use SL login server at &lt;URI&gt;&quot;              );
-			Console.WriteLine(&quot;  --proxy-verbose                     display proxy notifications&quot;               );
-			Console.WriteLine(&quot;  --proxy-quiet                       suppress proxy notifications&quot;              );
-
-			Environment.Exit(1);
-		}
-
-		private void ParseLoginPort(string value) {
-			loginPort = Convert.ToUInt16(value);
-		}
-
-		private void ParseClientFacingAddress(string value) {
-			clientFacingAddress = IPAddress.Parse(value);
-		}
-
-		private void ParseRemoteFacingAddress(string value) {
-			remoteFacingAddress = IPAddress.Parse(value);
-		}
-
-		private void ParseRemoteLoginUri(string value) {
-			remoteLoginUri = new Uri(value);
-		}
-
-		private void ParseVerbose(string value) {
-			if (value != null)
-				throw new Exception();
-
-			verbose = true;
-		}
-
-		private void ParseQuiet(string value) {
-			if (value != null)
-				throw new Exception();
-
-			verbose = false;
-		}
-	}
-
-	// Proxy: Second Life proxy server
-	// A Proxy instance is only prepared to deal with one client at a time.
-	public class Proxy {
-		private ProxyConfig proxyConfig;
-
-		/*
-		 * Proxy Management
-		 */
-
-		// Proxy: construct a proxy server with the given configuration
-		public Proxy(ProxyConfig proxyConfig) {
-			this.proxyConfig = proxyConfig;
-
-			InitializeLoginProxy();
-			InitializeSimProxy();
-		}
-
-		object keepAliveLock = new Object();
-
-		// Start: begin accepting clients
-		public void Start() { lock(this) {
-			System.Threading.Monitor.Enter(keepAliveLock);
-			(new Thread(new ThreadStart(KeepAlive))).Start();
-
-			RunSimProxy();
-			Thread runLoginProxy = new Thread(new ThreadStart(RunLoginProxy));
-			runLoginProxy.IsBackground = true;
-			runLoginProxy.Start();
-
-			IPEndPoint endPoint = (IPEndPoint)loginServer.LocalEndPoint;
-			IPAddress displayAddress;
-			if (endPoint.Address == IPAddress.Any)
-				displayAddress = IPAddress.Loopback;
-			else
-				displayAddress = endPoint.Address;
-			Log(&quot;proxy ready at <A HREF="http://">http://</A>&quot; + displayAddress + &quot;:&quot; + endPoint.Port + &quot;/&quot;, false);
-		}}
-
-		// Stop: allow foreground threads to die
-		public void Stop() { lock(this) {
-			System.Threading.Monitor.Exit(keepAliveLock);
-		}}
-
-		// KeepAlive: blocks until the proxy is free to shut down
-		public void KeepAlive() {
-			lock(keepAliveLock);
-		}
-
-		// SetLoginRequestDelegate: specify a callback loginRequestDelegate that will be called when the client requests login
-		public void SetLoginRequestDelegate(XmlRpcRequestDelegate loginRequestDelegate) { lock(this) {
-			this.loginRequestDelegate = loginRequestDelegate;
-		}}
-
-		// SetLoginResponseDelegate: specify a callback loginResponseDelegate that will be called when the server responds to login
-		public void SetLoginResponseDelegate(XmlRpcResponseDelegate loginResponseDelegate) { lock(this) {
-			this.loginResponseDelegate = loginResponseDelegate;
-		}}
-
-		// AddDelegate: add callback packetDelegate for packets of type packetName going direction
-		public void AddDelegate(string packetName, Direction direction, PacketDelegate packetDelegate) { lock(this) {
-			(direction == Direction.Incoming ? incomingDelegates : outgoingDelegates)[packetName] = packetDelegate;
-		}}
-
-		// RemoveDelegate: remove callback for packets of type packetName going direction
-		public void RemoveDelegate(string packetName, Direction direction) { lock(this) {
-			(direction == Direction.Incoming ? incomingDelegates : outgoingDelegates).Remove(packetName);
-		}}
-
-		// InjectPacket: send packet to the client or server when direction is Incoming or Outgoing, respectively
-		public void InjectPacket(Packet packet, Direction direction) { lock(this) {
-			if (activeCircuit == null) {
-				// no active circuit; queue the packet for injection once we have one
-				ArrayList queue = direction == Direction.Incoming ? queuedIncomingInjections : queuedOutgoingInjections;
-				queue.Add(packet);
-			} else
-				// tell the active sim proxy to inject the packet
-				((SimProxy)simProxies[activeCircuit]).Inject(packet, direction);
-		}}
-
-		// Log: write message to the console if in verbose mode
-		private void Log(object message, bool important) {
-			if (proxyConfig.verbose || important)
-				Console.WriteLine(message);
-		}
-
-		/*
-		 * Login Proxy
-		 */
-
-		private Socket loginServer;
-
-		// InitializeLoginProxy: initialize the login proxy
-		private void InitializeLoginProxy() {
-			loginServer = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
-			loginServer.Bind(new IPEndPoint(proxyConfig.clientFacingAddress, proxyConfig.loginPort));
-			loginServer.Listen(1);
-		}
-
-		// RunLoginProxy: process login requests from clients
-		private void RunLoginProxy() {
-		    try {
-			for (;;) {
-				Socket client = loginServer.Accept();
-				IPEndPoint clientEndPoint = (IPEndPoint)client.RemoteEndPoint;
-
-				Log(&quot;handling login request from &quot; + clientEndPoint, false);
-
-				NetworkStream networkStream = new NetworkStream(client);
-				StreamReader networkReader = new StreamReader(networkStream);
-				StreamWriter networkWriter = new StreamWriter(networkStream);
-
-				try {
-					ProxyLogin(networkReader, networkWriter);
-				} catch (Exception e) {
-					Log(&quot;login failed: &quot; + e.Message, false);
-				}
-
-				networkWriter.Close();
-				networkReader.Close();
-				networkStream.Close();
-
-				client.Close();
-
-				// send any packets queued for injection
-				if (activeCircuit != null) lock(this) {
-					SimProxy activeProxy = (SimProxy)simProxies[activeCircuit];
-					foreach (Packet packet in queuedOutgoingInjections)
-						activeProxy.Inject(packet, Direction.Outgoing);
-					queuedOutgoingInjections = new ArrayList();
-				}
-			}
-		    } catch (Exception e) {
-			Console.WriteLine(e.Message);
-			Console.WriteLine(e.StackTrace);
-		    }
-		}
-
-		// ProxyLogin: proxy a login request
-		private void ProxyLogin(StreamReader reader, StreamWriter writer) { lock(this) {
-			string line;
-			int contentLength = 0;
-
-			// read HTTP header
-			do {
-				// read one line of the header
-				line = reader.ReadLine();
-
-				// check for premature EOF
-				if (line == null)
-					throw new Exception(&quot;EOF in client HTTP header&quot;);
-
-				// look for Content-Length
-				Match match = (new Regex(@&quot;Content-Length: (\d+)$&quot;)).Match(line);
-				if (match.Success)
-					contentLength = Convert.ToInt32(match.Groups[1].Captures[0].ToString());
-			} while (line != &quot;&quot;);
-
-			// read the HTTP body into a buffer
-			char[] content = new char[contentLength];
-			reader.Read(content, 0, contentLength);
-
-			// convert the body into an XML-RPC request
-			XmlRpcRequest request = (XmlRpcRequest)(new XmlRpcRequestDeserializer()).Deserialize(new String(content));
-
-			// call the loginRequestDelegate
-			if (loginRequestDelegate != null)
-				try {
-					loginRequestDelegate(request);
-				} catch (Exception e) {
-					Log(&quot;exception in login request deligate: &quot; + e.Message, true);
-					Log(e.StackTrace, true);
-				}
-
-			// add our userAgent and author to the request
-			Hashtable requestParams = new Hashtable();
-			if (proxyConfig.userAgent != null)
-				requestParams[&quot;user-agent&quot;] = proxyConfig.userAgent;
-			if (proxyConfig.author != null)
-				requestParams[&quot;author&quot;] = proxyConfig.author;
-			request.Params.Add(requestParams);
-
-			// forward the XML-RPC request to the server
-			XmlRpcResponse response = (XmlRpcResponse)request.Send(proxyConfig.remoteLoginUri.ToString());
-			Hashtable responseData = (Hashtable)response.Value;
-
-			// proxy any simulator address given in the XML-RPC response
-			if (responseData.Contains(&quot;sim_ip&quot;) &amp;&amp; responseData.Contains(&quot;sim_port&quot;)) {
-				IPEndPoint realSim = new IPEndPoint(IPAddress.Parse((string)responseData[&quot;sim_ip&quot;]), Convert.ToUInt16(responseData[&quot;sim_port&quot;]));
-				IPEndPoint fakeSim = ProxySim(realSim);
-				responseData[&quot;sim_ip&quot;] = fakeSim.Address.ToString();
-				responseData[&quot;sim_port&quot;] = fakeSim.Port;
-				activeCircuit = realSim;
-			}
-
-			// start a new proxy session
-			Reset();
-
-			// call the loginResponseDelegate
-			if (loginResponseDelegate != null) {
-				try {
-					loginResponseDelegate(response);
-				} catch (Exception e) {
-					Log(&quot;exception in login response delegate: &quot; + e.Message, true);
-					Log(e.StackTrace, true);
-				}
-			}
-
+/*
+ * SLProxy.cs: implementation of Second Life proxy library
+ *
+ * Copyright (c) 2006 Austin Jennings
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the Second Life Reverse Engineering Team nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+//#define DEBUG_SEQUENCE
+
+using Nwc.XmlRpc;
+using System;
+using System.Collections;
+using System.IO;
+using System.Net;
+using System.Net.Sockets;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading;
+using System.Xml;
+using libsecondlife;
+
+// SLProxy: proxy library for Second Life
+namespace SLProxy {
+	// ProxyConfig: configuration for proxy objects
+	public class ProxyConfig {
+		// userAgent: name of the proxy application
+		public string userAgent;
+		// author: email address of the proxy application's author
+		public string author;
+		// protocol: libsecondlife ProtocolManager
+		public ProtocolManager protocol;
+		// loginPort: port that the login proxy will listen on
+		public ushort loginPort = 8080;
+		// clientFacingAddress: address from which to communicate with the client
+		public IPAddress clientFacingAddress = IPAddress.Loopback;
+		// remoteFacingAddress: address from which to communicate with the server
+		public IPAddress remoteFacingAddress = IPAddress.Any;
+		// remoteLoginUri: URI for Second Life's login server
+		public Uri remoteLoginUri = new Uri(&quot;<A HREF="https://login.agni.lindenlab.com/cgi-bin/login.cgi">https://login.agni.lindenlab.com/cgi-bin/login.cgi</A>&quot;);
+		// verbose: whether or not to print informative messages
+		public bool verbose = true;
+
+		// ProxyConfig: construct a default proxy configuration with the specified userAgent, author, and protocol
+		public ProxyConfig(string userAgent, string author, ProtocolManager protocol) {
+			this.userAgent = userAgent;
+			this.author = author;
+			this.protocol = protocol;
+		}
+
+		// ProxyConfig: construct a default proxy configuration, parsing command line arguments (try --proxy-help)
+		public ProxyConfig(string userAgent, string author, ProtocolManager protocol, string[] args) : this(userAgent, author, protocol) {
+			Hashtable argumentParsers = new Hashtable();
+			argumentParsers[&quot;proxy-help&quot;] = new ArgumentParser(ParseHelp);
+			argumentParsers[&quot;proxy-login-port&quot;] = new ArgumentParser(ParseLoginPort);
+			argumentParsers[&quot;proxy-client-facing-address&quot;] = new ArgumentParser(ParseClientFacingAddress);
+			argumentParsers[&quot;proxy-remote-facing-address&quot;] = new ArgumentParser(ParseRemoteFacingAddress);
+			argumentParsers[&quot;proxy-remote-login-uri&quot;] = new ArgumentParser(ParseRemoteLoginUri);
+			argumentParsers[&quot;proxy-verbose&quot;] = new ArgumentParser(ParseVerbose);
+			argumentParsers[&quot;proxy-quiet&quot;] = new ArgumentParser(ParseQuiet);
+
+			foreach (string arg in args)
+				foreach (string argument in argumentParsers.Keys) {
+					Match match = (new Regex(&quot;^--&quot; + argument + &quot;(?:=(.*))?$&quot;)).Match(arg);
+					if (match.Success) {
+						string value;
+						if (match.Groups[1].Captures.Count == 1)
+							value = match.Groups[1].Captures[0].ToString();
+						else
+							value = null;
+						try {
+							((ArgumentParser)argumentParsers[argument])(value);
+						} catch {
+							Console.WriteLine(&quot;invalid value for --&quot; + argument);
+							ParseHelp(null);
+						}
+					}
+				}
+		}
+
+		private delegate void ArgumentParser(string value);
+
+		private void ParseHelp(string value) {
+			Console.WriteLine(&quot;Proxy command-line arguments:&quot;                                                   );
+			Console.WriteLine(&quot;  --proxy-help                        display this help&quot;                         );
+			Console.WriteLine(&quot;  --proxy-login-port=&lt;port&gt;           listen for logins on &lt;port&gt;&quot;               );
+			Console.WriteLine(&quot;  --proxy-client-facing-address=&lt;IP&gt;  communicate with client via &lt;IP&gt;&quot;          );
+			Console.WriteLine(&quot;  --proxy-remote-facing-address=&lt;IP&gt;  communicate with server via &lt;IP&gt;&quot;          );
+			Console.WriteLine(&quot;  --proxy-remote-login-uri=&lt;URI&gt;      use SL login server at &lt;URI&gt;&quot;              );
+			Console.WriteLine(&quot;  --proxy-verbose                     display proxy notifications&quot;               );
+			Console.WriteLine(&quot;  --proxy-quiet                       suppress proxy notifications&quot;              );
+
+			Environment.Exit(1);
+		}
+
+		private void ParseLoginPort(string value) {
+			loginPort = Convert.ToUInt16(value);
+		}
+
+		private void ParseClientFacingAddress(string value) {
+			clientFacingAddress = IPAddress.Parse(value);
+		}
+
+		private void ParseRemoteFacingAddress(string value) {
+			remoteFacingAddress = IPAddress.Parse(value);
+		}
+
+		private void ParseRemoteLoginUri(string value) {
+			remoteLoginUri = new Uri(value);
+		}
+
+		private void ParseVerbose(string value) {
+			if (value != null)
+				throw new Exception();
+
+			verbose = true;
+		}
+
+		private void ParseQuiet(string value) {
+			if (value != null)
+				throw new Exception();
+
+			verbose = false;
+		}
+	}
+
+	// Proxy: Second Life proxy server
+	// A Proxy instance is only prepared to deal with one client at a time.
+	public class Proxy {
+		private ProxyConfig proxyConfig;
+
+		/*
+		 * Proxy Management
+		 */
+
+		// Proxy: construct a proxy server with the given configuration
+		public Proxy(ProxyConfig proxyConfig) {
+			this.proxyConfig = proxyConfig;
+
+			InitializeLoginProxy();
+			InitializeSimProxy();
+		}
+
+		object keepAliveLock = new Object();
+
+		// Start: begin accepting clients
+		public void Start() { lock(this) {
+			System.Threading.Monitor.Enter(keepAliveLock);
+			(new Thread(new ThreadStart(KeepAlive))).Start();
+
+			RunSimProxy();
+			Thread runLoginProxy = new Thread(new ThreadStart(RunLoginProxy));
+			runLoginProxy.IsBackground = true;
+			runLoginProxy.Start();
+
+			IPEndPoint endPoint = (IPEndPoint)loginServer.LocalEndPoint;
+			IPAddress displayAddress;
+			if (endPoint.Address == IPAddress.Any)
+				displayAddress = IPAddress.Loopback;
+			else
+				displayAddress = endPoint.Address;
+			Log(&quot;proxy ready at <A HREF="http://">http://</A>&quot; + displayAddress + &quot;:&quot; + endPoint.Port + &quot;/&quot;, false);
+		}}
+
+		// Stop: allow foreground threads to die
+		public void Stop() { lock(this) {
+			System.Threading.Monitor.Exit(keepAliveLock);
+		}}
+
+		// KeepAlive: blocks until the proxy is free to shut down
+		public void KeepAlive() {
+            lock (keepAliveLock) { };
+		}
+
+		// SetLoginRequestDelegate: specify a callback loginRequestDelegate that will be called when the client requests login
+		public void SetLoginRequestDelegate(XmlRpcRequestDelegate loginRequestDelegate) { lock(this) {
+			this.loginRequestDelegate = loginRequestDelegate;
+		}}
+
+		// SetLoginResponseDelegate: specify a callback loginResponseDelegate that will be called when the server responds to login
+		public void SetLoginResponseDelegate(XmlRpcResponseDelegate loginResponseDelegate) { lock(this) {
+			this.loginResponseDelegate = loginResponseDelegate;
+		}}
+
+		// AddDelegate: add callback packetDelegate for packets of type packetName going direction
+		public void AddDelegate(string packetName, Direction direction, PacketDelegate packetDelegate) { lock(this) {
+			(direction == Direction.Incoming ? incomingDelegates : outgoingDelegates)[packetName] = packetDelegate;
+		}}
+
+		// RemoveDelegate: remove callback for packets of type packetName going direction
+		public void RemoveDelegate(string packetName, Direction direction) { lock(this) {
+			(direction == Direction.Incoming ? incomingDelegates : outgoingDelegates).Remove(packetName);
+		}}
+
+		// InjectPacket: send packet to the client or server when direction is Incoming or Outgoing, respectively
+		public void InjectPacket(Packet packet, Direction direction) { lock(this) {
+			if (activeCircuit == null) {
+				// no active circuit; queue the packet for injection once we have one
+				ArrayList queue = direction == Direction.Incoming ? queuedIncomingInjections : queuedOutgoingInjections;
+				queue.Add(packet);
+			} else
+				// tell the active sim proxy to inject the packet
+				((SimProxy)simProxies[activeCircuit]).Inject(packet, direction);
+		}}
+
+		// Log: write message to the console if in verbose mode
+		private void Log(object message, bool important) {
+			if (proxyConfig.verbose || important)
+				Console.WriteLine(message);
+		}
+
+		/*
+		 * Login Proxy
+		 */
+
+		private Socket loginServer;
+
+		// InitializeLoginProxy: initialize the login proxy
+		private void InitializeLoginProxy() {
+			loginServer = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
+			loginServer.Bind(new IPEndPoint(proxyConfig.clientFacingAddress, proxyConfig.loginPort));
+			loginServer.Listen(1);
+		}
+
+		// RunLoginProxy: process login requests from clients
+		private void RunLoginProxy() {
+		    try {
+			for (;;) {
+				Socket client = loginServer.Accept();
+				IPEndPoint clientEndPoint = (IPEndPoint)client.RemoteEndPoint;
+
+				Log(&quot;handling login request from &quot; + clientEndPoint, false);
+
+				NetworkStream networkStream = new NetworkStream(client);
+				StreamReader networkReader = new StreamReader(networkStream);
+				StreamWriter networkWriter = new StreamWriter(networkStream);
+
+				try {
+					ProxyLogin(networkReader, networkWriter);
+				} catch (Exception e) {
+					Log(&quot;login failed: &quot; + e.Message, false);
+				}
+
+				networkWriter.Close();
+				networkReader.Close();
+				networkStream.Close();
+
+				client.Close();
+
+				// send any packets queued for injection
+				if (activeCircuit != null) lock(this) {
+					SimProxy activeProxy = (SimProxy)simProxies[activeCircuit];
+					foreach (Packet packet in queuedOutgoingInjections)
+						activeProxy.Inject(packet, Direction.Outgoing);
+					queuedOutgoingInjections = new ArrayList();
+				}
+			}
+		    } catch (Exception e) {
+			Console.WriteLine(e.Message);
+			Console.WriteLine(e.StackTrace);
+		    }
+		}
+
+		// ProxyLogin: proxy a login request
+		private void ProxyLogin(StreamReader reader, StreamWriter writer) { lock(this) {
+			string line;
+			int contentLength = 0;
+
+			// read HTTP header
+			do {
+				// read one line of the header
+				line = reader.ReadLine();
+
+				// check for premature EOF
+				if (line == null)
+					throw new Exception(&quot;EOF in client HTTP header&quot;);
+
+				// look for Content-Length
+				Match match = (new Regex(@&quot;Content-Length: (\d+)$&quot;)).Match(line);
+				if (match.Success)
+					contentLength = Convert.ToInt32(match.Groups[1].Captures[0].ToString());
+			} while (line != &quot;&quot;);
+
+			// read the HTTP body into a buffer
+			char[] content = new char[contentLength];
+			reader.Read(content, 0, contentLength);
+
+			// convert the body into an XML-RPC request
+			XmlRpcRequest request = (XmlRpcRequest)(new XmlRpcRequestDeserializer()).Deserialize(new String(content));
+
+			// call the loginRequestDelegate
+			if (loginRequestDelegate != null)
+				try {
+					loginRequestDelegate(request);
+				} catch (Exception e) {
+					Log(&quot;exception in login request deligate: &quot; + e.Message, true);
+					Log(e.StackTrace, true);
+				}
+
+			// add our userAgent and author to the request
+			Hashtable requestParams = new Hashtable();
+			if (proxyConfig.userAgent != null)
+				requestParams[&quot;user-agent&quot;] = proxyConfig.userAgent;
+			if (proxyConfig.author != null)
+				requestParams[&quot;author&quot;] = proxyConfig.author;
+			request.Params.Add(requestParams);
+
+			// forward the XML-RPC request to the server
+			XmlRpcResponse response = (XmlRpcResponse)request.Send(proxyConfig.remoteLoginUri.ToString());
+			Hashtable responseData = (Hashtable)response.Value;
+
+			// proxy any simulator address given in the XML-RPC response
+			if (responseData.Contains(&quot;sim_ip&quot;) &amp;&amp; responseData.Contains(&quot;sim_port&quot;)) {
+				IPEndPoint realSim = new IPEndPoint(IPAddress.Parse((string)responseData[&quot;sim_ip&quot;]), Convert.ToUInt16(responseData[&quot;sim_port&quot;]));
+				IPEndPoint fakeSim = ProxySim(realSim);
+				responseData[&quot;sim_ip&quot;] = fakeSim.Address.ToString();
+				responseData[&quot;sim_port&quot;] = fakeSim.Port;
+				activeCircuit = realSim;
+			}
+
+			// start a new proxy session
+			Reset();
+
+			// call the loginResponseDelegate
+			if (loginResponseDelegate != null) {
+				try {
+					loginResponseDelegate(response);
+				} catch (Exception e) {
+					Log(&quot;exception in login response delegate: &quot; + e.Message, true);
+					Log(e.StackTrace, true);
+				}
+			}
+
 			// forward the XML-RPC response to the client
             writer.WriteLine(&quot;HTTP/1.0 200 OK&quot;);
             writer.WriteLine(&quot;Content-type: text/xml&quot;);
-            writer.WriteLine();
-
-			XmlTextWriter responseWriter = new XmlTextWriter(writer);
-			XmlRpcResponseSerializer.Singleton.Serialize(responseWriter, response);
-			responseWriter.Close();
-		}}
-
-		/*
-		 * Sim Proxy
-		 */
-
-		private Socket simFacingSocket;
-		private IPEndPoint activeCircuit = null;
-		private Hashtable proxyEndPoints = new Hashtable();
-		private Hashtable simProxies = new Hashtable();
-		private Hashtable proxyHandlers = new Hashtable();
-		private XmlRpcRequestDelegate loginRequestDelegate = null;
-		private XmlRpcResponseDelegate loginResponseDelegate = null;
-		private Hashtable incomingDelegates = new Hashtable();
-		private Hashtable outgoingDelegates = new Hashtable();
-		private ArrayList queuedIncomingInjections = new ArrayList();
-		private ArrayList queuedOutgoingInjections = new ArrayList();
-
-		// InitializeSimProxy: initialize the sim proxy
-		private void InitializeSimProxy() {
-			InitializeAddressCheckers();
-
-			simFacingSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
-			simFacingSocket.Bind(new IPEndPoint(proxyConfig.remoteFacingAddress, 0));
-			Reset();
-		}
-
-		// Reset: start a new session
-		private void Reset() {
-			foreach (SimProxy simProxy in simProxies.Values)
-				simProxy.Reset();
-		}
-
-		private byte[] receiveBuffer = new byte[8192];
-		private byte[] zeroBuffer = new byte[8192];
-		private EndPoint remoteEndPoint = (EndPoint)new IPEndPoint(IPAddress.Any, 0);
-
-		// RunSimProxy: start listening for packets from remote sims
-		private void RunSimProxy() {
-			simFacingSocket.BeginReceiveFrom(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, ref remoteEndPoint, new AsyncCallback(ReceiveFromSim), null);
-		}
-
-		// ReceiveFromSim: packet received from a remote sim
-		private void ReceiveFromSim(IAsyncResult ar) { lock(this) try {
-			// pause listening and fetch the packet
-			bool needsZero = false;
-			bool needsCopy = true;
-			int length;
-			length = simFacingSocket.EndReceiveFrom(ar, ref remoteEndPoint);
-
-			if (proxyHandlers.Contains(remoteEndPoint)) {
-				// find the proxy responsible for forwarding this packet
-				SimProxy simProxy = (SimProxy)proxyHandlers[remoteEndPoint];
-
-				// interpret the packet according to the SL protocol
-				Packet packet;
-				if ((receiveBuffer[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(receiveBuffer), false);
-				else {
-					Helpers.ZeroDecodeCommand(receiveBuffer, zeroBuffer);
-					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(zeroBuffer), false);
-					needsZero = true;
-				}
-#if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;&lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
-#endif
-
-				// check for ACKs we're waiting for
-				packet = simProxy.CheckAcks(packet, Direction.Incoming, ref length, ref needsCopy);
-
-				// modify sequence numbers to account for injections
-				ushort oldSequence = packet.Sequence;
-				packet = simProxy.ModifySequence(packet, Direction.Incoming, ref length, ref needsCopy);
-
-				// keep track of sequence numbers
-				if (packet.Sequence &gt; simProxy.incomingSequence)
-					simProxy.incomingSequence = packet.Sequence;
-
-				// check the packet for addresses that need proxying
-				if (incomingCheckers.Contains(packet.Layout.Name)) {
-					if (needsZero) {
-						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
-						packet.Data = zeroBuffer;
-						needsZero = false;
-					}
-
-					Packet newPacket = ((AddressChecker)incomingCheckers[packet.Layout.Name])(packet);
-					SwapPacket(packet, newPacket, length);
-					packet = newPacket;
-					length = packet.Data.Length;
-					needsCopy = false;
-				}
-
-				// pass the packet to any callback delegates
-				if (incomingDelegates.Contains(packet.Layout.Name)) {
-					if (needsZero) {
-						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
-						packet.Data = zeroBuffer;
-						needsCopy = true;
-					}
-
-					if (needsCopy) {
-						byte[] newData = new byte[length];
-						Array.Copy(packet.Data, 0, newData, 0, length);
-						packet.Data = newData;
-					}
-
-					try {
-						Packet newPacket = ((PacketDelegate)incomingDelegates[packet.Layout.Name])(packet, (IPEndPoint)remoteEndPoint);
-						if (newPacket == null) {
-							if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
-								simProxy.Inject(SpoofAck(oldSequence), Direction.Outgoing);
-
-							if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
-								packet = SeparateAck(packet);
-							else
-								packet = null;
-						} else {
-							bool oldReliable = (packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
-							bool newReliable = (newPacket.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
-							if (oldReliable &amp;&amp; !newReliable)
-								simProxy.Inject(SpoofAck(oldSequence), Direction.Outgoing);
-							else if (!oldReliable &amp;&amp; newReliable)
-								simProxy.WaitForAck(packet, Direction.Incoming);
-
-							SwapPacket(packet, newPacket, packet.Data.Length);
-							packet = newPacket;
-						}
-					} catch (Exception e) {
-						Log(&quot;exception in incoming delegate: &quot; + e.Message, true);
-						Log(e.StackTrace, true);
-					}
-
-					if (packet != null)
-						simProxy.SendPacket(packet, packet.Data.Length, false);
-				} else
-					simProxy.SendPacket(packet, length, needsZero);
-			} else
-				// ignore packets from unknown peers
-				Log(&quot;dropping packet from &quot; + remoteEndPoint, false);
-		} catch (Exception e) {
-			Console.WriteLine(e.Message);
-			Console.WriteLine(e.StackTrace);
-		} finally {
-			// resume listening
-			simFacingSocket.BeginReceiveFrom(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, ref remoteEndPoint, new AsyncCallback(ReceiveFromSim), null);
-		}}
-
-		// SendPacket: send a packet to a sim from our fake client endpoint
-		public void SendPacket(Packet packet, IPEndPoint endPoint, int length, bool skipZero) {
-			if (skipZero || (packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-				simFacingSocket.SendTo(packet.Data, length, SocketFlags.None, endPoint);
-			else {
-				int zeroLength = Helpers.ZeroEncode(packet.Data, length, zeroBuffer);
-				simFacingSocket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, endPoint);
-			}
-		}
-
-		// SpoofAck: create an ACK for the given packet
-		public Packet SpoofAck(ushort sequence) {
-			Hashtable blocks = new Hashtable();
-			Hashtable fields = new Hashtable();
-			fields[&quot;ID&quot;] = (uint)sequence;
-			blocks[fields] = &quot;Packets&quot;;
-			return PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, Helpers.MSG_ZEROCODED);
-		}
-
-		// SeparateAck: create a standalone PacketAck for packet's appended ACKs
-		public Packet SeparateAck(Packet packet) {
-			int ackCount = ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)packet.Data[packet.Data.Length - 1]);
-			Hashtable blocks = new Hashtable();
-			for (int i = 0; i &lt; ackCount; ++i) {
-				Hashtable fields = new Hashtable();
-				int offset = packet.Data.Length - (ackCount - i) * 4 - 1;
-				fields[&quot;ID&quot;] = (uint)
-					  (packet.Data[offset++] &lt;&lt;  0)
-					+ (packet.Data[offset++] &lt;&lt;  8)
-					+ (packet.Data[offset++] &lt;&lt; 16)
-					+ (packet.Data[offset++] &lt;&lt; 24)
-					;
-				blocks[fields] = &quot;Packets&quot;;
-			}
-
-			Packet ack = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, Helpers.MSG_ZEROCODED);
-			ack.Sequence = packet.Sequence;
-			return ack;
-		}
-
-		// SwapPacket: copy the sequence number and appended ACKs from one packet to another
-		public static void SwapPacket(Packet oldPacket, Packet newPacket, int oldLength) {
-			newPacket.Sequence = oldPacket.Sequence;
-
-			int oldAcks = (oldPacket.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)oldPacket.Data[oldLength - 1];
-			int newAcks = (newPacket.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)newPacket.Data[newPacket.Data.Length - 1];
-
-			if (oldAcks != 0 || newAcks != 0) {
-				int oldAckSize = oldAcks == 0 ? 0 : oldAcks * 4 + 1;
-				int newAckSize = newAcks == 0 ? 0 : newAcks * 4 + 1;
-
-				byte[] newData = new byte[newPacket.Data.Length - newAckSize + oldAckSize];
-				Array.Copy(newPacket.Data, 0, newData, 0, newPacket.Data.Length - newAckSize);
-
-				if (newAcks != 0)
-					newData[0] ^= Helpers.MSG_APPENDED_ACKS;
-
-				if (oldAcks != 0) {
-					newData[0] |= Helpers.MSG_APPENDED_ACKS;
-					Array.Copy(oldPacket.Data, oldLength - oldAckSize, newData, newPacket.Data.Length - newAckSize, oldAckSize);
-				}
-
-				newPacket.Data = newData;
-			}
-		}
-
-		// ProxySim: return the proxy for the specified sim, creating it if it doesn't exist
-		private IPEndPoint ProxySim(IPEndPoint simEndPoint) {
-			if (proxyEndPoints.Contains(simEndPoint))
-				// return the existing proxy
-				return (IPEndPoint)proxyEndPoints[simEndPoint];
-			else {
-				// return a new proxy
-				SimProxy simProxy = new SimProxy(proxyConfig, simEndPoint, this);
-				IPEndPoint fakeSim = simProxy.LocalEndPoint();
-				Log(&quot;creating proxy for &quot; + simEndPoint + &quot; at &quot; + fakeSim, false);
-				simProxy.Run();
-				proxyEndPoints.Add(simEndPoint, fakeSim);
-				simProxies.Add(simEndPoint, simProxy);
-				return fakeSim;
-			}
-		}
-
-		// AddHandler: remember which sim proxy corresponds to a given sim
-		private void AddHandler(EndPoint endPoint, SimProxy proxy) {
-			proxyHandlers.Add(endPoint, proxy);
-		}
-
-		// SimProxy: proxy for a single simulator
-		private class SimProxy {
-			private ProxyConfig proxyConfig;
-			private IPEndPoint remoteEndPoint;
-			private Proxy proxy;
-			private Socket socket;
-			public ushort incomingSequence;
-			public ushort outgoingSequence;
-			private ArrayList incomingInjections;
-			private ArrayList outgoingInjections;
-			private ushort incomingOffset = 0;
-			private ushort outgoingOffset = 0;
-			private Hashtable incomingAcks;
-			private Hashtable outgoingAcks;
-			private ArrayList incomingSeenAcks;
-			private ArrayList outgoingSeenAcks;
-
-			// SimProxy: construct a proxy for a single simulator
-			public SimProxy(ProxyConfig proxyConfig, IPEndPoint simEndPoint, Proxy proxy) {
-				this.proxyConfig = proxyConfig;
-				remoteEndPoint = new IPEndPoint(simEndPoint.Address, simEndPoint.Port);
-				this.proxy = proxy;
-				socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
-				socket.Bind(new IPEndPoint(proxyConfig.clientFacingAddress, 0));
-				proxy.AddHandler(remoteEndPoint, this);
-				Reset();
-			}
-
-			// Reset: start a new session
-			public void Reset() {
-				incomingSequence = 0;
-				outgoingSequence = 0;
-				incomingInjections = new ArrayList();
-				outgoingInjections = new ArrayList();
-				incomingAcks = new Hashtable();
-				outgoingAcks = new Hashtable();
-				incomingSeenAcks = new ArrayList();
-				outgoingSeenAcks = new ArrayList();
-			}
-
-			// BackgroundTasks: resend unacknowledged packets and keep data structures clean
-			private void BackgroundTasks() { try {
-				int tick = 1;
-				int incomingInjectionsPoint = 0;
-				int outgoingInjectionsPoint = 0;
-				int incomingSeenAcksPoint = 0;
-				int outgoingSeenAcksPoint = 0;
-
-				for (;; Thread.Sleep(1000)) lock(proxy) {
-					if ((tick = (tick + 1) % 60) == 0) {
-						for (int i = 0; i &lt; incomingInjectionsPoint; ++i) {
-							incomingInjections.RemoveAt(0);
-							++incomingOffset;
-#if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;incomingOffset = &quot; + incomingOffset);
-#endif
-						}
-						incomingInjectionsPoint = incomingInjections.Count;
-
-						for (int i = 0; i &lt; outgoingInjectionsPoint; ++i) {
-							outgoingInjections.RemoveAt(0);
-							++outgoingOffset;
-#if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;outgoingOffset = &quot; + outgoingOffset);
-#endif
-						}
-						outgoingInjectionsPoint = outgoingInjections.Count;
-
-						for (int i = 0; i &lt; incomingSeenAcksPoint; ++i) {
-#if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;incomingAcks.Remove(&quot; + incomingSeenAcks[0] + &quot;)&quot;);
-#endif
-							incomingAcks.Remove(incomingSeenAcks[0]);
-							incomingSeenAcks.RemoveAt(0);
-						}
-						incomingSeenAcksPoint = incomingSeenAcks.Count;
-
-						for (int i = 0; i &lt; outgoingSeenAcksPoint; ++i) {
-#if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;outgoingAcks.Remove(&quot; + outgoingSeenAcks[0] + &quot;)&quot;);
-#endif
-							outgoingAcks.Remove(outgoingSeenAcks[0]);
-							outgoingSeenAcks.RemoveAt(0);
-						}
-						outgoingSeenAcksPoint = outgoingSeenAcks.Count;
-					}
-
-					foreach (ushort id in incomingAcks.Keys)
-						if (!incomingSeenAcks.Contains(id)) {
-							Packet packet = (Packet)incomingAcks[id];
-							packet.Data[0] |= Helpers.MSG_RESENT;
-#if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;RESEND &lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
-#endif
-							SendPacket(packet, packet.Data.Length, false);
-						}
-
-					foreach (ushort id in outgoingAcks.Keys)
-						if (!outgoingSeenAcks.Contains(id)) {
-							Packet packet = (Packet)outgoingAcks[id];
-							packet.Data[0] |= Helpers.MSG_RESENT;
-#if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;RESEND -&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
-#endif
-							proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
-						}
-				}
-			} catch (Exception e) {
-				Console.WriteLine(e.Message);
-				Console.WriteLine(e.StackTrace);
-			}}
-
-			// LocalEndPoint: return the endpoint that the client should communicate with
-			public IPEndPoint LocalEndPoint() {
-				return (IPEndPoint)socket.LocalEndPoint;
-			}
-
-			private byte[] receiveBuffer = new byte[8192];
-			private byte[] zeroBuffer = new byte[8192];
-			private EndPoint clientEndPoint = new IPEndPoint(IPAddress.Any, 0);
-			bool firstReceive = true;
-
-			// Run: forward packets from the client to the sim
-			public void Run() {
-				Thread backgroundTasks = new Thread(new ThreadStart(BackgroundTasks));
-				backgroundTasks.IsBackground = true;
-				backgroundTasks.Start();
-				socket.BeginReceiveFrom(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, ref clientEndPoint, new AsyncCallback(ReceiveFromClient), null);
-			}
-
-			// ReceiveFromClient: packet received from the client
-			private void ReceiveFromClient(IAsyncResult ar) { lock(proxy) try {
-				// pause listening and fetch the packet
-				bool needsZero = false;
-				bool needsCopy = true;
-				int length;
-				length = socket.EndReceiveFrom(ar, ref clientEndPoint);
-
-				// interpret the packet according to the SL protocol
-				Packet packet;
-				if ((receiveBuffer[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(receiveBuffer), false);
-				else {
-					Helpers.ZeroDecodeCommand(receiveBuffer, zeroBuffer);
-					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(zeroBuffer), false);
-					needsZero = true;
-				}
-#if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;-&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
-#endif
-
-				// check for ACKs we're waiting for
-				packet = CheckAcks(packet, Direction.Outgoing, ref length, ref needsCopy);
-
-				// modify sequence numbers to account for injections
-				ushort oldSequence = packet.Sequence;
-				packet = ModifySequence(packet, Direction.Outgoing, ref length, ref needsCopy);
-
-				// keep track of sequence numbers
-				if (packet.Sequence &gt; outgoingSequence)
-					outgoingSequence = packet.Sequence;
-
-				// check the packet for addresses that need proxying
-				if (proxy.outgoingCheckers.Contains(packet.Layout.Name)) {
-					if (needsZero) {
-						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
-						packet.Data = zeroBuffer;
-						needsZero = false;
-					}
-
-					Packet newPacket = ((AddressChecker)proxy.outgoingCheckers[packet.Layout.Name])(packet);
-					SwapPacket(packet, newPacket, length);
-					packet = newPacket;
-					length = packet.Data.Length;
-					needsCopy = false;
-				}
-
-				// pass the packet to any callback delegates
-				if (proxy.outgoingDelegates.Contains(packet.Layout.Name)) {
-					if (needsZero) {
-						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
-						packet.Data = zeroBuffer;
-						needsCopy = true;
-					}
-
-					if (needsCopy) {
-						byte[] newData = new byte[length];
-						Array.Copy(packet.Data, 0, newData, 0, length);
-						packet.Data = newData;
-					}
-
-					try {
-						Packet newPacket = ((PacketDelegate)proxy.outgoingDelegates[packet.Layout.Name])(packet, remoteEndPoint);
-						if (newPacket == null) {
-							if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
-								Inject(proxy.SpoofAck(oldSequence), Direction.Incoming);
-
-							if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
-								packet = proxy.SeparateAck(packet);
-							else
-								packet = null;
-						} else {
-							bool oldReliable = (packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
-							bool newReliable = (newPacket.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
-							if (oldReliable &amp;&amp; !newReliable)
-								Inject(proxy.SpoofAck(oldSequence), Direction.Incoming);
-							else if (!oldReliable &amp;&amp; newReliable)	
-								WaitForAck(packet, Direction.Outgoing);
-
-							SwapPacket(packet, newPacket, packet.Data.Length);
-							packet = newPacket;
-						}
-					} catch (Exception e) {
-						proxy.Log(&quot;exception in outgoing delegate: &quot; + e.Message, true);
-						proxy.Log(e.StackTrace, true);
-					}
-
-					if (packet != null)
-						proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
-				} else
-					proxy.SendPacket(packet, remoteEndPoint, length, needsZero);
-
-				// send any packets queued for injection
-				if (firstReceive) {
-					firstReceive = false;
-					foreach (Packet queuedPacket in proxy.queuedIncomingInjections)
-						Inject(queuedPacket, Direction.Incoming);
-					proxy.queuedIncomingInjections = new ArrayList();
-				}
-			} catch (Exception e) {
-				Console.WriteLine(e.Message);
-				Console.WriteLine(e.StackTrace);
-			} finally {
-				// resume listening
-				socket.BeginReceiveFrom(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, ref clientEndPoint, new AsyncCallback(ReceiveFromClient), null);
-			}}
-
-			// SendPacket: send a packet from the sim to the client via our fake sim endpoint
-			public void SendPacket(Packet packet, int length, bool skipZero) {
-				if (skipZero || (packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-					socket.SendTo(packet.Data, length, SocketFlags.None, clientEndPoint);
-				else {
-					int zeroLength = Helpers.ZeroEncode(packet.Data, length, zeroBuffer);
-					socket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, clientEndPoint);
-				}
-			}
-
-			// Inject: inject a packet
-			public void Inject(Packet packet, Direction direction) {
-				if (direction == Direction.Incoming) {
-					if (firstReceive) {
-						proxy.queuedIncomingInjections.Add(packet);
-						return;
-					}
-
-					incomingInjections.Add(++incomingSequence);
-					packet.Sequence = incomingSequence;
-				} else {
-					outgoingInjections.Add(++outgoingSequence);
-					packet.Sequence = outgoingSequence;
-				}
-
-#if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;INJECT &quot; + (direction == Direction.Incoming ? &quot;&lt;-&quot; : &quot;-&gt;&quot;) + &quot; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
-
-#endif
-				if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
-					WaitForAck(packet, direction);
-
-				if (direction == Direction.Incoming)
-					if ((packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-						socket.SendTo(packet.Data, packet.Data.Length, SocketFlags.None, clientEndPoint);
-					else {
-						int zeroLength = Helpers.ZeroEncode(packet.Data, packet.Data.Length, zeroBuffer);
-						socket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, clientEndPoint);
-					}
-				else
-					proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
-			}
-
-			// WaitForAck: take care of resending a packet until it's ACKed
-			public void WaitForAck(Packet packet, Direction direction) {
-				Hashtable table = direction == Direction.Incoming ? incomingAcks : outgoingAcks;
-				table.Add(packet.Sequence, packet);
-			}
-
-			// CheckAcks: check for and remove ACKs of packets we've injected
-			public Packet CheckAcks(Packet packet, Direction direction, ref int length, ref bool needsCopy) {
-				Hashtable acks = direction == Direction.Incoming ? outgoingAcks : incomingAcks;
-				ArrayList seenAcks = direction == Direction.Incoming ? outgoingSeenAcks : incomingSeenAcks;
-
-				if (acks.Count == 0)
-					return packet;
-
-				// check for embedded ACKs
-				if (packet.Layout.Name == &quot;PacketAck&quot;) {
-					bool changed = false;
-					Hashtable blocks = PacketUtility.Unbuild(packet);
-					Hashtable newBlocks = new Hashtable();
-					foreach (Hashtable fields in blocks.Keys) {
-						ushort id = (ushort)((uint)fields[&quot;ID&quot;]);
-#if DEBUG_SEQUENCE
-						string hrup = &quot;Check !&quot; + id;
-#endif
-						if (acks.Contains(id)) {
-#if DEBUG_SEQUENCE
-							hrup += &quot; get's&quot;;
-#endif
-							seenAcks.Add(id);
-							changed = true;
-						} else
-							newBlocks.Add(fields, blocks[fields]);
-#if DEBUG_SEQUENCE
-						Console.WriteLine(hrup);
-#endif
-					}
-					if (changed) {
-						Packet newPacket = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, newBlocks, packet.Data[0]);
-						SwapPacket(packet, newPacket, length);
-						packet = newPacket;
-						length = packet.Data.Length;
-						needsCopy = false;
-					}
-				}
-
-				// check for appended ACKs
-				if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
-					byte ackCount = packet.Data[length - 1];
-					for (int i = 0; i &lt; ackCount;) {
-						int offset = length - (ackCount - i) * 4 - 1;
-						ushort ackID = (ushort)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8));
-#if DEBUG_SEQUENCE
-						string hrup = &quot;Check @&quot; + ackID;
-#endif
-						if (acks.Contains(ackID)) {
-#if DEBUG_SEQUENCE
-							hrup += &quot; get's&quot;;
-#endif
-							byte[] newData = new byte[length -= 4];
-							Array.Copy(packet.Data, 0, newData, 0, offset);
-							Array.Copy(packet.Data, offset + 4, newData, offset, length - offset - 4);
-							--newData[newData.Length - 1];
-							packet.Data = newData;
-							--ackCount;
-							seenAcks.Add(ackID);
-							needsCopy = false;
-						} else
-							++i;
-#if DEBUG_SEQUENCE
-						Console.WriteLine(hrup);
-#endif
-					}
-					if (ackCount == 0) {
-						byte[] newData = new byte[length -= 1];
-						Array.Copy(packet.Data, 0, newData, 0, length);
-						newData[0] ^= Helpers.MSG_APPENDED_ACKS;
-						packet.Data = newData;
-					}
-				}
-
-				return packet;
-			}
-
-			// ModifySequence: modify a packet's sequence number and ACK IDs to account for injections
-			public Packet ModifySequence(Packet packet, Direction direction, ref int length, ref bool needsCopy) {
-				ArrayList ourInjections = direction == Direction.Outgoing ? outgoingInjections : incomingInjections;
-				ArrayList theirInjections = direction == Direction.Incoming ? outgoingInjections : incomingInjections;
-				ushort ourOffset = direction == Direction.Outgoing ? outgoingOffset : incomingOffset;
-				ushort theirOffset = direction == Direction.Incoming ? outgoingOffset : incomingOffset;
-
-				ushort newSequence = (ushort)(packet.Sequence + ourOffset);
-				foreach (ushort injection in ourInjections)
-					if (newSequence &gt;= injection)
-						++newSequence;
-#if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;Mod #&quot; + packet.Sequence + &quot; = &quot; + newSequence);
-#endif
-				packet.Sequence = newSequence;
-
-				if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
-					int ackCount = packet.Data[length - 1];
-					for (int i = 0; i &lt; ackCount; ++i) {
-						int offset = length - (ackCount - i) * 4 - 1;
-						uint ackID = (uint)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8)) - theirOffset;
-#if DEBUG_SEQUENCE
-						uint hrup = (uint)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8));
-#endif
-						for (int j = theirInjections.Count - 1; j &gt;= 0; --j)
-							if (ackID &gt;= (ushort)theirInjections[j])
-								--ackID;
-#if DEBUG_SEQUENCE
-						Console.WriteLine(&quot;Mod @&quot; + hrup + &quot; = &quot; + ackID);
-#endif
-						packet.Data[offset + 3] = (byte)(ackID % 256);
-						packet.Data[offset + 2] = (byte)(ackID / 256);
-					}
-				}
-
-				if (packet.Layout.Name == &quot;PacketAck&quot;) {
-					Hashtable blocks = PacketUtility.Unbuild(packet);
-					foreach (Hashtable fields in blocks.Keys) {
-						if ((string)blocks[fields] == &quot;Packets&quot;) {
-							uint ackID = (uint)fields[&quot;ID&quot;] - theirOffset;
-#if DEBUG_SEQUENCE
-							uint hrup = (uint)fields[&quot;ID&quot;];
-#endif
-							for (int i = theirInjections.Count - 1; i &gt;= 0; --i)
-								if (ackID &gt;= (ushort)theirInjections[i])
-									--ackID;
-#if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;Mod !&quot; + hrup + &quot; = &quot; + ackID);
-#endif
-							fields[&quot;ID&quot;] = ackID;
-						}
-					}
-					Packet newPacket = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, packet.Data[0]);
-					SwapPacket(packet, newPacket, length);
-					packet = newPacket;
-					length = packet.Data.Length;
-					needsCopy = false;
-				}
-
-				return packet;
-			}
-		}
-
-		// Checkers swap proxy addresses in for real addresses.  A few constraints:
-		//   - Checkers must not alter the incoming packet.
-		//   - Checkers must return a freshly built packet, even if nothing's changed.
-		//   - The incoming packet's buffer may be longer than the length of the data it contains.
-		//   - The incoming packet's buffer must not be used after the checker returns.
-		// This is all because checkers may be operating on data that's still in a scratch buffer.
-		delegate Packet AddressChecker(Packet packet);
-
-		Hashtable incomingCheckers = new Hashtable();
-		Hashtable outgoingCheckers = new Hashtable();
-
-		// InitializeAddressCheckers: initialize delegates that check packets for addresses that need proxying
-		private void InitializeAddressCheckers() {
-			// TODO: what do we do with mysteries and empty IPs?
-			AddMystery(&quot;OpenCircuit&quot;);
-			AddMystery(&quot;AgentPresenceResponse&quot;);
-			incomingCheckers.Add(&quot;TeleportFinish&quot;, new AddressChecker(CheckTeleportFinish));
-			// ViewerStats: IP is 0.0.0.0
-			incomingCheckers.Add(&quot;AgentToNewRegion&quot;, new AddressChecker(CheckAgentToNewRegion));
-			incomingCheckers.Add(&quot;CrossedRegion&quot;, new AddressChecker(CheckCrossedRegion));
-			incomingCheckers.Add(&quot;EnableSimulator&quot;, new AddressChecker(CheckEnableSimulator));
-			// KickUser: IP is 0.0.0.0
-			incomingCheckers.Add(&quot;UserLoginLocationReply&quot;, new AddressChecker(CheckUserLoginLocationReply));
-		}
-
-		// AddMystery: add a checker delegate that logs packets we're watching for development purposes
-		private void AddMystery(String name) {
-			incomingCheckers.Add(name, new AddressChecker(LogIncomingMysteryPacket));
-			outgoingCheckers.Add(name, new AddressChecker(LogOutgoingMysteryPacket));
-		}
-
-		// GenericCheck: replace the sim address in a packet with our proxy address
-		private Packet GenericCheck(Packet packet, string block, string fieldIP, string fieldPort, bool active) {
-			Hashtable blocks = PacketUtility.Unbuild(packet);
-
-			IPEndPoint realSim = new IPEndPoint((IPAddress)PacketUtility.GetField(blocks, block, fieldIP), Convert.ToInt32(PacketUtility.GetField(blocks, block, fieldPort)));
-			IPEndPoint fakeSim = ProxySim(realSim);
-			PacketUtility.SetField(blocks, block, fieldIP, fakeSim.Address);
-			PacketUtility.SetField(blocks, block, fieldPort, (ushort)fakeSim.Port);
-
-			if (active)
-				activeCircuit = realSim;
-
-			return PacketBuilder.BuildPacket(packet.Layout.Name, proxyConfig.protocol, blocks, packet.Data[0]);
-		}
-
-		// CheckTeleportFinish: check TeleportFinish packets
-		private Packet CheckTeleportFinish(Packet packet) {
-			return GenericCheck(packet, &quot;Info&quot;, &quot;SimIP&quot;, &quot;SimPort&quot;, true);
-		}
-
-		// CheckAgentToNewRegion: check AgentToNewRegion packets
-		private Packet CheckAgentToNewRegion(Packet packet) {
-			return GenericCheck(packet, &quot;RegionData&quot;, &quot;IP&quot;, &quot;Port&quot;, true);
-		}
-
-		// CheckEnableSimulator: check EnableSimulator packets
-		private Packet CheckEnableSimulator(Packet packet) {
-			return GenericCheck(packet, &quot;SimulatorInfo&quot;, &quot;IP&quot;, &quot;Port&quot;, false);
-		}
-
-		// CheckCrossedRegion: check CrossedRegion packets
-		private Packet CheckCrossedRegion(Packet packet) {
-			return GenericCheck(packet, &quot;RegionData&quot;, &quot;SimIP&quot;, &quot;SimPort&quot;, true);
-		}
-
-		// CheckUserLoginLocationReply: check UserLoginLocationReply packets
-		private Packet CheckUserLoginLocationReply(Packet packet) {
-			return GenericCheck(packet, &quot;SimulatorBlock&quot;, &quot;IP&quot;, &quot;Port&quot;, true);
-		}
-
-		// LogPacket: log a packet dump
-		private Packet LogPacket(Packet packet, string type) {
-			Log(type + &quot; packet:&quot;, true);
-			Log(packet, true);
-
-			return PacketBuilder.BuildPacket(packet.Layout.Name, proxyConfig.protocol, PacketUtility.Unbuild(packet), packet.Data[0]);
-		}
-
-		// LogIncomingMysteryPacket: log an incoming packet we're watching for development purposes
-		private Packet LogIncomingMysteryPacket(Packet packet) {
-			return LogPacket(packet, &quot;incoming mystery&quot;);
-		}
-
-		// LogOutgoingMysteryPacket: log an outgoing packet we're watching for development purposes
-		private Packet LogOutgoingMysteryPacket(Packet packet) {
-			return LogPacket(packet, &quot;outgoing mystery&quot;);
-		}
-	}
-
-	// XmlRpcRequestDelegate: specifies a delegate to be called for XML-RPC requests
-	public delegate void XmlRpcRequestDelegate(XmlRpcRequest request);
-
-	// XmlRpcResponseDelegate: specifies a delegate to be called for XML-RPC responses
-	public delegate void XmlRpcResponseDelegate(XmlRpcResponse response);
-
-	// PacketDelegate: specifies a delegate to be called when a packet passes through the proxy
-	public delegate Packet PacketDelegate(Packet packet, IPEndPoint endPoint);
-
-	// Direction: specifies whether a packet is going to the client (Incoming) or to a sim (Outgoing)
-	public enum Direction {
-		Incoming,
-		Outgoing
-	}
-
-	// PacketUtility: provides various utility methods for working with libsecondlife Packet objects
-	public class PacketUtility {
-		// Unbuild: deconstruct a packet into a Hashtable of blocks suitable for passing to PacketBuilder
-		public static Hashtable Unbuild(Packet packet) {
-			Hashtable blockTable = new Hashtable();
-			foreach (Block block in packet.Blocks()) {
-				Hashtable fieldTable = new Hashtable();
-				foreach (Field field in block.Fields)
-					fieldTable[field.Layout.Name] = field.Data;
-				blockTable[fieldTable] = block.Layout.Name;
-			}
-
-			return blockTable;
-		}
-
-		// GetField: given a table of blocks, return the value of the specified block and field
-		// In the case of packets with variable blocks, an arbitrary block will be used.
-		public static object GetField(Hashtable blocks, string block, string field) {
-			foreach (Hashtable fields in blocks.Keys)
-				if ((string)blocks[fields] == block)
-					if (fields.Contains(field))
-						return fields[field];
-
-			return null;
-		}
-
-		// SetField: given a table of blocks, update the value of the specified block and field
-		// In the case of packets with variable blocks, all blocks will be updated.
-		public static void SetField(Hashtable blocks, string block, string field, object value) {
-			foreach (Hashtable fields in blocks.Keys)
-				if ((string)blocks[fields] == block)
-					if (fields.Contains(field))
-						fields[field] = value;
-		}
-	}
-}
+            writer.WriteLine();
+
+			XmlTextWriter responseWriter = new XmlTextWriter(writer);
+			XmlRpcResponseSerializer.Singleton.Serialize(responseWriter, response);
+			responseWriter.Close();
+		}}
+
+		/*
+		 * Sim Proxy
+		 */
+
+		private Socket simFacingSocket;
+		private IPEndPoint activeCircuit = null;
+		private Hashtable proxyEndPoints = new Hashtable();
+		private Hashtable simProxies = new Hashtable();
+		private Hashtable proxyHandlers = new Hashtable();
+		private XmlRpcRequestDelegate loginRequestDelegate = null;
+		private XmlRpcResponseDelegate loginResponseDelegate = null;
+		private Hashtable incomingDelegates = new Hashtable();
+		private Hashtable outgoingDelegates = new Hashtable();
+		private ArrayList queuedIncomingInjections = new ArrayList();
+		private ArrayList queuedOutgoingInjections = new ArrayList();
+
+		// InitializeSimProxy: initialize the sim proxy
+		private void InitializeSimProxy() {
+			InitializeAddressCheckers();
+
+			simFacingSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
+			simFacingSocket.Bind(new IPEndPoint(proxyConfig.remoteFacingAddress, 0));
+			Reset();
+		}
+
+		// Reset: start a new session
+		private void Reset() {
+			foreach (SimProxy simProxy in simProxies.Values)
+				simProxy.Reset();
+		}
+
+		private byte[] receiveBuffer = new byte[8192];
+		private byte[] zeroBuffer = new byte[8192];
+		private EndPoint remoteEndPoint = (EndPoint)new IPEndPoint(IPAddress.Any, 0);
+
+		// RunSimProxy: start listening for packets from remote sims
+		private void RunSimProxy() {
+			simFacingSocket.BeginReceiveFrom(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, ref remoteEndPoint, new AsyncCallback(ReceiveFromSim), null);
+		}
+
+		// ReceiveFromSim: packet received from a remote sim
+		private void ReceiveFromSim(IAsyncResult ar) { lock(this) try {
+			// pause listening and fetch the packet
+			bool needsZero = false;
+			bool needsCopy = true;
+			int length;
+			length = simFacingSocket.EndReceiveFrom(ar, ref remoteEndPoint);
+
+			if (proxyHandlers.Contains(remoteEndPoint)) {
+				// find the proxy responsible for forwarding this packet
+				SimProxy simProxy = (SimProxy)proxyHandlers[remoteEndPoint];
+
+				// interpret the packet according to the SL protocol
+				Packet packet;
+				if ((receiveBuffer[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(receiveBuffer), false);
+				else {
+					Helpers.ZeroDecodeCommand(receiveBuffer, zeroBuffer);
+					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(zeroBuffer), false);
+					needsZero = true;
+				}
+#if DEBUG_SEQUENCE
+				Console.WriteLine(&quot;&lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
+#endif
+
+				// check for ACKs we're waiting for
+				packet = simProxy.CheckAcks(packet, Direction.Incoming, ref length, ref needsCopy);
+
+				// modify sequence numbers to account for injections
+				ushort oldSequence = packet.Sequence;
+				packet = simProxy.ModifySequence(packet, Direction.Incoming, ref length, ref needsCopy);
+
+				// keep track of sequence numbers
+				if (packet.Sequence &gt; simProxy.incomingSequence)
+					simProxy.incomingSequence = packet.Sequence;
+
+				// check the packet for addresses that need proxying
+				if (incomingCheckers.Contains(packet.Layout.Name)) {
+					if (needsZero) {
+						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
+						packet.Data = zeroBuffer;
+						needsZero = false;
+					}
+
+					Packet newPacket = ((AddressChecker)incomingCheckers[packet.Layout.Name])(packet);
+					SwapPacket(packet, newPacket, length);
+					packet = newPacket;
+					length = packet.Data.Length;
+					needsCopy = false;
+				}
+
+				// pass the packet to any callback delegates
+				if (incomingDelegates.Contains(packet.Layout.Name)) {
+					if (needsZero) {
+						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
+						packet.Data = zeroBuffer;
+						needsCopy = true;
+					}
+
+					if (needsCopy) {
+						byte[] newData = new byte[length];
+						Array.Copy(packet.Data, 0, newData, 0, length);
+						packet.Data = newData;
+					}
+
+					try {
+						Packet newPacket = ((PacketDelegate)incomingDelegates[packet.Layout.Name])(packet, (IPEndPoint)remoteEndPoint);
+						if (newPacket == null) {
+							if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
+								simProxy.Inject(SpoofAck(oldSequence), Direction.Outgoing);
+
+							if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
+								packet = SeparateAck(packet);
+							else
+								packet = null;
+						} else {
+							bool oldReliable = (packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							bool newReliable = (newPacket.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							if (oldReliable &amp;&amp; !newReliable)
+								simProxy.Inject(SpoofAck(oldSequence), Direction.Outgoing);
+							else if (!oldReliable &amp;&amp; newReliable)
+								simProxy.WaitForAck(packet, Direction.Incoming);
+
+							SwapPacket(packet, newPacket, packet.Data.Length);
+							packet = newPacket;
+						}
+					} catch (Exception e) {
+						Log(&quot;exception in incoming delegate: &quot; + e.Message, true);
+						Log(e.StackTrace, true);
+					}
+
+					if (packet != null)
+						simProxy.SendPacket(packet, packet.Data.Length, false);
+				} else
+					simProxy.SendPacket(packet, length, needsZero);
+			} else
+				// ignore packets from unknown peers
+				Log(&quot;dropping packet from &quot; + remoteEndPoint, false);
+		} catch (Exception e) {
+			Console.WriteLine(e.Message);
+			Console.WriteLine(e.StackTrace);
+		} finally {
+			// resume listening
+			simFacingSocket.BeginReceiveFrom(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, ref remoteEndPoint, new AsyncCallback(ReceiveFromSim), null);
+		}}
+
+		// SendPacket: send a packet to a sim from our fake client endpoint
+		public void SendPacket(Packet packet, IPEndPoint endPoint, int length, bool skipZero) {
+			if (skipZero || (packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+				simFacingSocket.SendTo(packet.Data, length, SocketFlags.None, endPoint);
+			else {
+				int zeroLength = Helpers.ZeroEncode(packet.Data, length, zeroBuffer);
+				simFacingSocket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, endPoint);
+			}
+		}
+
+		// SpoofAck: create an ACK for the given packet
+		public Packet SpoofAck(ushort sequence) {
+			Hashtable blocks = new Hashtable();
+			Hashtable fields = new Hashtable();
+			fields[&quot;ID&quot;] = (uint)sequence;
+			blocks[fields] = &quot;Packets&quot;;
+			return PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, Helpers.MSG_ZEROCODED);
+		}
+
+		// SeparateAck: create a standalone PacketAck for packet's appended ACKs
+		public Packet SeparateAck(Packet packet) {
+			int ackCount = ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)packet.Data[packet.Data.Length - 1]);
+			Hashtable blocks = new Hashtable();
+			for (int i = 0; i &lt; ackCount; ++i) {
+				Hashtable fields = new Hashtable();
+				int offset = packet.Data.Length - (ackCount - i) * 4 - 1;
+				fields[&quot;ID&quot;] = (uint)
+					  (packet.Data[offset++] &lt;&lt;  0)
+					+ (packet.Data[offset++] &lt;&lt;  8)
+					+ (packet.Data[offset++] &lt;&lt; 16)
+					+ (packet.Data[offset++] &lt;&lt; 24)
+					;
+				blocks[fields] = &quot;Packets&quot;;
+			}
+
+			Packet ack = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, Helpers.MSG_ZEROCODED);
+			ack.Sequence = packet.Sequence;
+			return ack;
+		}
+
+		// SwapPacket: copy the sequence number and appended ACKs from one packet to another
+		public static void SwapPacket(Packet oldPacket, Packet newPacket, int oldLength) {
+			newPacket.Sequence = oldPacket.Sequence;
+
+			int oldAcks = (oldPacket.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)oldPacket.Data[oldLength - 1];
+			int newAcks = (newPacket.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)newPacket.Data[newPacket.Data.Length - 1];
+
+			if (oldAcks != 0 || newAcks != 0) {
+				int oldAckSize = oldAcks == 0 ? 0 : oldAcks * 4 + 1;
+				int newAckSize = newAcks == 0 ? 0 : newAcks * 4 + 1;
+
+				byte[] newData = new byte[newPacket.Data.Length - newAckSize + oldAckSize];
+				Array.Copy(newPacket.Data, 0, newData, 0, newPacket.Data.Length - newAckSize);
+
+				if (newAcks != 0)
+					newData[0] ^= Helpers.MSG_APPENDED_ACKS;
+
+				if (oldAcks != 0) {
+					newData[0] |= Helpers.MSG_APPENDED_ACKS;
+					Array.Copy(oldPacket.Data, oldLength - oldAckSize, newData, newPacket.Data.Length - newAckSize, oldAckSize);
+				}
+
+				newPacket.Data = newData;
+			}
+		}
+
+		// ProxySim: return the proxy for the specified sim, creating it if it doesn't exist
+		private IPEndPoint ProxySim(IPEndPoint simEndPoint) {
+			if (proxyEndPoints.Contains(simEndPoint))
+				// return the existing proxy
+				return (IPEndPoint)proxyEndPoints[simEndPoint];
+			else {
+				// return a new proxy
+				SimProxy simProxy = new SimProxy(proxyConfig, simEndPoint, this);
+				IPEndPoint fakeSim = simProxy.LocalEndPoint();
+				Log(&quot;creating proxy for &quot; + simEndPoint + &quot; at &quot; + fakeSim, false);
+				simProxy.Run();
+				proxyEndPoints.Add(simEndPoint, fakeSim);
+				simProxies.Add(simEndPoint, simProxy);
+				return fakeSim;
+			}
+		}
+
+		// AddHandler: remember which sim proxy corresponds to a given sim
+		private void AddHandler(EndPoint endPoint, SimProxy proxy) {
+			proxyHandlers.Add(endPoint, proxy);
+		}
+
+		// SimProxy: proxy for a single simulator
+		private class SimProxy {
+			private ProxyConfig proxyConfig;
+			private IPEndPoint remoteEndPoint;
+			private Proxy proxy;
+			private Socket socket;
+			public ushort incomingSequence;
+			public ushort outgoingSequence;
+			private ArrayList incomingInjections;
+			private ArrayList outgoingInjections;
+			private ushort incomingOffset = 0;
+			private ushort outgoingOffset = 0;
+			private Hashtable incomingAcks;
+			private Hashtable outgoingAcks;
+			private ArrayList incomingSeenAcks;
+			private ArrayList outgoingSeenAcks;
+
+			// SimProxy: construct a proxy for a single simulator
+			public SimProxy(ProxyConfig proxyConfig, IPEndPoint simEndPoint, Proxy proxy) {
+				this.proxyConfig = proxyConfig;
+				remoteEndPoint = new IPEndPoint(simEndPoint.Address, simEndPoint.Port);
+				this.proxy = proxy;
+				socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
+				socket.Bind(new IPEndPoint(proxyConfig.clientFacingAddress, 0));
+				proxy.AddHandler(remoteEndPoint, this);
+				Reset();
+			}
+
+			// Reset: start a new session
+			public void Reset() {
+				incomingSequence = 0;
+				outgoingSequence = 0;
+				incomingInjections = new ArrayList();
+				outgoingInjections = new ArrayList();
+				incomingAcks = new Hashtable();
+				outgoingAcks = new Hashtable();
+				incomingSeenAcks = new ArrayList();
+				outgoingSeenAcks = new ArrayList();
+			}
+
+			// BackgroundTasks: resend unacknowledged packets and keep data structures clean
+			private void BackgroundTasks() { try {
+				int tick = 1;
+				int incomingInjectionsPoint = 0;
+				int outgoingInjectionsPoint = 0;
+				int incomingSeenAcksPoint = 0;
+				int outgoingSeenAcksPoint = 0;
+
+				for (;; Thread.Sleep(1000)) lock(proxy) {
+					if ((tick = (tick + 1) % 60) == 0) {
+						for (int i = 0; i &lt; incomingInjectionsPoint; ++i) {
+							incomingInjections.RemoveAt(0);
+							++incomingOffset;
+#if DEBUG_SEQUENCE
+							Console.WriteLine(&quot;incomingOffset = &quot; + incomingOffset);
+#endif
+						}
+						incomingInjectionsPoint = incomingInjections.Count;
+
+						for (int i = 0; i &lt; outgoingInjectionsPoint; ++i) {
+							outgoingInjections.RemoveAt(0);
+							++outgoingOffset;
+#if DEBUG_SEQUENCE
+							Console.WriteLine(&quot;outgoingOffset = &quot; + outgoingOffset);
+#endif
+						}
+						outgoingInjectionsPoint = outgoingInjections.Count;
+
+						for (int i = 0; i &lt; incomingSeenAcksPoint; ++i) {
+#if DEBUG_SEQUENCE
+							Console.WriteLine(&quot;incomingAcks.Remove(&quot; + incomingSeenAcks[0] + &quot;)&quot;);
+#endif
+							incomingAcks.Remove(incomingSeenAcks[0]);
+							incomingSeenAcks.RemoveAt(0);
+						}
+						incomingSeenAcksPoint = incomingSeenAcks.Count;
+
+						for (int i = 0; i &lt; outgoingSeenAcksPoint; ++i) {
+#if DEBUG_SEQUENCE
+							Console.WriteLine(&quot;outgoingAcks.Remove(&quot; + outgoingSeenAcks[0] + &quot;)&quot;);
+#endif
+							outgoingAcks.Remove(outgoingSeenAcks[0]);
+							outgoingSeenAcks.RemoveAt(0);
+						}
+						outgoingSeenAcksPoint = outgoingSeenAcks.Count;
+					}
+
+					foreach (ushort id in incomingAcks.Keys)
+						if (!incomingSeenAcks.Contains(id)) {
+							Packet packet = (Packet)incomingAcks[id];
+							packet.Data[0] |= Helpers.MSG_RESENT;
+#if DEBUG_SEQUENCE
+							Console.WriteLine(&quot;RESEND &lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
+#endif
+							SendPacket(packet, packet.Data.Length, false);
+						}
+
+					foreach (ushort id in outgoingAcks.Keys)
+						if (!outgoingSeenAcks.Contains(id)) {
+							Packet packet = (Packet)outgoingAcks[id];
+							packet.Data[0] |= Helpers.MSG_RESENT;
+#if DEBUG_SEQUENCE
+							Console.WriteLine(&quot;RESEND -&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
+#endif
+							proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
+						}
+				}
+			} catch (Exception e) {
+				Console.WriteLine(e.Message);
+				Console.WriteLine(e.StackTrace);
+			}}
+
+			// LocalEndPoint: return the endpoint that the client should communicate with
+			public IPEndPoint LocalEndPoint() {
+				return (IPEndPoint)socket.LocalEndPoint;
+			}
+
+			private byte[] receiveBuffer = new byte[8192];
+			private byte[] zeroBuffer = new byte[8192];
+			private EndPoint clientEndPoint = new IPEndPoint(IPAddress.Any, 0);
+			bool firstReceive = true;
+
+			// Run: forward packets from the client to the sim
+			public void Run() {
+				Thread backgroundTasks = new Thread(new ThreadStart(BackgroundTasks));
+				backgroundTasks.IsBackground = true;
+				backgroundTasks.Start();
+				socket.BeginReceiveFrom(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, ref clientEndPoint, new AsyncCallback(ReceiveFromClient), null);
+			}
+
+			// ReceiveFromClient: packet received from the client
+			private void ReceiveFromClient(IAsyncResult ar) { lock(proxy) try {
+				// pause listening and fetch the packet
+				bool needsZero = false;
+				bool needsCopy = true;
+				int length;
+				length = socket.EndReceiveFrom(ar, ref clientEndPoint);
+
+				// interpret the packet according to the SL protocol
+				Packet packet;
+				if ((receiveBuffer[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(receiveBuffer), false);
+				else {
+					Helpers.ZeroDecodeCommand(receiveBuffer, zeroBuffer);
+					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(zeroBuffer), false);
+					needsZero = true;
+				}
+#if DEBUG_SEQUENCE
+				Console.WriteLine(&quot;-&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
+#endif
+
+				// check for ACKs we're waiting for
+				packet = CheckAcks(packet, Direction.Outgoing, ref length, ref needsCopy);
+
+				// modify sequence numbers to account for injections
+				ushort oldSequence = packet.Sequence;
+				packet = ModifySequence(packet, Direction.Outgoing, ref length, ref needsCopy);
+
+				// keep track of sequence numbers
+				if (packet.Sequence &gt; outgoingSequence)
+					outgoingSequence = packet.Sequence;
+
+				// check the packet for addresses that need proxying
+				if (proxy.outgoingCheckers.Contains(packet.Layout.Name)) {
+					if (needsZero) {
+						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
+						packet.Data = zeroBuffer;
+						needsZero = false;
+					}
+
+					Packet newPacket = ((AddressChecker)proxy.outgoingCheckers[packet.Layout.Name])(packet);
+					SwapPacket(packet, newPacket, length);
+					packet = newPacket;
+					length = packet.Data.Length;
+					needsCopy = false;
+				}
+
+				// pass the packet to any callback delegates
+				if (proxy.outgoingDelegates.Contains(packet.Layout.Name)) {
+					if (needsZero) {
+						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
+						packet.Data = zeroBuffer;
+						needsCopy = true;
+					}
+
+					if (needsCopy) {
+						byte[] newData = new byte[length];
+						Array.Copy(packet.Data, 0, newData, 0, length);
+						packet.Data = newData;
+					}
+
+					try {
+						Packet newPacket = ((PacketDelegate)proxy.outgoingDelegates[packet.Layout.Name])(packet, remoteEndPoint);
+						if (newPacket == null) {
+							if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
+								Inject(proxy.SpoofAck(oldSequence), Direction.Incoming);
+
+							if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
+								packet = proxy.SeparateAck(packet);
+							else
+								packet = null;
+						} else {
+							bool oldReliable = (packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							bool newReliable = (newPacket.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							if (oldReliable &amp;&amp; !newReliable)
+								Inject(proxy.SpoofAck(oldSequence), Direction.Incoming);
+							else if (!oldReliable &amp;&amp; newReliable)	
+								WaitForAck(packet, Direction.Outgoing);
+
+							SwapPacket(packet, newPacket, packet.Data.Length);
+							packet = newPacket;
+						}
+					} catch (Exception e) {
+						proxy.Log(&quot;exception in outgoing delegate: &quot; + e.Message, true);
+						proxy.Log(e.StackTrace, true);
+					}
+
+					if (packet != null)
+						proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
+				} else
+					proxy.SendPacket(packet, remoteEndPoint, length, needsZero);
+
+				// send any packets queued for injection
+				if (firstReceive) {
+					firstReceive = false;
+					foreach (Packet queuedPacket in proxy.queuedIncomingInjections)
+						Inject(queuedPacket, Direction.Incoming);
+					proxy.queuedIncomingInjections = new ArrayList();
+				}
+			} catch (Exception e) {
+				Console.WriteLine(e.Message);
+				Console.WriteLine(e.StackTrace);
+			} finally {
+				// resume listening
+				socket.BeginReceiveFrom(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, ref clientEndPoint, new AsyncCallback(ReceiveFromClient), null);
+			}}
+
+			// SendPacket: send a packet from the sim to the client via our fake sim endpoint
+			public void SendPacket(Packet packet, int length, bool skipZero) {
+				if (skipZero || (packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+					socket.SendTo(packet.Data, length, SocketFlags.None, clientEndPoint);
+				else {
+					int zeroLength = Helpers.ZeroEncode(packet.Data, length, zeroBuffer);
+					socket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, clientEndPoint);
+				}
+			}
+
+			// Inject: inject a packet
+			public void Inject(Packet packet, Direction direction) {
+				if (direction == Direction.Incoming) {
+					if (firstReceive) {
+						proxy.queuedIncomingInjections.Add(packet);
+						return;
+					}
+
+					incomingInjections.Add(++incomingSequence);
+					packet.Sequence = incomingSequence;
+				} else {
+					outgoingInjections.Add(++outgoingSequence);
+					packet.Sequence = outgoingSequence;
+				}
+
+#if DEBUG_SEQUENCE
+				Console.WriteLine(&quot;INJECT &quot; + (direction == Direction.Incoming ? &quot;&lt;-&quot; : &quot;-&gt;&quot;) + &quot; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
+
+#endif
+				if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
+					WaitForAck(packet, direction);
+
+				if (direction == Direction.Incoming)
+					if ((packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+						socket.SendTo(packet.Data, packet.Data.Length, SocketFlags.None, clientEndPoint);
+					else {
+						int zeroLength = Helpers.ZeroEncode(packet.Data, packet.Data.Length, zeroBuffer);
+						socket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, clientEndPoint);
+					}
+				else
+					proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
+			}
+
+			// WaitForAck: take care of resending a packet until it's ACKed
+			public void WaitForAck(Packet packet, Direction direction) {
+				Hashtable table = direction == Direction.Incoming ? incomingAcks : outgoingAcks;
+				table.Add(packet.Sequence, packet);
+			}
+
+			// CheckAcks: check for and remove ACKs of packets we've injected
+			public Packet CheckAcks(Packet packet, Direction direction, ref int length, ref bool needsCopy) {
+				Hashtable acks = direction == Direction.Incoming ? outgoingAcks : incomingAcks;
+				ArrayList seenAcks = direction == Direction.Incoming ? outgoingSeenAcks : incomingSeenAcks;
+
+				if (acks.Count == 0)
+					return packet;
+
+				// check for embedded ACKs
+				if (packet.Layout.Name == &quot;PacketAck&quot;) {
+					bool changed = false;
+					Hashtable blocks = PacketUtility.Unbuild(packet);
+					Hashtable newBlocks = new Hashtable();
+					foreach (Hashtable fields in blocks.Keys) {
+						ushort id = (ushort)((uint)fields[&quot;ID&quot;]);
+#if DEBUG_SEQUENCE
+						string hrup = &quot;Check !&quot; + id;
+#endif
+						if (acks.Contains(id)) {
+#if DEBUG_SEQUENCE
+							hrup += &quot; get's&quot;;
+#endif
+							seenAcks.Add(id);
+							changed = true;
+						} else
+							newBlocks.Add(fields, blocks[fields]);
+#if DEBUG_SEQUENCE
+						Console.WriteLine(hrup);
+#endif
+					}
+					if (changed) {
+						Packet newPacket = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, newBlocks, packet.Data[0]);
+						SwapPacket(packet, newPacket, length);
+						packet = newPacket;
+						length = packet.Data.Length;
+						needsCopy = false;
+					}
+				}
+
+				// check for appended ACKs
+				if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
+					byte ackCount = packet.Data[length - 1];
+					for (int i = 0; i &lt; ackCount;) {
+						int offset = length - (ackCount - i) * 4 - 1;
+						ushort ackID = (ushort)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8));
+#if DEBUG_SEQUENCE
+						string hrup = &quot;Check @&quot; + ackID;
+#endif
+						if (acks.Contains(ackID)) {
+#if DEBUG_SEQUENCE
+							hrup += &quot; get's&quot;;
+#endif
+							byte[] newData = new byte[length -= 4];
+							Array.Copy(packet.Data, 0, newData, 0, offset);
+							Array.Copy(packet.Data, offset + 4, newData, offset, length - offset - 4);
+							--newData[newData.Length - 1];
+							packet.Data = newData;
+							--ackCount;
+							seenAcks.Add(ackID);
+							needsCopy = false;
+						} else
+							++i;
+#if DEBUG_SEQUENCE
+						Console.WriteLine(hrup);
+#endif
+					}
+					if (ackCount == 0) {
+						byte[] newData = new byte[length -= 1];
+						Array.Copy(packet.Data, 0, newData, 0, length);
+						newData[0] ^= Helpers.MSG_APPENDED_ACKS;
+						packet.Data = newData;
+					}
+				}
+
+				return packet;
+			}
+
+			// ModifySequence: modify a packet's sequence number and ACK IDs to account for injections
+			public Packet ModifySequence(Packet packet, Direction direction, ref int length, ref bool needsCopy) {
+				ArrayList ourInjections = direction == Direction.Outgoing ? outgoingInjections : incomingInjections;
+				ArrayList theirInjections = direction == Direction.Incoming ? outgoingInjections : incomingInjections;
+				ushort ourOffset = direction == Direction.Outgoing ? outgoingOffset : incomingOffset;
+				ushort theirOffset = direction == Direction.Incoming ? outgoingOffset : incomingOffset;
+
+				ushort newSequence = (ushort)(packet.Sequence + ourOffset);
+				foreach (ushort injection in ourInjections)
+					if (newSequence &gt;= injection)
+						++newSequence;
+#if DEBUG_SEQUENCE
+				Console.WriteLine(&quot;Mod #&quot; + packet.Sequence + &quot; = &quot; + newSequence);
+#endif
+				packet.Sequence = newSequence;
+
+				if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
+					int ackCount = packet.Data[length - 1];
+					for (int i = 0; i &lt; ackCount; ++i) {
+						int offset = length - (ackCount - i) * 4 - 1;
+						uint ackID = (uint)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8)) - theirOffset;
+#if DEBUG_SEQUENCE
+						uint hrup = (uint)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8));
+#endif
+						for (int j = theirInjections.Count - 1; j &gt;= 0; --j)
+							if (ackID &gt;= (ushort)theirInjections[j])
+								--ackID;
+#if DEBUG_SEQUENCE
+						Console.WriteLine(&quot;Mod @&quot; + hrup + &quot; = &quot; + ackID);
+#endif
+						packet.Data[offset + 3] = (byte)(ackID % 256);
+						packet.Data[offset + 2] = (byte)(ackID / 256);
+					}
+				}
+
+				if (packet.Layout.Name == &quot;PacketAck&quot;) {
+					Hashtable blocks = PacketUtility.Unbuild(packet);
+					foreach (Hashtable fields in blocks.Keys) {
+						if ((string)blocks[fields] == &quot;Packets&quot;) {
+							uint ackID = (uint)fields[&quot;ID&quot;] - theirOffset;
+#if DEBUG_SEQUENCE
+							uint hrup = (uint)fields[&quot;ID&quot;];
+#endif
+							for (int i = theirInjections.Count - 1; i &gt;= 0; --i)
+								if (ackID &gt;= (ushort)theirInjections[i])
+									--ackID;
+#if DEBUG_SEQUENCE
+							Console.WriteLine(&quot;Mod !&quot; + hrup + &quot; = &quot; + ackID);
+#endif
+							fields[&quot;ID&quot;] = ackID;
+						}
+					}
+					Packet newPacket = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, packet.Data[0]);
+					SwapPacket(packet, newPacket, length);
+					packet = newPacket;
+					length = packet.Data.Length;
+					needsCopy = false;
+				}
+
+				return packet;
+			}
+		}
+
+		// Checkers swap proxy addresses in for real addresses.  A few constraints:
+		//   - Checkers must not alter the incoming packet.
+		//   - Checkers must return a freshly built packet, even if nothing's changed.
+		//   - The incoming packet's buffer may be longer than the length of the data it contains.
+		//   - The incoming packet's buffer must not be used after the checker returns.
+		// This is all because checkers may be operating on data that's still in a scratch buffer.
+		delegate Packet AddressChecker(Packet packet);
+
+		Hashtable incomingCheckers = new Hashtable();
+		Hashtable outgoingCheckers = new Hashtable();
+
+		// InitializeAddressCheckers: initialize delegates that check packets for addresses that need proxying
+		private void InitializeAddressCheckers() {
+			// TODO: what do we do with mysteries and empty IPs?
+			AddMystery(&quot;OpenCircuit&quot;);
+			AddMystery(&quot;AgentPresenceResponse&quot;);
+			incomingCheckers.Add(&quot;TeleportFinish&quot;, new AddressChecker(CheckTeleportFinish));
+			// ViewerStats: IP is 0.0.0.0
+			incomingCheckers.Add(&quot;AgentToNewRegion&quot;, new AddressChecker(CheckAgentToNewRegion));
+			incomingCheckers.Add(&quot;CrossedRegion&quot;, new AddressChecker(CheckCrossedRegion));
+			incomingCheckers.Add(&quot;EnableSimulator&quot;, new AddressChecker(CheckEnableSimulator));
+			// KickUser: IP is 0.0.0.0
+			incomingCheckers.Add(&quot;UserLoginLocationReply&quot;, new AddressChecker(CheckUserLoginLocationReply));
+		}
+
+		// AddMystery: add a checker delegate that logs packets we're watching for development purposes
+		private void AddMystery(String name) {
+			incomingCheckers.Add(name, new AddressChecker(LogIncomingMysteryPacket));
+			outgoingCheckers.Add(name, new AddressChecker(LogOutgoingMysteryPacket));
+		}
+
+		// GenericCheck: replace the sim address in a packet with our proxy address
+		private Packet GenericCheck(Packet packet, string block, string fieldIP, string fieldPort, bool active) {
+			Hashtable blocks = PacketUtility.Unbuild(packet);
+
+			IPEndPoint realSim = new IPEndPoint((IPAddress)PacketUtility.GetField(blocks, block, fieldIP), Convert.ToInt32(PacketUtility.GetField(blocks, block, fieldPort)));
+			IPEndPoint fakeSim = ProxySim(realSim);
+			PacketUtility.SetField(blocks, block, fieldIP, fakeSim.Address);
+			PacketUtility.SetField(blocks, block, fieldPort, (ushort)fakeSim.Port);
+
+			if (active)
+				activeCircuit = realSim;
+
+			return PacketBuilder.BuildPacket(packet.Layout.Name, proxyConfig.protocol, blocks, packet.Data[0]);
+		}
+
+		// CheckTeleportFinish: check TeleportFinish packets
+		private Packet CheckTeleportFinish(Packet packet) {
+			return GenericCheck(packet, &quot;Info&quot;, &quot;SimIP&quot;, &quot;SimPort&quot;, true);
+		}
+
+		// CheckAgentToNewRegion: check AgentToNewRegion packets
+		private Packet CheckAgentToNewRegion(Packet packet) {
+			return GenericCheck(packet, &quot;RegionData&quot;, &quot;IP&quot;, &quot;Port&quot;, true);
+		}
+
+		// CheckEnableSimulator: check EnableSimulator packets
+		private Packet CheckEnableSimulator(Packet packet) {
+			return GenericCheck(packet, &quot;SimulatorInfo&quot;, &quot;IP&quot;, &quot;Port&quot;, false);
+		}
+
+		// CheckCrossedRegion: check CrossedRegion packets
+		private Packet CheckCrossedRegion(Packet packet) {
+			return GenericCheck(packet, &quot;RegionData&quot;, &quot;SimIP&quot;, &quot;SimPort&quot;, true);
+		}
+
+		// CheckUserLoginLocationReply: check UserLoginLocationReply packets
+		private Packet CheckUserLoginLocationReply(Packet packet) {
+			return GenericCheck(packet, &quot;SimulatorBlock&quot;, &quot;IP&quot;, &quot;Port&quot;, true);
+		}
+
+		// LogPacket: log a packet dump
+		private Packet LogPacket(Packet packet, string type) {
+			Log(type + &quot; packet:&quot;, true);
+			Log(packet, true);
+
+			return PacketBuilder.BuildPacket(packet.Layout.Name, proxyConfig.protocol, PacketUtility.Unbuild(packet), packet.Data[0]);
+		}
+
+		// LogIncomingMysteryPacket: log an incoming packet we're watching for development purposes
+		private Packet LogIncomingMysteryPacket(Packet packet) {
+			return LogPacket(packet, &quot;incoming mystery&quot;);
+		}
+
+		// LogOutgoingMysteryPacket: log an outgoing packet we're watching for development purposes
+		private Packet LogOutgoingMysteryPacket(Packet packet) {
+			return LogPacket(packet, &quot;outgoing mystery&quot;);
+		}
+	}
+
+	// XmlRpcRequestDelegate: specifies a delegate to be called for XML-RPC requests
+	public delegate void XmlRpcRequestDelegate(XmlRpcRequest request);
+
+	// XmlRpcResponseDelegate: specifies a delegate to be called for XML-RPC responses
+	public delegate void XmlRpcResponseDelegate(XmlRpcResponse response);
+
+	// PacketDelegate: specifies a delegate to be called when a packet passes through the proxy
+	public delegate Packet PacketDelegate(Packet packet, IPEndPoint endPoint);
+
+	// Direction: specifies whether a packet is going to the client (Incoming) or to a sim (Outgoing)
+	public enum Direction {
+		Incoming,
+		Outgoing
+	}
+
+	// PacketUtility: provides various utility methods for working with libsecondlife Packet objects
+	public class PacketUtility {
+		// Unbuild: deconstruct a packet into a Hashtable of blocks suitable for passing to PacketBuilder
+		public static Hashtable Unbuild(Packet packet) {
+			Hashtable blockTable = new Hashtable();
+			foreach (Block block in packet.Blocks()) {
+				Hashtable fieldTable = new Hashtable();
+				foreach (Field field in block.Fields)
+					fieldTable[field.Layout.Name] = field.Data;
+				blockTable[fieldTable] = block.Layout.Name;
+			}
+
+			return blockTable;
+		}
+
+		// GetField: given a table of blocks, return the value of the specified block and field
+		// In the case of packets with variable blocks, an arbitrary block will be used.
+		public static object GetField(Hashtable blocks, string block, string field) {
+			foreach (Hashtable fields in blocks.Keys)
+				if ((string)blocks[fields] == block)
+					if (fields.Contains(field))
+						return fields[field];
+
+			return null;
+		}
+
+		// SetField: given a table of blocks, update the value of the specified block and field
+		// In the case of packets with variable blocks, all blocks will be updated.
+		public static void SetField(Hashtable blocks, string block, string field, object value) {
+			foreach (Hashtable fields in blocks.Keys)
+				if ((string)blocks[fields] == block)
+					if (fields.Contains(field))
+						fields[field] = value;
+		}
+	}
+}

Modified: branches/aditi/SLProxy/legacy/ProtocolManager.cs
===================================================================
--- branches/aditi/SLProxy/legacy/ProtocolManager.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/SLProxy/legacy/ProtocolManager.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -142,7 +142,7 @@
 			TypeSizes.Add(FieldType.LLVector3, 12);
 			TypeSizes.Add(FieldType.LLVector3d, 24);
 			TypeSizes.Add(FieldType.LLVector4, 16);
-			TypeSizes.Add(FieldType.LLQuaternion, 16);
+			TypeSizes.Add(FieldType.LLQuaternion, 12);
 			TypeSizes.Add(FieldType.IPADDR, 4);
 			TypeSizes.Add(FieldType.IPPORT, 2);
 			TypeSizes.Add(FieldType.Variable, -1);

Modified: branches/aditi/SLProxy/legacy/Types.cs
===================================================================
--- branches/aditi/SLProxy/legacy/Types.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/SLProxy/legacy/Types.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,618 +1,630 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Net;
-
-namespace libsecondlife
-{
-	public class U64
-	{
-		public uint[] Data;
-
-		public U64()
-		{
-			Data = new uint[2];
-			Data[0] = 0;
-			Data[1] = 1;
-		}
-
-		public U64(uint left, uint right)
-		{
-			Data = new uint[2];
-			// &quot;backwards&quot;, due to little-endian ordering
-			Data[0] = right;
-			Data[1] = left;
-		}
-
-		public U64(int left, int right)
-		{
-			Data = new uint[2];
-			// &quot;backwards&quot;, due to little-endian ordering
-			Data[0] = (uint)right;
-			Data[1] = (uint)left;
-		}
-
-		public U64(byte[] bA, int pos)
-		{
-			Data = new uint[2];
-			Data[0] = (uint)(bA[pos]   + (bA[pos+1]&lt;&lt;8) + (bA[pos+2]&lt;&lt;16) + (bA[pos+3]&lt;&lt;24));
-			Data[1] = (uint)(bA[pos+4] + (bA[pos+5]&lt;&lt;8) + (bA[pos+6]&lt;&lt;16) + (bA[pos+7]&lt;&lt;24));
-		}
-
-		public byte[] GetBytes()
-		{
-			byte[] bA = new byte[8];
-
-			bA[0]=(byte)((Data[0])    %256); bA[1]=(byte)((Data[0]&gt;&gt;8) %256); 
-			bA[2]=(byte)((Data[0]&gt;&gt;16)%256); bA[3]=(byte)((Data[0]&gt;&gt;24)%256); 
-			bA[4]=(byte)((Data[1])    %256); bA[5]=(byte)((Data[1]&gt;&gt;8) %256);
-			bA[6]=(byte)((Data[1]&gt;&gt;16)%256); bA[7]=(byte)((Data[1]&gt;&gt;24)%256); 
-
-			return bA;
-		}
-
-		public override int GetHashCode()
-		{
-			return (int)(Data[0] ^ Data[1]);
-		}
-
-		public override bool Equals(object o)
-		{
-		        if (!(o is U64)) return false;
-
-			U64 u64 = (U64)o;
-
-			return (u64.Data[0] == Data[0] &amp;&amp; u64.Data[1] == Data[1]);
-		}
-
-		public static bool operator==(U64 lhs, U64 rhs)
-		{
-			if(object.ReferenceEquals(lhs, rhs))  return true;
-			if(object.ReferenceEquals(lhs, null)) return false;
-			if(object.ReferenceEquals(rhs, null)) return false;
-
-			return (lhs.Data[0] == rhs.Data[0] &amp;&amp; lhs.Data[1] == rhs.Data[1]);
-		}
-
-		public static bool operator!=(U64 lhs, U64 rhs)
-		{
-			return !(lhs == rhs);
-		}
-
-		public static bool operator==(U64 lhs, int rhs)
-		{
-			if(object.ReferenceEquals(lhs, null)) return (rhs == 0);
-			/* this used to ignore the upper half of the U64, and I don't think
-			   that's correct. */
-			return (lhs.Data[0] == 0 &amp;&amp; lhs.Data[1] == rhs);
-		}
-
-		public static bool operator!=(U64 lhs, int rhs)
-		{
-			return !(lhs == rhs);
-		}
-
-		public override string ToString()
-		{
-			ulong u64 = (Data[1] &lt;&lt; 32) + Data[0];
-			return u64.ToString();
-		}
-	}
-
-	public class LLUUID
-	{
-		private byte[] data = null;
-		public byte[] Data
-		{
-			get { return data; }
-		}
-
-		public LLUUID()
-		{
-			data = new byte[16];
-		}
-
-		public LLUUID(string val)
-		{
-			data = new byte[16];
-
-			if (val.Length == 36) val = val.Replace(&quot;-&quot;, &quot;&quot;);
-			
-			if (val.Length != 32) return;
-
-			for(int i = 0; i &lt; 16; ++i)
-			{
-				data[i] = Convert.ToByte(val.Substring(i * 2, 2), 16);
-			}
-		}
-
-		public LLUUID(byte[] byteArray, int pos)
-		{
-			data = new byte[16];
-
-			Array.Copy(byteArray, pos, data, 0, 16);
-		}
-
-		public LLUUID(bool randomize)
-		{
-			if (randomize) data = Guid.NewGuid().ToByteArray();
-			else           data = new byte[16];
-		}
-
-		/// &lt;summary&gt;
-		/// Calculate an LLCRC for the given LLUUID
-		/// &lt;/summary&gt;
-		/// &lt;param name=&quot;uuid&quot;&gt;The LLUUID to calculate the CRC value for&lt;/param&gt;
-		/// &lt;returns&gt;The CRC checksum for this LLUUID&lt;/returns&gt;
-		public uint CRC() 
-		{
-			uint retval = 0;
-
-			retval += (uint)((Data[3] &lt;&lt; 24) + (Data[2] &lt;&lt; 16) + (Data[1] &lt;&lt; 8) + Data[0]);
-			retval += (uint)((Data[7] &lt;&lt; 24) + (Data[6] &lt;&lt; 16) + (Data[5] &lt;&lt; 8) + Data[4]);
-			retval += (uint)((Data[11] &lt;&lt; 24) + (Data[10] &lt;&lt; 16) + (Data[9] &lt;&lt; 8) + Data[8]);
-			retval += (uint)((Data[15] &lt;&lt; 24) + (Data[14] &lt;&lt; 16) + (Data[13] &lt;&lt; 8) + Data[12]);
-
-			return retval;
-		}
-
-		public static LLUUID GenerateUUID()
-		{
-			return new LLUUID(Guid.NewGuid().ToByteArray(), 0);
-		}
-
-		public override int GetHashCode()
-		{
-			return ToString().GetHashCode();
-		}
-
-		public override bool Equals(object o)
-		{
-			if (!(o is LLUUID)) return false;
-
-			LLUUID uuid = (LLUUID)o;
-
-			for (int i = 0; i &lt; 16; ++i)
-			{
-				if (Data[i] != uuid.Data[i]) return false;
-			}
-
-			return true;
-		}
-
-		public static bool operator==(LLUUID lhs, LLUUID rhs)
-		{
-			if(object.ReferenceEquals(lhs, rhs))  return true;
-			if(object.ReferenceEquals(lhs, null)) return false;
-			if(object.ReferenceEquals(rhs, null)) return false;
-
-			for (int i = 0; i &lt; 16; ++i)
-			{
-				if (lhs.Data[i] != rhs.Data[i]) return false;
-			}
-
-			return true;
-		}
-
-		public static bool operator!=(LLUUID lhs, LLUUID rhs)
-		{
-			return !(lhs == rhs);
-		}
-
-		public static implicit operator LLUUID(string val)
-		{
-			return new LLUUID(val);
-		}
-
-		public override string ToString()
-		{
-			string uuid = &quot;&quot;;
-
-			for (int i = 0; i &lt; 16; ++i)
-			{
-				uuid += Data[i].ToString(&quot;x2&quot;);
-			}
-
-			return uuid;
-		}
-
-		public string ToStringHyphenated()
-		{
-			string uuid = &quot;&quot;;
-
-			for (int i = 0; i &lt; 16; ++i)
-			{
-				uuid += Data[i].ToString(&quot;x2&quot;);
-
-			}
-			uuid = uuid.Insert(20,&quot;-&quot;);
-			uuid = uuid.Insert(16,&quot;-&quot;);
-			uuid = uuid.Insert(12,&quot;-&quot;);
-			uuid = uuid.Insert(8,&quot;-&quot;);
-			
-
-			return uuid;
-		}
-	}
-
-	public class LLVector3
-	{
-		public float X;
-		public float Y;
-		public float Z;
-
-		public LLVector3()
-		{
-			X = Y = Z = 0.0F;
-		}
-		
-		public LLVector3(LLVector3d vector)
-		{
-			X = (float)vector.X;
-			Y = (float)vector.Y;
-			Z = (float)vector.Z;
-		}
-
-		public LLVector3(byte[] byteArray, int pos)
-		{
-			if(!BitConverter.IsLittleEndian) 
-			{
-				Array.Reverse(byteArray, pos, 4);
-				Array.Reverse(byteArray, pos + 4, 4);
-				Array.Reverse(byteArray, pos + 8, 4);
-			}
-
-			X = BitConverter.ToSingle(byteArray, pos);
-			Y = BitConverter.ToSingle(byteArray, pos + 4);
-			Z = BitConverter.ToSingle(byteArray, pos + 8);
-		}
-
-		public LLVector3(float x, float y, float z)
-		{
-			X = x;
-			Y = y;
-			Z = z;
-		}
-
-		public byte[] GetBytes()
-		{
-			byte[] byteArray = new byte[12];
-
-			Array.Copy(BitConverter.GetBytes(X), 0, byteArray, 0, 4);
-			Array.Copy(BitConverter.GetBytes(Y), 0, byteArray, 4, 4);
-			Array.Copy(BitConverter.GetBytes(Z), 0, byteArray, 8, 4);
-
-			if(!BitConverter.IsLittleEndian) {
-				Array.Reverse(byteArray, 0, 4);
-				Array.Reverse(byteArray, 4, 4);
-				Array.Reverse(byteArray, 8, 4);
-			}
-
-			return byteArray;
-		}
-
-		public override string ToString()
-		{
-			return X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString();
-		}
-
-		public override int GetHashCode()
-		{
-			int x = (int)X;
-			int y = (int)Y;
-			int z = (int)Z;
-
-			return (x ^ y ^ z);
-		}
-
-		public override bool Equals(object o)
-		{
-			if (!(o is LLVector3)) return false;
-
-			LLVector3 vector = (LLVector3)o;
-
-			return (X == vector.X &amp;&amp; Y == vector.Y &amp;&amp; Z == vector.Z);
-		}
-
-		public static bool operator==(LLVector3 lhs, LLVector3 rhs)
-		{
-			if(object.ReferenceEquals(lhs, rhs))  return true;
-			if(object.ReferenceEquals(lhs, null)) return false;
-			if(object.ReferenceEquals(rhs, null)) return false;
-
-			return (lhs.X == rhs.X &amp;&amp; lhs.Y == rhs.Y &amp;&amp; lhs.Z == rhs.Z);
-		}
-
-		public static bool operator!=(LLVector3 lhs, LLVector3 rhs)
-		{
-			return !(lhs == rhs);
-		}
-	}
-
-	public class LLVector3d
-	{
-		public double X;
-		public double Y;
-		public double Z;
-
-		public LLVector3d()
-		{
-			X = Y = Z = 0.0D;
-		}
-
-		public LLVector3d(double x, double y, double z)
-		{
-			X = x;
-			Y = y;
-			Z = z;
-		}
-
-		public LLVector3d(byte[] byteArray, int pos)
-		{
-			if(!BitConverter.IsLittleEndian) {
-				Array.Reverse(byteArray, pos, 8);
-				Array.Reverse(byteArray, pos + 8, 8);
-				Array.Reverse(byteArray, pos + 16, 8);
-			}
-
-			X = BitConverter.ToDouble(byteArray, pos);
-			Y = BitConverter.ToDouble(byteArray, pos + 8);
-			Z = BitConverter.ToDouble(byteArray, pos + 16);
-		}
-
-		public byte[] GetBytes()
-		{
-			byte[] byteArray = new byte[24];
-
-			Array.Copy(BitConverter.GetBytes(X), 0, byteArray, 0, 8);
-			Array.Copy(BitConverter.GetBytes(Y), 0, byteArray, 8, 8);
-			Array.Copy(BitConverter.GetBytes(Z), 0, byteArray, 16, 8);
-
-			if(!BitConverter.IsLittleEndian) {
-				Array.Reverse(byteArray, 0, 8);
-				Array.Reverse(byteArray, 8, 8);
-				Array.Reverse(byteArray, 16, 8);
-			}
-
-			return byteArray;
-		}
-
-		public override string ToString()
-		{
-			return X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString();
-		}
-	}
-
-	public class LLVector4
-	{
-		public float X;
-		public float Y;
-		public float Z;
-		public float S;
-
-		public LLVector4()
-		{
-			X = Y = Z = S = 0.0F;
-		}
-
-		public LLVector4(byte[] byteArray, int pos)
-		{
-			if(!BitConverter.IsLittleEndian) {
-				Array.Reverse(byteArray, pos, 4);
-				Array.Reverse(byteArray, pos + 4, 4);
-				Array.Reverse(byteArray, pos + 8, 4);
-				Array.Reverse(byteArray, pos + 12, 4);
-			}
-
-			X = BitConverter.ToSingle(byteArray, pos);
-			Y = BitConverter.ToSingle(byteArray, pos + 4);
-			Z = BitConverter.ToSingle(byteArray, pos + 8);
-			S = BitConverter.ToSingle(byteArray, pos + 12);
-		}
-
-		public byte[] GetBytes()
-		{
-			byte[] byteArray = new byte[16];
-
-			Array.Copy(BitConverter.GetBytes(X), 0, byteArray, 0, 4);
-			Array.Copy(BitConverter.GetBytes(Y), 0, byteArray, 4, 4);
-			Array.Copy(BitConverter.GetBytes(Z), 0, byteArray, 8, 4);
-			Array.Copy(BitConverter.GetBytes(S), 0, byteArray, 12, 4);
-
-			if(!BitConverter.IsLittleEndian) {
-				Array.Reverse(byteArray, 0, 4);
-				Array.Reverse(byteArray, 4, 4);
-				Array.Reverse(byteArray, 8, 4);
-				Array.Reverse(byteArray, 12, 4);
-			}
-
-			return byteArray;
-		}
-
-		public override string ToString()
-		{
-			return X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString() + &quot; &quot; + S.ToString();
-		}
-	}
-
-	public class LLQuaternion
-	{
-		public float X;
-		public float Y;
-		public float Z;
-		public float S;
-
-		public LLQuaternion()
-		{
-			X = Y = Z = S = 0.0F;
-		}
-
-		public LLQuaternion(byte[] byteArray, int pos)
-		{
-			if(!BitConverter.IsLittleEndian) {
-				Array.Reverse(byteArray, pos,4);
-				Array.Reverse(byteArray, pos + 4, 4);
-				Array.Reverse(byteArray, pos + 8, 4);
-				Array.Reverse(byteArray, pos + 12, 4);
-			}
-
-			X = BitConverter.ToSingle(byteArray, pos);
-			Y = BitConverter.ToSingle(byteArray, pos + 4);
-			Z = BitConverter.ToSingle(byteArray, pos + 8);
-			S = BitConverter.ToSingle(byteArray, pos + 12);
-		}
-
-		public LLQuaternion(float x, float y, float z, float s)
-		{
-			X = x;
-			Y = y;
-			Z = z;
-			S = s;
-		}
-
-		public byte[] GetBytes()
-		{
-			byte[] byteArray = new byte[16];
-
-			Array.Copy(BitConverter.GetBytes(X), 0, byteArray, 0, 4);
-			Array.Copy(BitConverter.GetBytes(Y), 0, byteArray, 4, 4);
-			Array.Copy(BitConverter.GetBytes(Z), 0, byteArray, 8, 4);
-			Array.Copy(BitConverter.GetBytes(S), 0, byteArray, 12, 4);
-
-			if(!BitConverter.IsLittleEndian) {
-				Array.Reverse(byteArray, 0, 4);
-				Array.Reverse(byteArray, 4, 4);
-				Array.Reverse(byteArray, 8, 4);
-				Array.Reverse(byteArray, 12, 4);
-			}
-
-			return byteArray;
-		}
-
-		public override string ToString()
-		{
-			return X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString() + &quot; &quot; + S.ToString();
-		}
-	}
-
-	public class DataConvert
-	{
-		private static byte[] ba;
-
-		public static float toFloat(object Data, int offset)
-		{
-			ba = (byte[])Data;
-			if(!BitConverter.IsLittleEndian) 
-				Array.Reverse(ba, offset, 4);
-			return BitConverter.ToSingle(ba, offset);
-		}
-
-		public static float toFloat(object Data)
-		{
-			return toFloat(Data, 0);
-		}
-
-		public static double toDouble(object Data, int offset)
-		{
-			ba = (byte[])Data;
-			if(!BitConverter.IsLittleEndian) 
-				Array.Reverse(ba, offset, 8);
-			return BitConverter.ToDouble(ba, offset);
-		}
-
-		public static double toDouble(object Data)
-		{
-			return toDouble(Data, 0);
-		}
-
-		public static byte toU8(object Data, int offset)
-		{
-			ba = (byte[])Data;
-			return ba[offset];
-		}
-
-		public static byte toU8(object Data)
-		{
-			return toU8(Data,0);
-		}
-
-		public static ushort toU16(object Data, int offset)
-		{
-			return (ushort)(toU8(Data,0) | (ushort)toU8(Data,1) &lt;&lt; 8);
-		}
-
-		public static ushort toU16(object Data)
-		{
-			return toU16(Data, 0);
-		}
-
-		public static uint toU32(object Data, int offset)
-		{
-			return ((uint)(toU16(Data,0)) | ((uint)(toU16(Data,2) &lt;&lt; 16))); 
-		}
-
-		public static uint toU32(object Data)
-		{
-			return toU32(Data, 0);
-		}
-
-		public static String toChoppedString(object Data)
-		{
-			return System.Text.Encoding.UTF8.GetString((byte[])Data).Replace(&quot;\0&quot;, &quot;&quot;);
-		}
-
-		public static byte[] from(byte data) {
-			return new byte[1]{data};
-		}
-
-		public static byte[] from(ushort data) {
-			return new byte[2]{(byte)(data%256),(byte)(data&gt;&gt;8)};
-		}
-
-		public static byte[] from(uint data) {
-			return new byte[4] {(byte)      (data%256),(byte)((data&gt;&gt; 8)%256),
-					    (byte)((data&gt;&gt;16)%256),(byte)((data&gt;&gt;24)%256)};
-		}
-			
-		public static byte[] from(float data) 
-		{
-			ba = BitConverter.GetBytes(data);
-			if(!BitConverter.IsLittleEndian) 
-				Array.Reverse(ba, 0, 4);
-			return ba;
-		}
-
-		public static byte[] from(double data) 
-		{
-			ba = BitConverter.GetBytes(data);
-			if(!BitConverter.IsLittleEndian) 
-				Array.Reverse(ba, 0, 8);
-			return ba;
-		}
-
-	}
-}
+/*
+ * Copyright (c) 2006, Second Life Reverse Engineering Team
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the Second Life Reverse Engineering Team nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Net;
+
+namespace libsecondlife
+{
+	public class U64
+	{
+		public uint[] Data;
+
+		public U64()
+		{
+			Data = new uint[2];
+			Data[0] = 0;
+			Data[1] = 1;
+		}
+
+		public U64(uint left, uint right)
+		{
+			Data = new uint[2];
+			// &quot;backwards&quot;, due to little-endian ordering
+			Data[0] = right;
+			Data[1] = left;
+		}
+
+		public U64(int left, int right)
+		{
+			Data = new uint[2];
+			// &quot;backwards&quot;, due to little-endian ordering
+			Data[0] = (uint)right;
+			Data[1] = (uint)left;
+		}
+
+		public U64(byte[] bA, int pos)
+		{
+			Data = new uint[2];
+			Data[0] = (uint)(bA[pos]   + (bA[pos+1]&lt;&lt;8) + (bA[pos+2]&lt;&lt;16) + (bA[pos+3]&lt;&lt;24));
+			Data[1] = (uint)(bA[pos+4] + (bA[pos+5]&lt;&lt;8) + (bA[pos+6]&lt;&lt;16) + (bA[pos+7]&lt;&lt;24));
+		}
+
+		public byte[] GetBytes()
+		{
+			byte[] bA = new byte[8];
+
+			bA[0]=(byte)((Data[0])    %256); bA[1]=(byte)((Data[0]&gt;&gt;8) %256); 
+			bA[2]=(byte)((Data[0]&gt;&gt;16)%256); bA[3]=(byte)((Data[0]&gt;&gt;24)%256); 
+			bA[4]=(byte)((Data[1])    %256); bA[5]=(byte)((Data[1]&gt;&gt;8) %256);
+			bA[6]=(byte)((Data[1]&gt;&gt;16)%256); bA[7]=(byte)((Data[1]&gt;&gt;24)%256); 
+
+			return bA;
+		}
+
+		public override int GetHashCode()
+		{
+			return (int)(Data[0] ^ Data[1]);
+		}
+
+		public override bool Equals(object o)
+		{
+		        if (!(o is U64)) return false;
+
+			U64 u64 = (U64)o;
+
+			return (u64.Data[0] == Data[0] &amp;&amp; u64.Data[1] == Data[1]);
+		}
+
+		public static bool operator==(U64 lhs, U64 rhs)
+		{
+			if(object.ReferenceEquals(lhs, rhs))  return true;
+			if(object.ReferenceEquals(lhs, null)) return false;
+			if(object.ReferenceEquals(rhs, null)) return false;
+
+			return (lhs.Data[0] == rhs.Data[0] &amp;&amp; lhs.Data[1] == rhs.Data[1]);
+		}
+
+		public static bool operator!=(U64 lhs, U64 rhs)
+		{
+			return !(lhs == rhs);
+		}
+
+		public static bool operator==(U64 lhs, int rhs)
+		{
+			if(object.ReferenceEquals(lhs, null)) return (rhs == 0);
+			/* this used to ignore the upper half of the U64, and I don't think
+			   that's correct. */
+			return (lhs.Data[0] == 0 &amp;&amp; lhs.Data[1] == rhs);
+		}
+
+		public static bool operator!=(U64 lhs, int rhs)
+		{
+			return !(lhs == rhs);
+		}
+
+		public override string ToString()
+		{
+			ulong u64 = (Data[1] &lt;&lt; 32) + Data[0];
+			return u64.ToString();
+		}
+	}
+
+	public class LLUUID
+	{
+		private byte[] data = null;
+		public byte[] Data
+		{
+			get { return data; }
+		}
+
+		public LLUUID()
+		{
+			data = new byte[16];
+		}
+
+		public LLUUID(string val)
+		{
+			data = new byte[16];
+
+			if (val.Length == 36) val = val.Replace(&quot;-&quot;, &quot;&quot;);
+			
+			if (val.Length != 32) return;
+
+			for(int i = 0; i &lt; 16; ++i)
+			{
+				data[i] = Convert.ToByte(val.Substring(i * 2, 2), 16);
+			}
+		}
+
+		public LLUUID(byte[] byteArray, int pos)
+		{
+			data = new byte[16];
+
+			Array.Copy(byteArray, pos, data, 0, 16);
+		}
+
+		public LLUUID(bool randomize)
+		{
+			if (randomize) data = Guid.NewGuid().ToByteArray();
+			else           data = new byte[16];
+		}
+
+		/// &lt;summary&gt;
+		/// Calculate an LLCRC for the given LLUUID
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;uuid&quot;&gt;The LLUUID to calculate the CRC value for&lt;/param&gt;
+		/// &lt;returns&gt;The CRC checksum for this LLUUID&lt;/returns&gt;
+		public uint CRC() 
+		{
+			uint retval = 0;
+
+			retval += (uint)((Data[3] &lt;&lt; 24) + (Data[2] &lt;&lt; 16) + (Data[1] &lt;&lt; 8) + Data[0]);
+			retval += (uint)((Data[7] &lt;&lt; 24) + (Data[6] &lt;&lt; 16) + (Data[5] &lt;&lt; 8) + Data[4]);
+			retval += (uint)((Data[11] &lt;&lt; 24) + (Data[10] &lt;&lt; 16) + (Data[9] &lt;&lt; 8) + Data[8]);
+			retval += (uint)((Data[15] &lt;&lt; 24) + (Data[14] &lt;&lt; 16) + (Data[13] &lt;&lt; 8) + Data[12]);
+
+			return retval;
+		}
+
+		public static LLUUID GenerateUUID()
+		{
+			return new LLUUID(Guid.NewGuid().ToByteArray(), 0);
+		}
+
+		public override int GetHashCode()
+		{
+			return ToString().GetHashCode();
+		}
+
+		public override bool Equals(object o)
+		{
+			if (!(o is LLUUID)) return false;
+
+			LLUUID uuid = (LLUUID)o;
+
+			for (int i = 0; i &lt; 16; ++i)
+			{
+				if (Data[i] != uuid.Data[i]) return false;
+			}
+
+			return true;
+		}
+
+		public static bool operator==(LLUUID lhs, LLUUID rhs)
+		{
+			if(object.ReferenceEquals(lhs, rhs))  return true;
+			if(object.ReferenceEquals(lhs, null)) return false;
+			if(object.ReferenceEquals(rhs, null)) return false;
+
+			for (int i = 0; i &lt; 16; ++i)
+			{
+				if (lhs.Data[i] != rhs.Data[i]) return false;
+			}
+
+			return true;
+		}
+
+		public static bool operator!=(LLUUID lhs, LLUUID rhs)
+		{
+			return !(lhs == rhs);
+		}
+
+		public static implicit operator LLUUID(string val)
+		{
+			return new LLUUID(val);
+		}
+
+		public override string ToString()
+		{
+			string uuid = &quot;&quot;;
+
+			for (int i = 0; i &lt; 16; ++i)
+			{
+				uuid += Data[i].ToString(&quot;x2&quot;);
+			}
+
+			return uuid;
+		}
+
+		public string ToStringHyphenated()
+		{
+			string uuid = &quot;&quot;;
+
+			for (int i = 0; i &lt; 16; ++i)
+			{
+				uuid += Data[i].ToString(&quot;x2&quot;);
+
+			}
+			uuid = uuid.Insert(20,&quot;-&quot;);
+			uuid = uuid.Insert(16,&quot;-&quot;);
+			uuid = uuid.Insert(12,&quot;-&quot;);
+			uuid = uuid.Insert(8,&quot;-&quot;);
+			
+
+			return uuid;
+		}
+	}
+
+	public class LLVector3
+	{
+		public float X;
+		public float Y;
+		public float Z;
+
+		public LLVector3()
+		{
+			X = Y = Z = 0.0F;
+		}
+		
+		public LLVector3(LLVector3d vector)
+		{
+			X = (float)vector.X;
+			Y = (float)vector.Y;
+			Z = (float)vector.Z;
+		}
+
+		public LLVector3(byte[] byteArray, int pos)
+		{
+			if(!BitConverter.IsLittleEndian) 
+			{
+				Array.Reverse(byteArray, pos, 4);
+				Array.Reverse(byteArray, pos + 4, 4);
+				Array.Reverse(byteArray, pos + 8, 4);
+			}
+
+			X = BitConverter.ToSingle(byteArray, pos);
+			Y = BitConverter.ToSingle(byteArray, pos + 4);
+			Z = BitConverter.ToSingle(byteArray, pos + 8);
+		}
+
+		public LLVector3(float x, float y, float z)
+		{
+			X = x;
+			Y = y;
+			Z = z;
+		}
+
+		public byte[] GetBytes()
+		{
+			byte[] byteArray = new byte[12];
+
+			Array.Copy(BitConverter.GetBytes(X), 0, byteArray, 0, 4);
+			Array.Copy(BitConverter.GetBytes(Y), 0, byteArray, 4, 4);
+			Array.Copy(BitConverter.GetBytes(Z), 0, byteArray, 8, 4);
+
+			if(!BitConverter.IsLittleEndian) {
+				Array.Reverse(byteArray, 0, 4);
+				Array.Reverse(byteArray, 4, 4);
+				Array.Reverse(byteArray, 8, 4);
+			}
+
+			return byteArray;
+		}
+
+		public override string ToString()
+		{
+			return X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString();
+		}
+
+		public override int GetHashCode()
+		{
+			int x = (int)X;
+			int y = (int)Y;
+			int z = (int)Z;
+
+			return (x ^ y ^ z);
+		}
+
+		public override bool Equals(object o)
+		{
+			if (!(o is LLVector3)) return false;
+
+			LLVector3 vector = (LLVector3)o;
+
+			return (X == vector.X &amp;&amp; Y == vector.Y &amp;&amp; Z == vector.Z);
+		}
+
+		public static bool operator==(LLVector3 lhs, LLVector3 rhs)
+		{
+			if(object.ReferenceEquals(lhs, rhs))  return true;
+			if(object.ReferenceEquals(lhs, null)) return false;
+			if(object.ReferenceEquals(rhs, null)) return false;
+
+			return (lhs.X == rhs.X &amp;&amp; lhs.Y == rhs.Y &amp;&amp; lhs.Z == rhs.Z);
+		}
+
+		public static bool operator!=(LLVector3 lhs, LLVector3 rhs)
+		{
+			return !(lhs == rhs);
+		}
+	}
+
+	public class LLVector3d
+	{
+		public double X;
+		public double Y;
+		public double Z;
+
+		public LLVector3d()
+		{
+			X = Y = Z = 0.0D;
+		}
+
+		public LLVector3d(double x, double y, double z)
+		{
+			X = x;
+			Y = y;
+			Z = z;
+		}
+
+		public LLVector3d(byte[] byteArray, int pos)
+		{
+			if(!BitConverter.IsLittleEndian) {
+				Array.Reverse(byteArray, pos, 8);
+				Array.Reverse(byteArray, pos + 8, 8);
+				Array.Reverse(byteArray, pos + 16, 8);
+			}
+
+			X = BitConverter.ToDouble(byteArray, pos);
+			Y = BitConverter.ToDouble(byteArray, pos + 8);
+			Z = BitConverter.ToDouble(byteArray, pos + 16);
+		}
+
+		public byte[] GetBytes()
+		{
+			byte[] byteArray = new byte[24];
+
+			Array.Copy(BitConverter.GetBytes(X), 0, byteArray, 0, 8);
+			Array.Copy(BitConverter.GetBytes(Y), 0, byteArray, 8, 8);
+			Array.Copy(BitConverter.GetBytes(Z), 0, byteArray, 16, 8);
+
+			if(!BitConverter.IsLittleEndian) {
+				Array.Reverse(byteArray, 0, 8);
+				Array.Reverse(byteArray, 8, 8);
+				Array.Reverse(byteArray, 16, 8);
+			}
+
+			return byteArray;
+		}
+
+		public override string ToString()
+		{
+			return X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString();
+		}
+	}
+
+	public class LLVector4
+	{
+		public float X;
+		public float Y;
+		public float Z;
+		public float S;
+
+		public LLVector4()
+		{
+			X = Y = Z = S = 0.0F;
+		}
+
+		public LLVector4(byte[] byteArray, int pos)
+		{
+			if(!BitConverter.IsLittleEndian) {
+				Array.Reverse(byteArray, pos, 4);
+				Array.Reverse(byteArray, pos + 4, 4);
+				Array.Reverse(byteArray, pos + 8, 4);
+				Array.Reverse(byteArray, pos + 12, 4);
+			}
+
+			X = BitConverter.ToSingle(byteArray, pos);
+			Y = BitConverter.ToSingle(byteArray, pos + 4);
+			Z = BitConverter.ToSingle(byteArray, pos + 8);
+			S = BitConverter.ToSingle(byteArray, pos + 12);
+		}
+
+		public byte[] GetBytes()
+		{
+			byte[] byteArray = new byte[16];
+
+			Array.Copy(BitConverter.GetBytes(X), 0, byteArray, 0, 4);
+			Array.Copy(BitConverter.GetBytes(Y), 0, byteArray, 4, 4);
+			Array.Copy(BitConverter.GetBytes(Z), 0, byteArray, 8, 4);
+			Array.Copy(BitConverter.GetBytes(S), 0, byteArray, 12, 4);
+
+			if(!BitConverter.IsLittleEndian) {
+				Array.Reverse(byteArray, 0, 4);
+				Array.Reverse(byteArray, 4, 4);
+				Array.Reverse(byteArray, 8, 4);
+				Array.Reverse(byteArray, 12, 4);
+			}
+
+			return byteArray;
+		}
+
+		public override string ToString()
+		{
+			return X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString() + &quot; &quot; + S.ToString();
+		}
+	}
+
+	public class LLQuaternion
+	{
+		public float X;
+		public float Y;
+		public float Z;
+		public float W;
+
+		public LLQuaternion()
+		{
+			X = Y = Z = W = 0.0F;
+		}
+
+		public LLQuaternion(byte[] byteArray, int pos)
+		{
+			if(!BitConverter.IsLittleEndian) {
+				Array.Reverse(byteArray, pos,4);
+				Array.Reverse(byteArray, pos + 4, 4);
+				Array.Reverse(byteArray, pos + 8, 4);
+			}
+
+			X = BitConverter.ToSingle(byteArray, pos);
+			Y = BitConverter.ToSingle(byteArray, pos + 4);
+			Z = BitConverter.ToSingle(byteArray, pos + 8);
+
+            float xyzsum = 1 - X * X - Y * Y - Z * Z;
+            W = (xyzsum &gt; 0) ? (float)Math.Sqrt(xyzsum) : 0;
+		}
+
+		public LLQuaternion(float x, float y, float z, float w)
+		{
+			X = x;
+			Y = y;
+			Z = z;
+			W = w;
+		}
+
+		public byte[] GetBytes()
+		{
+            byte[] bytes = new byte[12];
+            float norm;
+
+            norm = (float)Math.Sqrt(X * X + Y * Y + Z * Z + W * W);
+
+            if (norm != 0)
+            {
+                norm = 1 / norm;
+
+                Array.Copy(BitConverter.GetBytes(norm * X), 0, bytes, 0, 4);
+                Array.Copy(BitConverter.GetBytes(norm * Y), 0, bytes, 4, 4);
+                Array.Copy(BitConverter.GetBytes(norm * Z), 0, bytes, 8, 4);
+
+                if (!BitConverter.IsLittleEndian)
+                {
+                    Array.Reverse(bytes, 0, 4);
+                    Array.Reverse(bytes, 4, 4);
+                    Array.Reverse(bytes, 8, 4);
+                }
+            }
+            else
+            {
+                throw new Exception(&quot;Quaternion &lt;&quot; + X + &quot;,&quot; + Y + &quot;,&quot; + Z + &quot;,&quot; + W + &quot;&gt; normalized to zero&quot;);
+            }
+
+            return bytes;
+		}
+
+		public override string ToString()
+		{
+			return &quot;&lt;&quot; + X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString() + &quot; &quot; + W.ToString() + &quot;&gt;&quot;;
+		}
+	}
+
+	public class DataConvert
+	{
+		private static byte[] ba;
+
+		public static float toFloat(object Data, int offset)
+		{
+			ba = (byte[])Data;
+			if(!BitConverter.IsLittleEndian) 
+				Array.Reverse(ba, offset, 4);
+			return BitConverter.ToSingle(ba, offset);
+		}
+
+		public static float toFloat(object Data)
+		{
+			return toFloat(Data, 0);
+		}
+
+		public static double toDouble(object Data, int offset)
+		{
+			ba = (byte[])Data;
+			if(!BitConverter.IsLittleEndian) 
+				Array.Reverse(ba, offset, 8);
+			return BitConverter.ToDouble(ba, offset);
+		}
+
+		public static double toDouble(object Data)
+		{
+			return toDouble(Data, 0);
+		}
+
+		public static byte toU8(object Data, int offset)
+		{
+			ba = (byte[])Data;
+			return ba[offset];
+		}
+
+		public static byte toU8(object Data)
+		{
+			return toU8(Data,0);
+		}
+
+		public static ushort toU16(object Data, int offset)
+		{
+			return (ushort)(toU8(Data,0) | (ushort)toU8(Data,1) &lt;&lt; 8);
+		}
+
+		public static ushort toU16(object Data)
+		{
+			return toU16(Data, 0);
+		}
+
+		public static uint toU32(object Data, int offset)
+		{
+			return ((uint)(toU16(Data,0)) | ((uint)(toU16(Data,2) &lt;&lt; 16))); 
+		}
+
+		public static uint toU32(object Data)
+		{
+			return toU32(Data, 0);
+		}
+
+		public static String toChoppedString(object Data)
+		{
+			return System.Text.Encoding.UTF8.GetString((byte[])Data).Replace(&quot;\0&quot;, &quot;&quot;);
+		}
+
+		public static byte[] from(byte data) {
+			return new byte[1]{data};
+		}
+
+		public static byte[] from(ushort data) {
+			return new byte[2]{(byte)(data%256),(byte)(data&gt;&gt;8)};
+		}
+
+		public static byte[] from(uint data) {
+			return new byte[4] {(byte)      (data%256),(byte)((data&gt;&gt; 8)%256),
+					    (byte)((data&gt;&gt;16)%256),(byte)((data&gt;&gt;24)%256)};
+		}
+			
+		public static byte[] from(float data) 
+		{
+			ba = BitConverter.GetBytes(data);
+			if(!BitConverter.IsLittleEndian) 
+				Array.Reverse(ba, 0, 4);
+			return ba;
+		}
+
+		public static byte[] from(double data) 
+		{
+			ba = BitConverter.GetBytes(data);
+			if(!BitConverter.IsLittleEndian) 
+				Array.Reverse(ba, 0, 8);
+			return ba;
+		}
+
+	}
+}

Modified: branches/aditi/SLProxy/legacy/XmlRpcDeserializer.cs
===================================================================
--- branches/aditi/SLProxy/legacy/XmlRpcDeserializer.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/SLProxy/legacy/XmlRpcDeserializer.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -92,7 +92,7 @@
 		_value = _text;
 		break;
 	      case DOUBLE:
-		_value = Double.Parse(_text);
+		_value = Double.Parse(_text, CultureInfo.InvariantCulture);
 		break;
 	      case INT:
 	      case ALT_INT:


Property changes on: branches/aditi/applications/Decoder
___________________________________________________________________
Name: svn:ignore
   + 
obj


Modified: branches/aditi/applications/Decoder/Decoder.cs
===================================================================
--- branches/aditi/applications/Decoder/Decoder.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/Decoder/Decoder.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -38,8 +38,7 @@
 class Decoder {
 	private static int BUFSIZE = 8096;
 
-    private static SecondLife client = new SecondLife();
-	private static ProtocolManager protocol = new ProtocolManager(&quot;message_template.msg&quot;, client);
+	private static SecondLife client = new SecondLife();
 	private static string grep = null;
 	private static byte[] data = new byte[BUFSIZE];
 	private static byte[] temp = new byte[BUFSIZE];
@@ -73,7 +72,10 @@
 
 	public static void Main(string[] args) {
 		if (args.Length &gt; 0) {
-			grep = String.Join(&quot; &quot;, args);
+			// FIXME
+			Console.WriteLine(&quot;sorry, filtering is currently broken :(&quot;);
+			return;
+			// grep = String.Join(&quot; &quot;, args);
 		}
 
 		for (Reset();;) {
@@ -138,7 +140,10 @@
 				boring = true;
 	}
 
-	private static void Done() {
+	private static void Done()
+    {
+        byte[] zeroBuffer = new byte[4096];
+
 		if (!boring) try {
 			byte[] buf;
 			if ((data[0] &amp; 0xF0) == 0x40) {
@@ -171,9 +176,7 @@
 				} else
 					buf = data;
 
-			//Packet packet = new Packet(buf, pos, protocol);
-            // FIXME: Is this right? I haven't really looked at this code at all
-            Packet packet = Packet.BuildPacket(buf, ref pos);
+			Packet packet = Packet.BuildPacket(buf, ref pos, zeroBuffer);
 
 			if (grep != null) {
 				bool match = false;
@@ -218,7 +221,7 @@
 
 			Console.WriteLine(&quot;{0,5} {1} {2}&quot;
 					 ,packet.Header.Sequence
-					 ,InterpretOptions(packet.Header.Data[0])
+					 ,InterpretOptions(packet.Header)
 					 ,endpoints
 					);
 			Console.WriteLine(packet);
@@ -229,16 +232,15 @@
 		Reset();
 	}
 
-    // FIXME: Would be much easier to pass packet.Header and use the existing properties
-	private static string InterpretOptions(byte options) {
+	private static string InterpretOptions(Header header) {
 		return &quot;[&quot;
-		     + ((options &amp; Helpers.MSG_APPENDED_ACKS) != 0 ? &quot;Ack&quot; : &quot;   &quot;)
+		     + (header.AppendedAcks	? &quot;Ack&quot; : &quot;   &quot;)
 		     + &quot; &quot;
-		     + ((options &amp; Helpers.MSG_RESENT)	!= 0 ? &quot;Res&quot; : &quot;   &quot;)
+		     + (header.Resent		? &quot;Res&quot; : &quot;   &quot;)
 		     + &quot; &quot;
-		     + ((options &amp; Helpers.MSG_RELIABLE)      != 0 ? &quot;Rel&quot; : &quot;   &quot;)
+		     + (header.Reliable		? &quot;Rel&quot; : &quot;   &quot;)
 		     + &quot; &quot;
-		     + ((options &amp; Helpers.MSG_ZEROCODED)     != 0 ? &quot;Zer&quot; : &quot;   &quot;)
+		     + (header.Zerocoded	? &quot;Zer&quot; : &quot;   &quot;)
 		     + &quot;]&quot;
 		     ;
 	}

Copied: branches/aditi/applications/FollowBot (from rev 649, trunk/applications/FollowBot)


Property changes on: branches/aditi/applications/FollowBot
___________________________________________________________________
Name: svn:ignore
   + bin
obj



Property changes on: branches/aditi/applications/SLIRC
___________________________________________________________________
Name: svn:ignore
   + 
obj


Copied: branches/aditi/applications/SLIRC/Meebey.SmartIrc4net.dll (from rev 649, trunk/applications/SLIRC/Meebey.SmartIrc4net.dll)

Modified: branches/aditi/applications/SLIRC/SLIRC.csproj
===================================================================
--- branches/aditi/applications/SLIRC/SLIRC.csproj	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/SLIRC/SLIRC.csproj	2006-11-29 00:53:56 UTC (rev 650)
@@ -14,7 +14,7 @@
     &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
     &lt;DebugType&gt;full&lt;/DebugType&gt;
     &lt;Optimize&gt;false&lt;/Optimize&gt;
-    &lt;OutputPath&gt;bin\Debug\&lt;/OutputPath&gt;
+    &lt;OutputPath&gt;..\..\bin\&lt;/OutputPath&gt;
     &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
     &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
     &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
@@ -28,10 +28,9 @@
     &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
   &lt;/PropertyGroup&gt;
   &lt;ItemGroup&gt;
-    &lt;Reference Include=&quot;libsecondlife, Version=0.0.5.0, Culture=neutral, processorArchitecture=MSIL&quot; /&gt;
     &lt;Reference Include=&quot;Meebey.SmartIrc4net, Version=0.3.5.1833, Culture=neutral&quot;&gt;
       &lt;SpecificVersion&gt;False&lt;/SpecificVersion&gt;
-      &lt;HintPath&gt;..\..\Desktop\SmartIrc4net-0.3.5\bin\net\debug\Meebey.SmartIrc4net.dll&lt;/HintPath&gt;
+      &lt;HintPath&gt;.\Meebey.SmartIrc4net.dll&lt;/HintPath&gt;
     &lt;/Reference&gt;
     &lt;Reference Include=&quot;System&quot; /&gt;
     &lt;Reference Include=&quot;System.Data&quot; /&gt;
@@ -72,6 +71,12 @@
       &lt;DesignTimeSharedInput&gt;True&lt;/DesignTimeSharedInput&gt;
     &lt;/Compile&gt;
   &lt;/ItemGroup&gt;
+  &lt;ItemGroup&gt;
+    &lt;ProjectReference Include=&quot;..\..\libsecondlife-cs\libsecondlife.csproj&quot;&gt;
+      &lt;Project&gt;{D9CDEDFB-8169-4B03-B57F-0DF638F044EC}&lt;/Project&gt;
+      &lt;Name&gt;libsecondlife&lt;/Name&gt;
+    &lt;/ProjectReference&gt;
+  &lt;/ItemGroup&gt;
   &lt;Import Project=&quot;$(MSBuildBinPath)\Microsoft.CSharp.targets&quot; /&gt;
   &lt;!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.

Modified: branches/aditi/applications/SLIRC/frmSLIRC.cs
===================================================================
--- branches/aditi/applications/SLIRC/frmSLIRC.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/SLIRC/frmSLIRC.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -32,10 +32,7 @@
                 cmdConnect.Text = &quot;Disconnect&quot;;
                 txtFirstName.Enabled = txtLastName.Enabled = txtPassword.Enabled = false;
 
-                Hashtable loginParams = NetworkManager.DefaultLoginValues(txtFirstName.Text,
-                    txtLastName.Text, txtPassword.Text, &quot;00:00:00:00:00:00&quot;, &quot;last&quot;, 1, 50, 50, 50,
-                    &quot;Win&quot;, &quot;0&quot;, &quot;accountant&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">jhurliman at wsu.edu</A>&quot;);
-                if (client.Network.Login(loginParams))
+                if (client.Network.Login(txtFirstName.Text, txtLastName.Text, txtPassword.Text, &quot;slirc&quot;, &quot;Unknown Author&quot;))
                 {
                     LogMessage(&quot;Logged into Second Life&quot;);
                     lstAllowedUsers.Enabled = lstLog.Enabled = btnJoin.Enabled = txtMessage.Enabled = btnSay.Enabled = true;
@@ -45,7 +42,7 @@
                     {
                         ircclient.Connect(new string[] { txtServerName.Text }, int.Parse(txtPort.Text));
                         LogMessage(&quot;Connected to IRC Server.&quot;);
-                        ircclient.Login(client.Avatar.FirstName + client.Avatar.LastName, &quot;SLIRC Gateway&quot;);
+                        ircclient.Login(client.Self.FirstName + client.Self.LastName, &quot;SLIRC Gateway&quot;);
                         ircclient.RfcJoin(txtChannel.Text);
                         LogMessage(&quot;Logged in&quot;);
                         if(listenthread != null) listenthread.Abort();
@@ -84,15 +81,15 @@
         {
             LogMessage(e.Data.Nick + &quot;: &quot; + e.Data.Message);
             //From IRC -&gt; Inject to SL
-            client.Avatar.Say(e.Data.Nick + &quot;: &quot; + e.Data.Message, 0);
+            client.Self.Chat(e.Data.Nick + &quot;: &quot; + e.Data.Message, 0, MainAvatar.ChatType.Say);
         }
 
         private void frmSLIRC_Load(object sender, EventArgs e)
         {
             try
             {
-                client = new SecondLife(&quot;keywords.txt&quot;, &quot;message_template.msg&quot;);
-                client.Avatar.OnChat += new ChatCallback(Avatar_OnChat);
+                client = new SecondLife();
+                client.Self.OnChat += new ChatCallback(Avatar_OnChat);
                 grpLogin.Enabled = true;
             }
             catch (Exception error)
@@ -124,7 +121,7 @@
                 Invoke(new SingleStringDelegate(AddToAllowedList), new object[] { name });
             }
         }
-        void Avatar_OnChat(string message, byte audible, byte type, byte sourcetype, string name, LLUUID id, byte command, LLUUID commandID)
+        void Avatar_OnChat(string message, byte audible, byte type, byte sourcetype, string name, LLUUID id, LLUUID ownerid, LLVector3 position)
         {
             if (message.Equals(&quot;addme&quot;))
             {
@@ -150,12 +147,12 @@
 
         private void btnGetPos_Click(object sender, EventArgs e)
         {
-            LogMessage(&quot;Position: &quot; + client.Avatar.Position.X.ToString() + &quot; &quot; + client.Avatar.Position.Y.ToString());
+            LogMessage(&quot;Position: &quot; + client.Self.Position.X.ToString() + &quot; &quot; + client.Self.Position.Y.ToString());
         }
 
         private void btnSay_Click(object sender, EventArgs e)
         {
-            client.Avatar.Say(ircclient.Nickname + &quot;: &quot; + txtMessage.Text, 0);
+            client.Self.Chat(ircclient.Nickname + &quot;: &quot; + txtMessage.Text, 0, MainAvatar.ChatType.Say);
             ircclient.SendMessage(SendType.Message, txtChannel.Text, txtMessage.Text);
         }
 

Copied: branches/aditi/applications/TestBot (from rev 649, trunk/applications/TestBot)


Property changes on: branches/aditi/applications/TestBot
___________________________________________________________________
Name: svn:ignore
   + obj
*.user
*.suo


Copied: branches/aditi/applications/libslupdater (from rev 649, trunk/applications/libslupdater)

Copied: branches/aditi/applications/sceneviewer (from rev 649, trunk/applications/sceneviewer)

Deleted: branches/aditi/applications/sceneviewer/Camera.cs
===================================================================
--- trunk/applications/sceneviewer/Camera.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Camera.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,175 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-using Microsoft.Xna.Framework;
-
-namespace sceneviewer
-{
-    /// &lt;summary&gt;
-    /// Simple third-person camera class
-    /// &lt;/summary&gt;
-    public class Camera
-    {
-        public const float FOV = MathHelper.PiOver4;
-        public const float NearClip = 1.0f;
-        public const float FarClip = 1024.0f;
-
-        public Vector3 _position;
-        private Vector3 _lookatPosition;
-        private Matrix _projection;
-        private Matrix _view;
-
-        private float _theta = 0;
-        private float _phi = 0;
-        private float _zoom = 0;
-
-        public Matrix ViewMatrix
-        {
-            get { return _view; }
-        }
-
-        public Matrix ProjectionMatrix
-        {
-            get { return _projection; }
-        }
-
-        /// &lt;summary&gt;
-        /// Gets the view and projection matrices multiplied together
-        /// &lt;/summary&gt;
-        public Matrix ViewProjectionMatrix
-        {
-            get { return _view * _projection; }
-        }
-
-        public BoundingFrustum Frustum
-        {
-            get { return new BoundingFrustum(ViewProjectionMatrix); }
-        }
-
-        /// &lt;summary&gt;
-        /// Gets the camera position
-        /// &lt;/summary&gt;
-        public Vector3 Position
-        {
-            get { return _position; }
-        }
-
-        /// &lt;summary&gt;
-        /// Get or set the current angle of rotation in radians about the
-        /// Y-axis for the camera.
-        /// &lt;/summary&gt;
-        public float Theta
-        {
-            get { return _theta; }
-            //set 
-            //{
-            //    _theta = value; //% MAX_RADIANS;
-            //}
-        }
-
-        /// &lt;summary&gt;
-        /// Get or set the current angle of rotation in radians about the
-        /// Z-axis for the camera.
-        /// 
-        /// Applies a hard cap on the minimum or maximum values of phi.
-        /// &lt;/summary&gt;
-        public float Phi
-        {
-            get { return _phi; }
-        }
-
-        /// &lt;summary&gt;
-        /// Get or set the current zoom of the camera.
-        /// 
-        /// TODO: I should set a hard value on how close
-        /// the camera can zoom in; it should never be able to go
-        /// through the look at point.
-        /// &lt;/summary&gt;
-        public float Zoom
-        {
-            get { return _zoom; }
-
-            // TODO: Add a hard limit on zoom amount.
-            //set { _zoom = value; }
-        }
-
-
-        /// &lt;summary&gt;
-        /// Default constructor. Assumes the camera should be oriented up.
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;pos&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;lookAt&quot;&gt;&lt;/param&gt;
-        public Camera(GameWindow window, Vector3 pos, Vector3 lookAt)
-        {
-            _position = pos;
-            _lookatPosition = lookAt;
-
-            UpdateProjection(window);
-            Update();
-        }
-
-        public void Rotate(float angle)
-        {
-            _theta += angle;
-            Update();
-        }
-
-        public void Translate(Vector3 distance)
-        {
-            _position += Vector3.Transform(distance, Matrix.CreateRotationZ(_theta));
-            Update();
-        }
-
-        /// &lt;summary&gt;
-        /// Call this method any time the client window changes.
-        /// &lt;/summary&gt;
-        public void UpdateProjection(GameWindow window)
-        {
-            _projection = Matrix.CreatePerspectiveFieldOfView(FOV,
-                (float)window.ClientBounds.Width / (float)window.ClientBounds.Height,
-                NearClip, FarClip);
-        }
-
-        public void Update()
-        {
-            Vector3 newCameraPosition = _position;
-            Matrix rotationMatrix;
-
-            rotationMatrix = Matrix.CreateRotationZ(_theta);
-
-            Vector3 cameraReference = Vector3.UnitY;
-            Vector3 transformedReference = Vector3.Transform(cameraReference, rotationMatrix);
-
-            _lookatPosition = transformedReference + _position;
-
-            _view = Matrix.CreateLookAt(newCameraPosition, _lookatPosition,
-                Vector3.UnitZ);
-        }
-    }
-}
\ No newline at end of file

Copied: branches/aditi/applications/sceneviewer/Camera.cs (from rev 649, trunk/applications/sceneviewer/Camera.cs)

Copied: branches/aditi/applications/sceneviewer/Prims (from rev 649, trunk/applications/sceneviewer/Prims)

Deleted: branches/aditi/applications/sceneviewer/Prims/CrossSection.cs
===================================================================
--- trunk/applications/sceneviewer/Prims/CrossSection.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Prims/CrossSection.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,65 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using System.Collections.Generic;
-using Microsoft.Xna.Framework;
-using Microsoft.Xna.Framework.Graphics;
-using libsecondlife;
-
-namespace sceneviewer.Prims
-{
-    public class CrossSection
-    {
-        private List&lt;Vector3&gt; Points;
-
-        public CrossSection()
-        {
-            Points = new List&lt;Vector3&gt;();
-        }
-
-        public void AddPoint(Vector3 point)
-        {
-            Points.Add(point);
-        }
-
-        public void RemoveAllPoints()
-        {
-            Points.Clear();
-        }
-
-        public int GetNumPoints()
-        {
-            return Points.Count;
-        }
-
-        public Vector3 GetRawVertex(int index)
-        {
-            return Points[index];
-        }
-    }
-}

Copied: branches/aditi/applications/sceneviewer/Prims/CrossSection.cs (from rev 649, trunk/applications/sceneviewer/Prims/CrossSection.cs)

Deleted: branches/aditi/applications/sceneviewer/Prims/LinearPrimVisual.cs
===================================================================
--- trunk/applications/sceneviewer/Prims/LinearPrimVisual.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Prims/LinearPrimVisual.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,506 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using Microsoft.Xna.Framework;
-using Microsoft.Xna.Framework.Graphics;
-using libsecondlife;
-
-namespace sceneviewer.Prims
-{
-    public abstract class LinearPrimVisual : PrimVisual
-    {
-        // Abstract functions
-        protected abstract void BuildEndCapHollow(bool top);
-
-        public LinearPrimVisual(PrimObject prim)
-            : base(prim)
-        {
-        }
-
-        protected override void BuildFaces()
-        {
-            Vector3 cutstartouterface = Vector3.Zero;
-            Vector3 cutendouterface = Vector3.Zero;
-            Vector3 cutstartinnerface = Vector3.Zero;
-            Vector3 cutendinnerface = Vector3.Zero;
-            int cutStartDiagQuadrant = cutStartDiagQuadrant = GetCutQuadrant(Prim.ProfileBegin);
-            int cutEndDiagQuadrant = cutEndDiagQuadrant = GetCutQuadrant(Prim.ProfileEnd);
-            float hollowRatio = (float)Prim.ProfileHollow / 100.0f;
-
-            cutstartouterface = GetCutIntersect(Prim.ProfileBegin, 0.5f);  // coordinates of where the cut starts
-            cutendouterface = GetCutIntersect(Prim.ProfileEnd, 0.5f);  // coordinates of where the cut starts
-
-            if (hollow)
-            {
-                float halfWidth = hollowRatio * 0.5f;
-                cutstartinnerface = GetCutIntersect(Prim.ProfileBegin, halfWidth);
-                cutendinnerface = GetCutIntersect(Prim.ProfileEnd, halfWidth);
-            }
-
-            if (cut)
-            {
-                if (hollow)
-                {
-                    BuildCutHollowFaces(cutstartouterface, cutstartinnerface, cutendouterface, cutendinnerface);
-                }
-                else
-                {
-                    BuildCutFaces(cutstartouterface, cutendouterface);
-                }
-            }
-
-            if (cutStartDiagQuadrant == cutEndDiagQuadrant)
-            {
-                FirstOuterFace = LastOuterFace = cutStartDiagQuadrant;
-
-                OuterFaces[0].RemoveAllPoints();
-                OuterFaces[0].AddPoint(cutstartouterface);
-                OuterFaces[0].AddPoint(cutendouterface);
-                //OuterFaces[0].TextureMapping = texturemapping;
-
-                if (hollow)
-                {
-                    InnerFaces[0].RemoveAllPoints();
-                    InnerFaces[0].AddPoint(cutendinnerface);
-                    InnerFaces[0].AddPoint(cutstartinnerface);
-                    //InnerFaces[0].TextureMapping = texturemapping;
-                }
-            }
-            else
-            {
-                FirstOuterFace = cutStartDiagQuadrant;
-
-                float totalInnerLength = 0;
-                float startSideInnerLength = 0;
-                float wholeSideLength = 0;
-
-                PopulateSingleCutFacePositiveDirection(ref OuterFaces[FirstOuterFace], cutstartouterface, cutStartDiagQuadrant, 0.5f, true);
-                //OuterFaces[FirstOuterFace].TextureMapping = texturemapping;
-
-                if (hollow)
-                {
-                    startSideInnerLength = PopulateSingleCutFacePositiveDirection(ref InnerFaces[FirstOuterFace],
-                        cutstartinnerface, cutStartDiagQuadrant, hollowRatio * 0.5f, false);
-                    //InnerFaces[FirstOuterFace].TextureMapping = texturemapping;
-                    totalInnerLength += startSideInnerLength;
-                }
-
-                int quadrant = cutStartDiagQuadrant + 1;
-
-                while (quadrant &lt; cutEndDiagQuadrant)
-                {
-                    PopulateCompleteSide(ref OuterFaces[quadrant], quadrant, 0.5f, true);
-                    //OuterFaces[quadrant].TextureMapping = texturemapping;
-
-                    if (hollow)
-                    {
-                        wholeSideLength = PopulateCompleteSide(ref InnerFaces[quadrant], quadrant,
-                            hollowRatio * 0.5f, false);
-                        //InnerFaces[quadrant].TextureMapping = texturemapping;
-                        totalInnerLength += wholeSideLength;
-                    }
-
-                    quadrant++;
-                }
-
-                PopulateSingleCutFaceNegativeDirection(ref OuterFaces[quadrant], cutendouterface,
-                    cutEndDiagQuadrant, 0.5f, true);
-                //OuterFaces[quadrant].TextureMapping = texturemapping;
-
-                if (hollow)
-                {
-                    float endSideInnerLength = PopulateSingleCutFaceNegativeDirection(ref InnerFaces[quadrant],
-                        cutendinnerface, cutEndDiagQuadrant, hollowRatio * 0.5f, false);
-                    //InnerFaces[quadrant].TextureMapping = texturemapping;
-                    totalInnerLength += endSideInnerLength;
-                }
-
-                LastOuterFace = quadrant;
-
-                if (hollow)
-                {
-                    //SetupInnerFaceTextureOffsets(startSideInnerLength, wholeSideLength, totalInnerLength);
-                }
-            }
-
-            AssignFaces();
-
-            BuildVertexes();
-        }
-
-        protected void BuildCutFaces(Vector3 cutstartouterface, Vector3 cutendouterface)
-        {
-            CutFaces[0].RemoveAllPoints();
-
-            CutFaces[0].AddPoint(Vector3.Zero);
-            CutFaces[0].AddPoint(cutstartouterface);
-            //CutFaces[0].TextureMapping = texturemapping;
-
-            CutFaces[1].RemoveAllPoints();
-
-            CutFaces[1].AddPoint(cutendouterface);
-            CutFaces[1].AddPoint(Vector3.Zero);
-            //CutFaces[1].TextureMapping = texturemapping;
-        }
-
-        protected void BuildCutHollowFaces(Vector3 cutstartouterface, Vector3 cutstartinnerface, Vector3 cutendouterface, Vector3 cutendinnerface)
-        {
-            CutFaces[0].RemoveAllPoints();
-
-            CutFaces[0].AddPoint(cutstartinnerface);
-            CutFaces[0].AddPoint(cutstartouterface);
-            //CutFaces[0].TextureMapping = texturemapping;
-
-            CutFaces[1].RemoveAllPoints();
-
-            CutFaces[1].AddPoint(cutendouterface);
-            CutFaces[1].AddPoint(cutendinnerface);
-            //CutFaces[1].TextureMapping = texturemapping;
-        }
-
-        private Vector3 GetCutIntersect(float cut, float cubeHalfWidth)
-        {
-            int cutQuadrant = GetCutQuadrant(cut);
-
-            Vector3 lineend;
-            Vector3 linestart = ReferenceVertices[cutQuadrant] * cubeHalfWidth;
-            linestart = Vector3.Divide(linestart, 0.5f);
-            if (cutQuadrant &lt; NumberFaces - 1)
-            {
-                lineend = ReferenceVertices[cutQuadrant + 1] * cubeHalfWidth;
-            }
-            else
-            {
-                lineend = ReferenceVertices[0] * cubeHalfWidth;
-            }
-            lineend = Vector3.Divide(lineend, 0.5f);
-
-            //
-            float angle = GetAngleWithXAxis(cut);
-
-            // CutVectorPerp is perpendicular to the radius vector
-            Vector3 cutVectorPerp = new Vector3((float)-Math.Sin(angle), (float)Math.Cos(angle), 0);
-            Vector3 delta = lineend - linestart;
-
-            // From <A HREF="http://softsurfer.com/Archive/algorithm_0104/algorithm_0104B.htm">http://softsurfer.com/Archive/algorithm_0104/algorithm_0104B.htm</A>
-            Vector3 result = linestart - delta * Vector3.Dot(cutVectorPerp, linestart) / Vector3.Dot(cutVectorPerp, delta);
-
-            return result;
-        }
-
-        // Handles the first face in the cut, starting from cutstart, 
-        // and running anticlockwise to first reference vertex
-        private float PopulateSingleCutFacePositiveDirection(ref CrossSection face, Vector3 cutPoint, int quadrant, 
-            float halfCubeWidth, bool outer)
-        {
-            quadrant = NormalizeQuadrant(quadrant);
-
-            face.RemoveAllPoints();
-
-            Vector3 startPoint = cutPoint;
-            Vector3 endPoint;
-            if (quadrant &lt; NumberFaces - 1)
-            {
-                endPoint = ReferenceVertices[quadrant + 1] * halfCubeWidth / 0.5f;
-            }
-            else
-            {
-                endPoint = ReferenceVertices[0] * halfCubeWidth / 0.5f;
-            }
-
-            if (outer)
-            {
-                face.AddPoint(startPoint);
-                face.AddPoint(endPoint);
-            }
-            else
-            {
-                face.AddPoint(endPoint);
-                face.AddPoint(startPoint);
-            }
-
-            return Vector3.Distance(startPoint, endPoint);
-        }
-
-        private float PopulateSingleCutFaceNegativeDirection(ref CrossSection face, Vector3 cutPoint, int quadrant, 
-            float halfCubeWidth, bool outer)
-        {
-            quadrant = NormalizeQuadrant(quadrant);
-
-            face.RemoveAllPoints();
-
-            Vector3 startPoint = ReferenceVertices[quadrant] * halfCubeWidth / 0.5f;
-            Vector3 endPoint = cutPoint;
-
-            if (outer)
-            {
-                face.AddPoint(startPoint);
-                face.AddPoint(endPoint);
-            }
-            else
-            {
-                face.AddPoint(endPoint);
-                face.AddPoint(startPoint);
-            }
-
-            return Vector3.Distance(startPoint, endPoint);
-        }
-
-        private float PopulateCompleteSide(ref CrossSection face, int quadrant, float halfCubeWidth, bool outer)
-        {
-            quadrant = NormalizeQuadrant(quadrant);
-
-            face.RemoveAllPoints();
-
-            Vector3 startPoint = ReferenceVertices[quadrant];
-            Vector3 endPoint;
-            if (quadrant &lt; NumberFaces - 1)
-            {
-                endPoint = ReferenceVertices[quadrant + 1];
-            }
-            else
-            {
-                endPoint = ReferenceVertices[0];
-            }
-
-            startPoint = startPoint * halfCubeWidth / 0.5f;
-            endPoint = endPoint * halfCubeWidth / 0.5f;
-
-            if (outer)
-            {
-                face.AddPoint(startPoint);
-                face.AddPoint(endPoint);
-            }
-            else
-            {
-                face.AddPoint(endPoint);
-                face.AddPoint(startPoint);
-            }
-
-            return 2f * halfCubeWidth;
-        }
-
-        protected override void BuildVertexes()
-        {
-            Vertexes.Clear();
-
-            // For prims with a linear extrusion path, we base the number of transformations on the amount of twist
-            int transforms = 1 + Math.Abs((int)((float)(Prim.PathTwist - Prim.PathTwistBegin) / 9f));
-
-            // Build the outer sides
-            BuildSideVertexes(OuterFaces, transforms);
-
-            if (hollow)
-            {
-                // Build the inner sides
-                BuildSideVertexes(InnerFaces, transforms);
-            }
-
-            if (cut)
-            {
-                // Build the cut sides (between the inner and outer)
-                BuildSideVertexes(CutFaces, transforms);
-            }
-
-            // Build the top and bottom end caps
-            if (hollow)
-            {
-                BuildEndCapHollow(true);
-                BuildEndCapHollow(false);
-            }
-            else
-            {
-                if (cut)
-                {
-                    BuildEndCapCutNoHollow(true);
-                    BuildEndCapCutNoHollow(false);
-                }
-                else
-                {
-                    BuildEndCapNoCutNoHollow(true);
-                    BuildEndCapNoCutNoHollow(false);
-                }
-            }
-            
-            VertexArray = Vertexes.ToArray();
-        }
-
-        protected void BuildSideVertexes(CrossSection[] crossSection, int transforms)
-        {
-            float transformOffset = 1.0f / (float)transforms;
-            float currentOffset = -0.5f;
-
-            for (int i = 0; i &lt; transforms; i++)
-            {
-                for (int j = 0; j &lt; crossSection.Length; j++)
-                {
-                    int pointCount = crossSection[j].GetNumPoints();
-
-                    if (pointCount &gt; 0)
-                    {
-                        for (int k = 0; k &lt; pointCount - 1; k++)
-                        {
-                            Vector3 lower1, lower2, upper1, upper2;
-                            float lowerRatio = (float)i / (float)transforms;
-                            float upperRatio = (float)(i + 1) / (float)transforms;
-
-                            lower1 = crossSection[j].GetRawVertex(k);
-                            lower2 = crossSection[j].GetRawVertex(k + 1);
-
-                            lower1.Z = currentOffset;
-                            lower2.Z = currentOffset;
-
-                            upper1 = lower1;
-                            upper2 = lower2;
-
-                            upper1.Z = currentOffset + transformOffset;
-                            upper2.Z = currentOffset + transformOffset;
-
-                            lower1 = Transform(lower1, lowerRatio);
-                            lower2 = Transform(lower2, lowerRatio);
-                            upper1 = Transform(upper1, upperRatio);
-                            upper2 = Transform(upper2, upperRatio);
-
-                            Vertexes.Add(new VertexPositionColor(lower1, color));
-                            Vertexes.Add(new VertexPositionColor(lower2, color));
-                            Vertexes.Add(new VertexPositionColor(upper2, color));
-
-                            Vertexes.Add(new VertexPositionColor(lower1, color));
-                            Vertexes.Add(new VertexPositionColor(upper2, color));
-                            Vertexes.Add(new VertexPositionColor(upper1, color));
-                        }
-                    }
-                }
-
-                currentOffset += transformOffset;
-            }
-        }
-
-        protected void BuildEndCapNoCutNoHollow(bool top)
-        {
-            float z = top ? 0.5f : -0.5f;
-
-            for (int i = 0; i &lt; OuterFaces.Length; i++)
-            {
-                int pointCount = OuterFaces[i].GetNumPoints();
-
-                if (pointCount &gt; 0)
-                {
-                    for (int j = 0; j &lt; pointCount - 1; j++)
-                    {
-                        Vector3 first = OuterFaces[i].GetRawVertex(j);
-                        first.Z = z;
-                        Vector3 second = OuterFaces[i].GetRawVertex(j + 1);
-                        second.Z = z;
-                        Vector3 center = new Vector3(0, 0, z);
-
-                        float transformRatio = top ? 1 : 0;
-
-                        // Apply the transformation to each vertex
-                        first = Transform(first, transformRatio);
-                        second = Transform(second, transformRatio);
-                        center = Transform(center, transformRatio);
-
-                        Vertexes.Add(new VertexPositionColor(first, color));
-                        Vertexes.Add(new VertexPositionColor(second, color));
-                        Vertexes.Add(new VertexPositionColor(center, color));
-                    }
-                }
-            }
-        }
-
-        protected void BuildEndCapCutNoHollow(bool top)
-        {
-            float z = top ? 0.5f : -0.5f;
-
-            for (int i = FirstOuterFace; i &lt;= LastOuterFace; i++)
-            {
-                int pointCount = OuterFaces[i].GetNumPoints();
-
-                for (int j = 0; j &lt; pointCount - 1; j++)
-                {
-                    Vector3 first = OuterFaces[i].GetRawVertex(j);
-                    first.Z = z;
-                    Vector3 second = OuterFaces[i].GetRawVertex(j + 1);
-                    second.Z = z;
-                    Vector3 center = new Vector3(0, 0, z);
-
-                    // TODO: Texturemapping stuff
-                    //Vector2 t1 = texturemapping.GetTextureCoordinate(new Vector2(1 - (p1.x + 0.5), p1.y + 0.5));
-                    //Vector2 t2 = texturemapping.GetTextureCoordinate(new Vector2(1 - (p2.x + 0.5), p2.y + 0.5));
-
-                    float transformRatio = top ? 1 : 0;
-
-                    first = Transform(first, transformRatio);
-                    second = Transform(second, transformRatio);
-                    center = Transform(center, transformRatio);
-
-                    Vertexes.Add(new VertexPositionColor(first, color));
-                    Vertexes.Add(new VertexPositionColor(second, color));
-                    Vertexes.Add(new VertexPositionColor(center, color));
-                }
-            }
-        }
-
-        protected Vector3 Transform(Vector3 v, float ratio)
-        {
-            Matrix transform = Matrix.Identity;
-
-            // Top Shear
-            transform.Translation = new Vector3(ratio * Prim.PathShearX, ratio * Prim.PathShearY, 0);
-
-            // Taper
-            float xScale = 1.0f, yScale = 1.0f;
-            if (Prim.PathTaperX != 0)
-            {
-                float adjratio = (Prim.PathTaperX &lt; 0) ? (1.0f - ratio) : (ratio);
-                xScale -= Math.Abs(Prim.PathTaperX) * adjratio;
-            }
-            if (Prim.PathTaperY != 0)
-            {
-                float adjratio = (Prim.PathTaperY &lt; 0) ? (1.0f - ratio) : (ratio);
-                yScale -= Math.Abs(Prim.PathTaperY) * adjratio;
-            }
-            transform *= Matrix.CreateScale(xScale, yScale, 1.0f);
-
-            // Twist
-            float twistBegin = (float)Prim.PathTwistBegin * MathHelper.Pi / 180.0f;
-            float twistEnd = (float)Prim.PathTwist * MathHelper.Pi / 180.0f;
-            float twist = (twistEnd - twistBegin) * ratio;
-            transform *= Matrix.CreateRotationZ(-twist);
-
-            // Apply the transformation matrix to this point
-            return Vector3.Transform(v, transform);
-        }
-
-        private int NormalizeQuadrant(int quadrant)
-        {
-            return ((quadrant % NumberFaces) + NumberFaces) % NumberFaces;
-        }
-    }
-}

Copied: branches/aditi/applications/sceneviewer/Prims/LinearPrimVisual.cs (from rev 649, trunk/applications/sceneviewer/Prims/LinearPrimVisual.cs)

Deleted: branches/aditi/applications/sceneviewer/Prims/PrimVisual.cs
===================================================================
--- trunk/applications/sceneviewer/Prims/PrimVisual.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Prims/PrimVisual.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,203 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using System.Collections.Generic;
-using Microsoft.Xna.Framework;
-using Microsoft.Xna.Framework.Graphics;
-using libsecondlife;
-
-namespace sceneviewer.Prims
-{
-    public abstract class PrimVisual
-    {
-        // Constants
-        public const int MaxCut = 200;
-
-        public Matrix Matrix;
-        public VertexPositionColor[] VertexArray;
-        public PrimObject Prim;
-        public Vector3 Acceleration;
-        public Vector3 Velocity;
-        public Vector3 RotationVelocity;
-        public BoundingBox BoundBox;
-        public int LevelOfDetail = 16;
-
-        //
-        protected CrossSection[] OuterFaces; // Section for each extruded outer face
-        protected CrossSection[] InnerFaces; // Section for each extruded inner face (hollow)
-        protected CrossSection[] CutFaces; // Two cut faces
-
-        protected Color color;
-
-        //
-        protected int NumberFaces; // Number of faces on the base primitive
-        protected int FirstOuterFace; // If we're cutting, this might not be 0
-        protected int LastOuterFace; // If we're cutting, this might not be iNumberFaces
-
-        // Reference vertices of the unscaled/unrotated primitive
-        protected Vector3[] ReferenceVertices;
-
-        protected const int MaxFaces = 9;
-
-        protected bool hollow;
-        protected bool cut;
-
-        protected List&lt;VertexPositionColor&gt; Vertexes;
-        protected Color[] FaceColors = new Color[MaxFaces];
-
-        // Abstract methods
-        protected abstract void BuildFaces();
-        protected abstract void BuildVertexes();
-        protected abstract void AssignFaces();
-        protected abstract int GetCutQuadrant(float cut);
-        protected abstract float GetAngleWithXAxis(float cut);
-
-        public PrimVisual(PrimObject prim)
-        {
-            Prim = prim;
-            Vertexes = new List&lt;VertexPositionColor&gt;();
-            VertexArray = Vertexes.ToArray();
-
-            Acceleration = Vector3.Zero;
-            Velocity = Vector3.Zero;
-            RotationVelocity = Vector3.Zero;
-
-            // TODO: This is temporary, for debugging and entertainment purposes
-            Random rand = new Random((int)Prim.LocalID + Environment.TickCount);
-            byte r = (byte)rand.Next(256);
-            byte g = (byte)rand.Next(256);
-            byte b = (byte)rand.Next(256);
-            color = new Color(r, g, b);
-
-            BuildMatrix();
-        }
-
-        public void Select()
-        {
-            // TODO: This is temporary, for debugging and entertainment purposes
-            Random rand = new Random((int)Prim.LocalID + Environment.TickCount);
-            byte r = (byte)rand.Next(256);
-            byte g = (byte)rand.Next(256);
-            byte b = (byte)rand.Next(256);
-            color = new Color(r, g, b);
-
-            BuildVertexes();
-        }
-
-        public void Deselect()
-        {
-            ;
-        }
-
-        public void Update(PrimUpdate primUpdate)
-        {
-            Prim.Position = primUpdate.Position;
-            Prim.Rotation = primUpdate.Rotation;
-            Acceleration = new Vector3(primUpdate.Acceleration.X, primUpdate.Acceleration.Y, primUpdate.Acceleration.Z);
-            Velocity = new Vector3(primUpdate.Velocity.X, primUpdate.Velocity.Y, primUpdate.Velocity.Z);
-            RotationVelocity = new Vector3(primUpdate.RotationVelocity.X, primUpdate.RotationVelocity.Y, primUpdate.RotationVelocity.Z);
-
-            BuildMatrix();
-        }
-
-        private void BuildMatrix()
-        {
-            Matrix offset = Matrix.CreateTranslation(new Vector3(Prim.Position.X, Prim.Position.Y, Prim.Position.Z));
-            Matrix rotation = Matrix.CreateFromQuaternion(new Quaternion(Prim.Rotation.X, Prim.Rotation.Y, Prim.Rotation.Z,
-                Prim.Rotation.W));
-            Matrix scaling = Matrix.CreateScale(Prim.Scale.X, Prim.Scale.Y, Prim.Scale.Z);
-
-            Matrix = scaling * rotation * offset;
-            
-            // Now that we have the final transformation matrix we can create a proper bounding box
-            // TODO: This code has only been tested with linear extrusion prims
-            if (Prim.ParentID != 0)
-            {
-                float minX = -0.5f, minY = -0.5f, minZ = -0.5f;
-                if (Prim.PathShearX &lt; 0) minX *= Prim.PathShearX;
-                if (Prim.PathShearY &lt; 0) minY *= Prim.PathShearY;
-
-                float maxX = 0.5f, maxY = 0.5f, maxZ = 0.5f;
-                if (Prim.PathShearX &gt; 0) maxX *= Prim.PathShearX;
-                if (Prim.PathShearY &gt; 0) maxY *= Prim.PathShearY;
-
-                Vector3 min = Vector3.Transform(new Vector3(minX, minY, minZ), Matrix);
-                Vector3 max = Vector3.Transform(new Vector3(maxX, maxY, maxZ), Matrix);
-
-                BoundBox = new BoundingBox(min, max);
-            }
-            else
-            {
-                BoundBox = new BoundingBox();
-            }
-        }
-
-        public static PrimVisual BuildPrimVisual(PrimObject prim)
-        {
-            if (prim.ProfileCurve == 1 &amp;&amp; prim.PathCurve == 16)
-            {
-                // PRIM_TYPE_BOX
-                return new PrimVisualBox(prim);
-            }
-            else if (prim.ProfileCurve == 0 &amp;&amp; prim.PathCurve == 16)
-            {
-                // PRIM_TYPE_CYLINDER
-                return new PrimVisualCylinder(prim);
-            }
-            else if (prim.ProfileCurve == 3 &amp;&amp; prim.PathCurve == 16)
-            {
-                // PRIM_TYPE_PRISM
-                return new PrimVisualPrism(prim);
-            }
-            else if (prim.ProfileCurve == 5 &amp;&amp; prim.PathCurve == 32)
-            {
-                // PRIM_TYPE_SPHERE
-                return new PrimVisualSphere(prim);
-            }
-            else if (prim.ProfileCurve == 0 &amp;&amp; prim.PathCurve == 32)
-            {
-                // PRIM_TYPE_TORUS
-                return new PrimVisualTorus(prim);
-            }
-            else if (prim.ProfileCurve == 1 &amp;&amp; prim.PathCurve == 32)
-            {
-                // PRIM_TYPE_TUBE
-                return new PrimVisualTube(prim);
-            }
-            else if (prim.ProfileCurve == 3 &amp;&amp; prim.PathCurve == 32)
-            {
-                // PRIM_TYPE_RING
-                return new PrimVisualRing(prim);
-            }
-            else
-            {
-                return null;
-            }
-        }
-    }
-}

Copied: branches/aditi/applications/sceneviewer/Prims/PrimVisual.cs (from rev 649, trunk/applications/sceneviewer/Prims/PrimVisual.cs)

Deleted: branches/aditi/applications/sceneviewer/Prims/PrimVisualBox.cs
===================================================================
--- trunk/applications/sceneviewer/Prims/PrimVisualBox.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Prims/PrimVisualBox.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,136 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using Microsoft.Xna.Framework;
-using Microsoft.Xna.Framework.Graphics;
-using libsecondlife;
-
-namespace sceneviewer.Prims
-{
-    public class PrimVisualBox : LinearPrimVisual
-    {
-        public PrimVisualBox(PrimObject prim) : base(prim)
-        {
-            NumberFaces = 4;
-            FirstOuterFace = 0;
-            LastOuterFace = 3;
-
-            ReferenceVertices = new Vector3[4];
-
-            ReferenceVertices[1] = new Vector3(0.5f, -0.5f, 0f);
-            ReferenceVertices[2] = new Vector3(0.5f, 0.5f, 0f);
-            ReferenceVertices[3] = new Vector3(-0.5f, 0.5f, 0f);
-            ReferenceVertices[0] = new Vector3(-0.5f, -0.5f, 0f);
-
-            OuterFaces = new CrossSection[4];
-            for (int i = 0; i &lt; 4; i++)
-            {
-                OuterFaces[i] = new CrossSection();
-            }
-
-            if (prim.ProfileHollow != 0)
-            {
-                hollow = true;
-                InnerFaces = new CrossSection[4];
-                for (int i = 0; i &lt; 4; i++)
-                {
-                    InnerFaces[i] = new CrossSection();
-                }
-            }
-
-            if (prim.ProfileBegin != 0 || prim.ProfileEnd != 1)
-            {
-                cut = true;
-                CutFaces = new CrossSection[2];
-                for (int i = 0; i &lt; 2; i++)
-                {
-                    CutFaces[i] = new CrossSection();
-                }
-            }
-
-            BuildFaces();
-        }
-
-        protected override void AssignFaces()
-        {
-        }
-
-        protected override int GetCutQuadrant(float cut)
-        {
-            if (cut == 1) { return 3; }
-            else { return (int)(cut * 4.0); }
-        }
-
-        protected override float GetAngleWithXAxis(float cut)
-        {
-            //return (cut - 0.125f) * 2f * (float)Math.PI;
-            return (cut + 0.125f) * 2f * (float)Math.PI;
-        }
-
-        protected override void BuildEndCapHollow(bool top)
-        {
-            float z = top ? 0.5f : -0.5f;
-
-            for (int i = FirstOuterFace; i &lt;= LastOuterFace; i++)
-            {
-                int pointCount = OuterFaces[i].GetNumPoints();
-
-                if (pointCount &gt;= 2)
-                {
-                    Vector3 p1 = OuterFaces[i].GetRawVertex(0);
-                    Vector3 p2 = OuterFaces[i].GetRawVertex(1);
-                    Vector3 p3 = InnerFaces[i].GetRawVertex(0);
-                    Vector3 p4 = InnerFaces[i].GetRawVertex(1);
-
-                    p1.Z = p2.Z = p3.Z = p4.Z = z;
-
-                    // TODO: Texturemapping
-                    //Vector2 t1 = texturemapping.GetTextureCoordinate(new Vector2(1 - (r1.x + 0.5), r1.y + 0.5));
-                    //Vector2 t2 = texturemapping.GetTextureCoordinate(new Vector2(1 - (r2.x + 0.5), r2.y + 0.5));
-                    //Vector2 t3 = texturemapping.GetTextureCoordinate(new Vector2(1 - (r3.x + 0.5), r3.y + 0.5));
-                    //Vector2 t4 = texturemapping.GetTextureCoordinate(new Vector2(1 - (r4.x + 0.5), r4.y + 0.5));
-
-                    float transformRatio = top ? 1 : 0;
-
-                    p1 = Transform(p1, transformRatio);
-                    p2 = Transform(p2, transformRatio);
-                    p3 = Transform(p3, transformRatio);
-                    p4 = Transform(p4, transformRatio);
-
-                    Vertexes.Add(new VertexPositionColor(p4, color));
-                    Vertexes.Add(new VertexPositionColor(p3, color));
-                    Vertexes.Add(new VertexPositionColor(p2, color));
-
-                    Vertexes.Add(new VertexPositionColor(p4, color));
-                    Vertexes.Add(new VertexPositionColor(p2, color));
-                    Vertexes.Add(new VertexPositionColor(p1, color));
-                }
-            }
-        }
-    }
-}

Copied: branches/aditi/applications/sceneviewer/Prims/PrimVisualBox.cs (from rev 649, trunk/applications/sceneviewer/Prims/PrimVisualBox.cs)

Deleted: branches/aditi/applications/sceneviewer/Prims/PrimVisualCylinder.cs
===================================================================
--- trunk/applications/sceneviewer/Prims/PrimVisualCylinder.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Prims/PrimVisualCylinder.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,196 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using Microsoft.Xna.Framework;
-using Microsoft.Xna.Framework.Graphics;
-using libsecondlife;
-
-namespace sceneviewer.Prims
-{
-    public class PrimVisualCylinder : LinearPrimVisual
-    {
-        public PrimVisualCylinder(PrimObject prim)
-            : base(prim)
-        {
-            NumberFaces = 1;
-            FirstOuterFace = 0;
-            LastOuterFace = 0;
-
-            OuterFaces = new CrossSection[1];
-            OuterFaces[0] = new CrossSection();
-
-            if (prim.ProfileHollow != 0)
-            {
-                hollow = true;
-                InnerFaces = new CrossSection[1];
-                InnerFaces[0] = new CrossSection();
-
-                //for (int i = 0; i &lt; 4; i++)
-                //{
-                //    InnerFaces[i] = new CrossSection();
-                //}
-            }
-
-            if (prim.ProfileBegin != 0 || prim.ProfileEnd != 1)
-            {
-                cut = true;
-                CutFaces = new CrossSection[2];
-                for (int i = 0; i &lt; 2; i++)
-                {
-                    CutFaces[i] = new CrossSection();
-                }
-            }
-
-            BuildFaces();
-        }
-
-        protected override void AssignFaces()
-        {
-        }
-
-        protected Vector3 GetCutIntersect(float cut, float primHalfWidth)
-        {
-            double angle = cut * 2 * Math.PI;
-            return new Vector3((float)(primHalfWidth * Math.Cos(angle)), (float)(primHalfWidth * Math.Sin(angle)), 0);
-        }
-
-        protected override float GetAngleWithXAxis(float cut)
-        {
-            return cut * 2 * (float)Math.PI;
-        }
-
-        protected override int GetCutQuadrant(float cut)
-        {
-            return 0;
-        }
-
-        protected override void BuildFaces()
-        {
-            float hollowRatio = Prim.ProfileHollow / 100.0f;
-
-            Vector3 cutstartinnerface;
-            Vector3 cutendinnerface;
-
-            Vector3 cutstartouterface = GetCutIntersect(Prim.ProfileBegin, 0.5f);
-            Vector3 cutendouterface = GetCutIntersect(Prim.ProfileEnd, 0.5f);
-
-            OuterFaces[0].RemoveAllPoints();
-
-            if (hollow)
-            {
-                InnerFaces[0].RemoveAllPoints();
-
-                cutstartinnerface = GetCutIntersect(Prim.ProfileBegin, hollowRatio * 0.5f);
-                cutendinnerface = GetCutIntersect(Prim.ProfileEnd, hollowRatio * 0.5f);
-
-                if (cut)
-                {
-                    BuildCutHollowFaces(cutstartouterface, cutstartinnerface, cutendouterface, cutendinnerface);
-                }
-            }
-            else if (cut)
-            {
-                BuildCutFaces(cutstartouterface, cutendouterface);
-            }
-
-            double angle = 0;
-            double startAngle = Prim.ProfileBegin * 2 * Math.PI;
-            double endAngle = Prim.ProfileEnd * 2 * Math.PI;
-
-            Vector3 nextOuterPoint = Vector3.Zero;
-            Vector3 nextInnerPoint = Vector3.Zero;
-
-            for (int facePoint = 0; facePoint &lt;= LevelOfDetail; facePoint++)
-            {
-                angle = startAngle + ((double)facePoint / (double)LevelOfDetail) * (endAngle - startAngle);
-
-                nextOuterPoint.X = (float)(0.5 * Math.Cos(angle));
-                nextOuterPoint.Y = (float)(0.5 * Math.Sin(angle));
-                OuterFaces[0].AddPoint(nextOuterPoint);
-            }
-
-            if (hollow)
-            {
-                //for (int facePoint = LevelOfDetail; facePoint &gt;= 0; facePoint--)
-                for (int facePoint = 0; facePoint &lt;= LevelOfDetail; facePoint++)
-                {
-                    angle = startAngle + ((double)facePoint / (double)LevelOfDetail) * (endAngle - startAngle);
-
-                    nextInnerPoint.X = (float)(0.5 * Math.Cos(angle) * hollowRatio);
-                    nextInnerPoint.Y = (float)(0.5 * Math.Sin(angle) * hollowRatio);
-                    InnerFaces[0].AddPoint(nextInnerPoint);
-                }
-            }
-
-            // TODO: Texturemapping
-
-            AssignFaces();
-
-            BuildVertexes();
-        }
-
-        protected override void BuildEndCapHollow(bool top)
-        {
-            float z = top ? 0.5f : -0.5f;
-
-            // We assume the innerfaces and outerfaces point counts are the same
-            int pointCount = OuterFaces[0].GetNumPoints();
-
-            for (int j = 0; j &lt; pointCount - 1; j++)
-            {
-                Vector3 p1 = OuterFaces[0].GetRawVertex(j);
-                Vector3 p2 = OuterFaces[0].GetRawVertex(j + 1);
-                Vector3 p3 = InnerFaces[0].GetRawVertex(j);
-                Vector3 p4 = InnerFaces[0].GetRawVertex(j + 1);
-
-                p1.Z = p2.Z = p3.Z = p4.Z = z;
-
-                // TODO: Texturemapping
-                //Vector2 t1 = texturemapping.GetTextureCoordinate(new Vector2(1 - (r1.x + 0.5), r1.y + 0.5));
-                //Vector2 t2 = texturemapping.GetTextureCoordinate(new Vector2(1 - (r2.x + 0.5), r2.y + 0.5));
-                //Vector2 t3 = texturemapping.GetTextureCoordinate(new Vector2(1 - (r3.x + 0.5), r3.y + 0.5));
-                //Vector2 t4 = texturemapping.GetTextureCoordinate(new Vector2(1 - (r4.x + 0.5), r4.y + 0.5));
-
-                float transformRatio = top ? 1 : 0;
-
-                p1 = Transform(p1, transformRatio);
-                p2 = Transform(p2, transformRatio);
-                p3 = Transform(p3, transformRatio);
-                p4 = Transform(p4, transformRatio);
-
-                Vertexes.Add(new VertexPositionColor(p4, color));
-                Vertexes.Add(new VertexPositionColor(p3, color));
-                Vertexes.Add(new VertexPositionColor(p2, color));
-
-                Vertexes.Add(new VertexPositionColor(p3, color));
-                Vertexes.Add(new VertexPositionColor(p2, color));
-                Vertexes.Add(new VertexPositionColor(p1, color));
-            }
-        }
-    }
-}

Copied: branches/aditi/applications/sceneviewer/Prims/PrimVisualCylinder.cs (from rev 649, trunk/applications/sceneviewer/Prims/PrimVisualCylinder.cs)

Deleted: branches/aditi/applications/sceneviewer/Prims/PrimVisualPrism.cs
===================================================================
--- trunk/applications/sceneviewer/Prims/PrimVisualPrism.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Prims/PrimVisualPrism.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,64 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using Microsoft.Xna.Framework;
-using Microsoft.Xna.Framework.Graphics;
-using libsecondlife;
-
-namespace sceneviewer.Prims
-{
-    public class PrimVisualPrism : LinearPrimVisual
-    {
-        public PrimVisualPrism(PrimObject prim)
-            : base(prim)
-        {
-            ;
-        }
-
-        protected override void AssignFaces()
-        {
-        }
-
-        protected override int GetCutQuadrant(float cut)
-        {
-            // FIXME
-            //return cut / 67;
-            return 0;
-        }
-
-        // should return angle in radians for a given cut ratio (?)
-        protected override float GetAngleWithXAxis(float cut)
-        {
-            return (cut - (30f / 360f)) * 2 * (float)Math.PI;
-        }
-
-        protected override void BuildEndCapHollow(bool top)
-        {
-        }
-    }
-}
\ No newline at end of file

Copied: branches/aditi/applications/sceneviewer/Prims/PrimVisualPrism.cs (from rev 649, trunk/applications/sceneviewer/Prims/PrimVisualPrism.cs)

Deleted: branches/aditi/applications/sceneviewer/Prims/PrimVisualRing.cs
===================================================================
--- trunk/applications/sceneviewer/Prims/PrimVisualRing.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Prims/PrimVisualRing.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using Microsoft.Xna.Framework;
-using Microsoft.Xna.Framework.Graphics;
-using libsecondlife;
-
-namespace sceneviewer.Prims
-{
-    public class PrimVisualRing : RotationalPrimVisual
-    {
-        public PrimVisualRing(PrimObject prim)
-            : base(prim)
-        {
-            NumberFaces = 3;
-            FirstOuterFace = 0;
-            LastOuterFace = 2;
-
-            ReferenceVertices = new Vector3[3];
-
-            ReferenceVertices[0] = new Vector3(0.5f, -0.5f, 0f);
-            ReferenceVertices[1] = new Vector3(0f, 0.5f, 0f);
-            ReferenceVertices[2] = new Vector3(-0.5f, -0.5f, 0f);
-
-            OuterFaces = new CrossSection[4];
-            for (int i = 0; i &lt; 4; i++)
-            {
-                OuterFaces[i] = new CrossSection();
-            }
-
-            if (prim.ProfileHollow != 0)
-            {
-                hollow = true;
-                InnerFaces = new CrossSection[4];
-                for (int i = 0; i &lt; 4; i++)
-                {
-                    InnerFaces[i] = new CrossSection();
-                }
-            }
-
-            if (prim.ProfileBegin != 0 || prim.ProfileEnd != 1)
-            {
-                cut = true;
-                CutFaces = new CrossSection[2];
-                for (int i = 0; i &lt; 2; i++)
-                {
-                    CutFaces[i] = new CrossSection();
-                }
-            }
-
-            BuildFaces();
-        }
-
-        protected override void AssignFaces()
-        {
-        }
-
-        protected override void BuildFaces()
-        {
-        }
-
-        protected override int GetCutQuadrant(float cut)
-        {
-            return (int)(cut / (67f / 255f)) % 3;
-        }
-
-        protected override float GetAngleWithXAxis(float cut)
-        {
-            return (cut - 0.125f) * 2 * (float)Math.PI;
-        }
-
-        //protected override void BuildEndCapHollow(bool top)
-        //{
-        //}
-    }
-}
\ No newline at end of file

Copied: branches/aditi/applications/sceneviewer/Prims/PrimVisualRing.cs (from rev 649, trunk/applications/sceneviewer/Prims/PrimVisualRing.cs)

Deleted: branches/aditi/applications/sceneviewer/Prims/PrimVisualSphere.cs
===================================================================
--- trunk/applications/sceneviewer/Prims/PrimVisualSphere.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Prims/PrimVisualSphere.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,67 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using Microsoft.Xna.Framework;
-using Microsoft.Xna.Framework.Graphics;
-using libsecondlife;
-
-namespace sceneviewer.Prims
-{
-    public class PrimVisualSphere : RotationalPrimVisual
-    {
-        public PrimVisualSphere(PrimObject prim)
-            : base(prim)
-        {
-            ;
-        }
-
-        protected override void AssignFaces()
-        {
-        }
-
-        protected override void BuildFaces()
-        {
-        }
-
-        protected override int GetCutQuadrant(float cut)
-        {
-            // FIXME: ?
-            return 0;
-        }
-
-        protected override float GetAngleWithXAxis(float cut)
-        {
-            // FIXME: Is this correct?
-            return (cut - 0.125f) * 2 * (float)Math.PI;
-        }
-
-        //protected override void BuildEndCapHollow(bool top)
-        //{
-        //}
-    }
-}

Copied: branches/aditi/applications/sceneviewer/Prims/PrimVisualSphere.cs (from rev 649, trunk/applications/sceneviewer/Prims/PrimVisualSphere.cs)

Deleted: branches/aditi/applications/sceneviewer/Prims/PrimVisualTorus.cs
===================================================================
--- trunk/applications/sceneviewer/Prims/PrimVisualTorus.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Prims/PrimVisualTorus.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using Microsoft.Xna.Framework;
-using Microsoft.Xna.Framework.Graphics;
-using libsecondlife;
-
-namespace sceneviewer.Prims
-{
-    public class PrimVisualTorus : LinearPrimVisual
-    {
-        public PrimVisualTorus(PrimObject prim)
-            : base(prim)
-        {
-            ;
-        }
-
-        protected override void AssignFaces()
-        {
-        }
-
-        protected override int GetCutQuadrant(float cut)
-        {
-            return 0;
-        }
-
-        protected override float GetAngleWithXAxis(float cut)
-        {
-            return cut * 2 * (float)Math.PI;
-        }
-
-        protected override void BuildEndCapHollow(bool top)
-        {
-        }
-    }
-}

Copied: branches/aditi/applications/sceneviewer/Prims/PrimVisualTorus.cs (from rev 649, trunk/applications/sceneviewer/Prims/PrimVisualTorus.cs)

Deleted: branches/aditi/applications/sceneviewer/Prims/PrimVisualTube.cs
===================================================================
--- trunk/applications/sceneviewer/Prims/PrimVisualTube.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Prims/PrimVisualTube.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,63 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using Microsoft.Xna.Framework;
-using Microsoft.Xna.Framework.Graphics;
-using libsecondlife;
-
-namespace sceneviewer.Prims
-{
-    public class PrimVisualTube : LinearPrimVisual
-    {
-        public PrimVisualTube(PrimObject prim)
-            : base(prim)
-        {
-            ;
-        }
-
-        protected override void AssignFaces()
-        {
-        }
-
-        protected override int GetCutQuadrant(float cut)
-        {
-            // FIXME: This is wrong
-            //return ((cut / 50) % 4 + 4) % 4;
-            return 0;
-        }
-
-        protected override float GetAngleWithXAxis(float cut)
-        {
-            return (cut - 0.125f) * 2 * (float)Math.PI;
-        }
-
-        protected override void BuildEndCapHollow(bool top)
-        {
-        }
-    }
-}
\ No newline at end of file

Copied: branches/aditi/applications/sceneviewer/Prims/PrimVisualTube.cs (from rev 649, trunk/applications/sceneviewer/Prims/PrimVisualTube.cs)

Copied: branches/aditi/applications/sceneviewer/Properties (from rev 649, trunk/applications/sceneviewer/Properties)

Deleted: branches/aditi/applications/sceneviewer/Properties/AssemblyInfo.cs
===================================================================
--- trunk/applications/sceneviewer/Properties/AssemblyInfo.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/Properties/AssemblyInfo.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,33 +0,0 @@
-&#65279;using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// General Information about an assembly is controlled through the following 
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle(&quot;sceneviewer&quot;)]
-[assembly: AssemblyProduct(&quot;sceneviewer&quot;)]
-[assembly: AssemblyDescription(&quot;&quot;)]
-[assembly: AssemblyCompany(&quot;&quot;)]
-
-[assembly: AssemblyCopyright(&quot;Copyright &#169;  2006&quot;)]
-[assembly: AssemblyTrademark(&quot;&quot;)]
-[assembly: AssemblyCulture(&quot;&quot;)]
-
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
-// COM, set the ComVisible attribute to true on that type.
-[assembly: ComVisible(false)]
-
-// The following GUID is for the ID of the typelib if this project is exposed to COM
-[assembly: Guid(&quot;f8359d28-d0d4-41bb-b025-11f793e0c678&quot;)]
-
-
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version 
-//      Build Number
-//      Revision
-//
-[assembly: AssemblyVersion(&quot;1.0.0.0&quot;)]

Copied: branches/aditi/applications/sceneviewer/Properties/AssemblyInfo.cs (from rev 649, trunk/applications/sceneviewer/Properties/AssemblyInfo.cs)

Deleted: branches/aditi/applications/sceneviewer/README.txt
===================================================================
--- trunk/applications/sceneviewer/README.txt	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/README.txt	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,7 +0,0 @@
-sceneviewer uses XNA, a Microsoft DirectX technology for the .NET framework. 
-Currently the XNA framework requires Visual C# Express (it can be installed 
-alongside VS2005 or any other IDE), and the XNA Game Studio Express Beta 2.
-
-C# Express: <A HREF="http://msdn.microsoft.com/vstudio/express/visualcsharp/">http://msdn.microsoft.com/vstudio/express/visualcsharp/</A>
-XNA:        <A HREF="http://msdn.microsoft.com/directx/XNA/default.aspx">http://msdn.microsoft.com/directx/XNA/default.aspx</A>
-XGE:        <A HREF="http://msdn.microsoft.com/directx/xna/gse/">http://msdn.microsoft.com/directx/xna/gse/</A>

Copied: branches/aditi/applications/sceneviewer/README.txt (from rev 649, trunk/applications/sceneviewer/README.txt)

Deleted: branches/aditi/applications/sceneviewer/sceneviewer.csproj
===================================================================
--- trunk/applications/sceneviewer/sceneviewer.csproj	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/sceneviewer.csproj	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,164 +0,0 @@
-&#65279;&lt;Project DefaultTargets=&quot;Build&quot; xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot;&gt;
-  &lt;PropertyGroup&gt;
-    &lt;ProjectGuid&gt;{2E2A4A58-39A7-485F-BC99-F12F86E0A40A}&lt;/ProjectGuid&gt;
-    &lt;ProjectTypeGuids&gt;{9F340DF3-2AED-4330-AC16-78AC2D9B4738};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&lt;/ProjectTypeGuids&gt;
-    &lt;Configuration Condition=&quot; '$(Configuration)' == '' &quot;&gt;Debug&lt;/Configuration&gt;
-    &lt;Platform Condition=&quot; '$(Platform)' == '' &quot;&gt;x86&lt;/Platform&gt;
-    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
-    &lt;AppDesignerFolder&gt;Properties&lt;/AppDesignerFolder&gt;
-    &lt;RootNamespace&gt;sceneviewer&lt;/RootNamespace&gt;
-    &lt;AssemblyName&gt;sceneviewer&lt;/AssemblyName&gt;
-    &lt;XnaFrameworkVersion&gt;v1.0&lt;/XnaFrameworkVersion&gt;
-    &lt;XnaPlatform&gt;Windows&lt;/XnaPlatform&gt;
-    &lt;ApplicationIcon&gt;Game.ico&lt;/ApplicationIcon&gt;
-    &lt;XNAGlobalContentPipelineAssemblies&gt;Microsoft.Xna.Framework.Content.Pipeline.EffectImporter.dll;Microsoft.Xna.Framework.Content.Pipeline.FBXImporter.dll;Microsoft.Xna.Framework.Content.Pipeline.TextureImporter.dll;Microsoft.Xna.Framework.Content.Pipeline.XImporter.dll&lt;/XNAGlobalContentPipelineAssemblies&gt;
-    &lt;XNAProjectContentPipelineAssemblies&gt;
-    &lt;/XNAProjectContentPipelineAssemblies&gt;
-  &lt;/PropertyGroup&gt;
-  &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Debug|x86' &quot;&gt;
-    &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
-    &lt;DebugType&gt;full&lt;/DebugType&gt;
-    &lt;Optimize&gt;false&lt;/Optimize&gt;
-    &lt;OutputPath&gt;bin\&lt;/OutputPath&gt;
-    &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
-    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
-    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
-    &lt;NoStdLib&gt;true&lt;/NoStdLib&gt;
-    &lt;UseVSHostingProcess&gt;false&lt;/UseVSHostingProcess&gt;
-    &lt;PlatformTarget&gt;x86&lt;/PlatformTarget&gt;
-  &lt;/PropertyGroup&gt;
-  &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Release|x86' &quot;&gt;
-    &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
-    &lt;Optimize&gt;true&lt;/Optimize&gt;
-    &lt;OutputPath&gt;bin\x86\Release&lt;/OutputPath&gt;
-    &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
-    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
-    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
-    &lt;NoStdLib&gt;true&lt;/NoStdLib&gt;
-    &lt;UseVSHostingProcess&gt;false&lt;/UseVSHostingProcess&gt;
-    &lt;PlatformTarget&gt;x86&lt;/PlatformTarget&gt;
-  &lt;/PropertyGroup&gt;
-  &lt;ItemGroup&gt;
-    &lt;Reference Include=&quot;libsecondlife, Version=0.0.6.0, Culture=neutral, processorArchitecture=MSIL&quot;&gt;
-      &lt;SpecificVersion&gt;False&lt;/SpecificVersion&gt;
-      &lt;HintPath&gt;..\..\bin\libsecondlife.dll&lt;/HintPath&gt;
-    &lt;/Reference&gt;
-    &lt;Reference Include=&quot;Microsoft.Xna.Framework&quot;&gt;
-      &lt;Private&gt;False&lt;/Private&gt;
-    &lt;/Reference&gt;
-    &lt;Reference Include=&quot;Microsoft.Xna.Framework.Game&quot;&gt;
-      &lt;Private&gt;False&lt;/Private&gt;
-    &lt;/Reference&gt;
-    &lt;Reference Include=&quot;mscorlib&quot;&gt;
-      &lt;Private&gt;False&lt;/Private&gt;
-    &lt;/Reference&gt;
-    &lt;Reference Include=&quot;System&quot;&gt;
-      &lt;Private&gt;False&lt;/Private&gt;
-    &lt;/Reference&gt;
-  &lt;/ItemGroup&gt;
-  &lt;ItemGroup&gt;
-    &lt;Compile Include=&quot;Camera.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;Camera&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\CrossSection.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;CrossSection&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\LinearPrimVisual.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;LinearPrimVisual&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\PrimVisual.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;PrimVisual&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\PrimVisualBox.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;PrimVisualBox&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\PrimVisualCylinder.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;PrimVisualCylinder&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\PrimVisualPrism.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;PrimVisualPrism&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\PrimVisualRing.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;PrimVisualRing&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\PrimVisualSphere.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;PrimVisualSphere&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\PrimVisualTorus.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;PrimVisualTorus&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\PrimVisualTube.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;PrimVisualTube&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Prims\RotationalPrimVisual.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;RotationalPrimVisual&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;Properties\AssemblyInfo.cs&quot; /&gt;
-    &lt;Compile Include=&quot;Program.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;Program&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;sceneviewer.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;sceneviewer&lt;/Name&gt;
-    &lt;/Compile&gt;
-    &lt;Compile Include=&quot;VertexPosTexNormalTanBitan.cs&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;VertexPosTexNormalTanBitan&lt;/Name&gt;
-    &lt;/Compile&gt;
-  &lt;/ItemGroup&gt;
-  &lt;ItemGroup&gt;
-    &lt;Content Include=&quot;Game.ico&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;false&lt;/XNAUseContentPipeline&gt;
-      &lt;Name&gt;Game&lt;/Name&gt;
-    &lt;/Content&gt;
-  &lt;/ItemGroup&gt;
-  &lt;ItemGroup&gt;
-    &lt;Content Include=&quot;Shaders\basicprim.fx&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;true&lt;/XNAUseContentPipeline&gt;
-      &lt;Importer&gt;EffectImporter&lt;/Importer&gt;
-      &lt;Processor&gt;EffectProcessor&lt;/Processor&gt;
-      &lt;Name&gt;basicprim&lt;/Name&gt;
-    &lt;/Content&gt;
-    &lt;Content Include=&quot;Shaders\ocean.fx&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;true&lt;/XNAUseContentPipeline&gt;
-      &lt;Importer&gt;EffectImporter&lt;/Importer&gt;
-      &lt;Processor&gt;EffectProcessor&lt;/Processor&gt;
-      &lt;Name&gt;ocean&lt;/Name&gt;
-    &lt;/Content&gt;
-    &lt;Content Include=&quot;Textures\cubemap.dds&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;true&lt;/XNAUseContentPipeline&gt;
-      &lt;Importer&gt;TextureImporter&lt;/Importer&gt;
-      &lt;Processor&gt;SpriteTextureProcessor&lt;/Processor&gt;
-      &lt;Name&gt;cubemap&lt;/Name&gt;
-    &lt;/Content&gt;
-    &lt;Content Include=&quot;Textures\wavenormalmap.dds&quot;&gt;
-      &lt;XNAUseContentPipeline&gt;true&lt;/XNAUseContentPipeline&gt;
-      &lt;Importer&gt;TextureImporter&lt;/Importer&gt;
-      &lt;Processor&gt;SpriteTextureProcessor&lt;/Processor&gt;
-      &lt;Name&gt;wavenormalmap&lt;/Name&gt;
-    &lt;/Content&gt;
-  &lt;/ItemGroup&gt;
-  &lt;Import Project=&quot;$(MSBuildBinPath)\Microsoft.CSharp.targets&quot; /&gt;
-  &lt;Import Project=&quot;$(MSBuildExtensionsPath)\Microsoft\XNA\Game Studio Express\v1.0\Microsoft.Xna.ContentPipeline.targets&quot; /&gt;
-  &lt;Import Project=&quot;$(MSBuildExtensionsPath)\Microsoft\XNA\Game Studio Express\v1.0\Microsoft.Xna.Common.targets&quot; /&gt;
-  &lt;!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
-       Other similar extension points exist, see Microsoft.Common.targets.
-  &lt;Target Name=&quot;BeforeBuild&quot;&gt;
-  &lt;/Target&gt;
-  &lt;Target Name=&quot;AfterBuild&quot;&gt;
-  &lt;/Target&gt;
-  --&gt;
-&lt;/Project&gt;
\ No newline at end of file

Copied: branches/aditi/applications/sceneviewer/sceneviewer.csproj (from rev 649, trunk/applications/sceneviewer/sceneviewer.csproj)

Deleted: branches/aditi/applications/sceneviewer/sceneviewer.sln
===================================================================
--- trunk/applications/sceneviewer/sceneviewer.sln	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/applications/sceneviewer/sceneviewer.sln	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,20 +0,0 @@
-&#65279;
-Microsoft Visual Studio Solution File, Format Version 9.00
-# Visual C# Express 2005
-Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;sceneviewer&quot;, &quot;sceneviewer.csproj&quot;, &quot;{2E2A4A58-39A7-485F-BC99-F12F86E0A40A}&quot;
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|x86 = Debug|x86
-		Release|x86 = Release|x86
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{2E2A4A58-39A7-485F-BC99-F12F86E0A40A}.Debug|x86.ActiveCfg = Debug|x86
-		{2E2A4A58-39A7-485F-BC99-F12F86E0A40A}.Debug|x86.Build.0 = Debug|x86
-		{2E2A4A58-39A7-485F-BC99-F12F86E0A40A}.Release|x86.ActiveCfg = Release|x86
-		{2E2A4A58-39A7-485F-BC99-F12F86E0A40A}.Release|x86.Build.0 = Release|x86
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal

Copied: branches/aditi/applications/sceneviewer/sceneviewer.sln (from rev 649, trunk/applications/sceneviewer/sceneviewer.sln)


Property changes on: branches/aditi/bin
___________________________________________________________________
Name: svn:ignore
   + *.exe
*.pdb
*.dll



Property changes on: branches/aditi/libjaspernet
___________________________________________________________________
Name: svn:ignore
   + 
obj


Modified: branches/aditi/libjaspernet/JasperWrapper.cs
===================================================================
--- branches/aditi/libjaspernet/JasperWrapper.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libjaspernet/JasperWrapper.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -94,16 +94,28 @@
 {
     const string JASPER_LIBRARY = &quot;libjasper.dll&quot;;
 
+    protected static bool Initialized = false;
+    protected static int Initialized_Value;
+
     [DllImport(JASPER_LIBRARY)]
-    public static extern int jas_init();
+    protected static extern int jas_init();
 
+    public static void jasper_init()
+    {
+        if (!Initialized)
+        {
+            Initialized = true;
+            jas_init();  // always returns zero.
+        }
+    }
+
     [DllImport(JASPER_LIBRARY)]
     private static extern IntPtr jas_getversion();
 
     [DllImport(JASPER_LIBRARY)]
     private static extern int jas_setdbglevel(int level);
 
-    [DllImport(JASPER_LIBRARY)]
+    [DllImport(JASPER_LIBRARY, CharSet=CharSet.Ansi)]
     public static extern IntPtr jas_stream_fopen(string filename, string mode);
 
     [DllImport(JASPER_LIBRARY)]
@@ -136,16 +148,16 @@
     public static extern int jas_image_getfmt(IntPtr stream);
 
     /* Get the ID for the image format with the specified name. */
-    [DllImport(JASPER_LIBRARY)]
+    [DllImport(JASPER_LIBRARY, CharSet=CharSet.Ansi)]
     private static extern int jas_image_strtofmt(string name);
 
-    [DllImport(JASPER_LIBRARY)]
+    [DllImport(JASPER_LIBRARY, CharSet=CharSet.Ansi)]
     public static extern int jas_image_fmtfromname(string filename);
 
-    [DllImport(JASPER_LIBRARY)]
+    [DllImport(JASPER_LIBRARY, CharSet=CharSet.Ansi)]
     public static extern int jas_image_encode(IntPtr image, IntPtr out_stream, int fmt, string optstr);
 
-    [DllImport(JASPER_LIBRARY)]
+    [DllImport(JASPER_LIBRARY, CharSet=CharSet.Ansi)]
     public static extern IntPtr jas_image_decode(IntPtr in_stream, int fmt, string optstr);
 
     [DllImport(JASPER_LIBRARY)]
@@ -165,7 +177,7 @@
 
     public static string get_jasper_version()
     {
-        string text = Marshal.PtrToStringAuto(jas_getversion());
+        string text = Marshal.PtrToStringAnsi(jas_getversion());
         if (text == null) throw new Exception(&quot;jas_getversion returned NULL\n&quot;);
         return text;
     }
@@ -210,8 +222,51 @@
         get { return get_jasper_version(); }
     }
 
+    /* This function can convert any file format that GeoJASPER can read
+       (tif, jpg, bmp, pnm, ras) into j2c.  The input format is determined
+       by the extension of the input file. */
+
+    public static byte[] jasper_encode_j2c(string filename) {
+      jasper_init();
+      IntPtr input_stream_ptr = jas_stream_fopen(filename, &quot;rb&quot;);
+      int format = jas_image_getfmt(input_stream_ptr);
+      
+      Console.WriteLine(&quot;file is format # &quot; + format);
+      
+      IntPtr image_ptr = jas_image_decode(input_stream_ptr, format, &quot;&quot;);
+      if (image_ptr == IntPtr.Zero) throw new Exception(&quot;Error decoding image&quot;);
+      jas_image_t image_struct = jas_image_t.fromPtr(image_ptr);
+      
+      int output_buffer_size = image_struct.width * image_struct.height *
+				image_struct.numcmpts * 4 + 4096;  // it's called a safety margin
+      
+      IntPtr bufPtr = Marshal.AllocHGlobal(output_buffer_size);
+      IntPtr output_stream_ptr = jas_stream_memopen(bufPtr, output_buffer_size);
+      
+      Console.WriteLine(&quot;Ready to encode&quot;);
+      Console.WriteLine(&quot;jas_image_strtofmt(j2c)=&quot; + jas_image_strtofmt(&quot;j2c&quot;));
+      Console.WriteLine(&quot;jas_image_strtofmt(tif)=&quot; + jas_image_strtofmt(&quot;tif&quot;));
+      int retval = jas_image_encode(image_ptr, output_stream_ptr,
+				    jas_image_strtofmt(&quot;j2c&quot;), &quot;&quot;);
+      
+      jas_stream_flush(output_stream_ptr);
+      if (retval != 0) throw new Exception(&quot;Error encoding image: &quot; + retval);
+      
+      byte[] buf = new byte[output_buffer_size];
+      Marshal.Copy(bufPtr, buf, 0, output_buffer_size);
+      Marshal.FreeHGlobal(bufPtr);
+      
+      jas_image_destroy(image_ptr);
+      
+      jas_stream_close(input_stream_ptr);
+      
+      return buf;
+    }
+    
     public static byte[] jasper_decode_j2c_to_tiff(byte[] input)
     {
+        jasper_init();
+
         int header_size = 1024;  // a guess
         IntPtr input_stream_ptr = jas_stream_memopen(input);
         IntPtr temp_stream_ptr = jas_stream_tmpfile();
@@ -224,7 +279,9 @@
         if (image_ptr == IntPtr.Zero) throw new Exception(&quot;Error decoding image&quot;);
         jas_image_t image_struct = jas_image_t.fromPtr(image_ptr);
 
-        int output_buffer_size = image_struct.width * image_struct.height * 4 + header_size;
+        int output_buffer_size = image_struct.width * image_struct.height *
+				image_struct.numcmpts * 4 + 4096;  // it's called a safety margin
+
         IntPtr bufPtr = Marshal.AllocHGlobal(output_buffer_size);
         IntPtr output_stream_ptr = jas_stream_memopen(bufPtr, output_buffer_size);
 
@@ -255,6 +312,8 @@
 
     public static byte[] jasper_decode_j2c_to_tga(byte[] input)
     {
+        jasper_init();
+
         int header_size = 32;  // roughly
         IntPtr input_stream_ptr = jas_stream_memopen(input);
 
@@ -283,7 +342,7 @@
         int offset = 0;
         output[offset++] = 0; // idlength
         output[offset++] = 0; // colormaptype = 0: no colormap
-        output[offset++] = 2; // image type = 2: uncompressed RGB 
+        output[offset++] = 2; // image type = 2: uncompressed RGB
         output[offset++] = 0; // color map spec is five zeroes for no color map
         output[offset++] = 0; // color map spec is five zeroes for no color map
         output[offset++] = 0; // color map spec is five zeroes for no color map

Modified: branches/aditi/libjaspernet/libjasper.dll
===================================================================
(Binary files differ)


Property changes on: branches/aditi/libsecondlife-cs
___________________________________________________________________
Name: svn:ignore
   - obj

   + obj
bin
*.suo


Modified: branches/aditi/libsecondlife-cs/AssetSystem/AssetManager.cs
===================================================================
--- branches/aditi/libsecondlife-cs/AssetSystem/AssetManager.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/AssetSystem/AssetManager.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -24,6 +24,8 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+//#define DEBUG_PACKETS
+
 using System;
 using System.Collections.Generic;
 
@@ -32,6 +34,7 @@
 using libsecondlife.InventorySystem;
 
 using libsecondlife.Packets;
+using System.Threading;
 
 namespace libsecondlife.AssetSystem
 {
@@ -40,32 +43,15 @@
 	/// &lt;/summary&gt;
 	public class AssetManager
 	{
-        private const bool DEBUG_PACKETS = true;
 
 
 		public const int SINK_FEE_IMAGE = 1;
 
 		private SecondLife slClient;
 
-        private TransferRequest curUploadRequest = null;
-		private Dictionary&lt;LLUUID, TransferRequest&gt; htDownloadRequests = new Dictionary&lt;LLUUID,TransferRequest&gt;();
+        private AssetRequestUpload curUploadRequest = null;
+        private Dictionary&lt;LLUUID, AssetRequestDownload&gt; htDownloadRequests = new Dictionary&lt;LLUUID, AssetRequestDownload&gt;();
 
-		private class TransferRequest
-		{
-			public bool Completed;
-			public bool Status;
-			public string StatusMsg;
-
-			public int Size;
-			public int Received;
-			public uint LastPacketTime;
-            public uint LastPacketNumSent;
-			public byte[] AssetData;
-
-            public LLUUID TransactionID;
-            public LLUUID AssetID;
-		}
-
         /// &lt;summary&gt;
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
@@ -74,23 +60,13 @@
 			slClient = client;
 
 			// Used to upload small assets, or as an initial start packet for large transfers
-			PacketCallback AssetUploadCompleteCallback = new PacketCallback(AssetUploadCompleteCallbackHandler);
-            slClient.Network.RegisterCallback(PacketType.AssetUploadComplete, AssetUploadCompleteCallback);
-
-			// Transfer Packets for downloading large assets		
-			PacketCallback TransferInfoCallback = new PacketCallback(TransferInfoCallbackHandler);
-            slClient.Network.RegisterCallback(PacketType.TransferInfo, TransferInfoCallback);
-
-			PacketCallback TransferPacketCallback = new PacketCallback(TransferPacketCallbackHandler);
-            slClient.Network.RegisterCallback(PacketType.TransferPacket, TransferPacketCallback);
-
+            slClient.Network.RegisterCallback(PacketType.AssetUploadComplete, new NetworkManager.PacketCallback(AssetUploadCompleteCallbackHandler));
+			// Transfer Packets for downloading large assets
+            slClient.Network.RegisterCallback(PacketType.TransferInfo, new NetworkManager.PacketCallback(TransferInfoCallbackHandler));
+            slClient.Network.RegisterCallback(PacketType.TransferPacket, new NetworkManager.PacketCallback(TransferPacketCallbackHandler));
 			// XFer packets for uploading large assets
-			PacketCallback ConfirmXferPacketCallback = new PacketCallback(ConfirmXferPacketCallbackHandler);
-            slClient.Network.RegisterCallback(PacketType.ConfirmXferPacket, ConfirmXferPacketCallback);
-			
-			PacketCallback RequestXferCallback = new PacketCallback(RequestXferCallbackHandler);
-            slClient.Network.RegisterCallback(PacketType.RequestXfer, RequestXferCallback);
-			
+            slClient.Network.RegisterCallback(PacketType.ConfirmXferPacket, new NetworkManager.PacketCallback(ConfirmXferPacketCallbackHandler));
+            slClient.Network.RegisterCallback(PacketType.RequestXfer, new NetworkManager.PacketCallback(RequestXferCallbackHandler));
 		}
 
 
@@ -103,7 +79,7 @@
 			switch( sinkType )
 			{
 				case SINK_FEE_IMAGE:
-					slClient.Self.GiveMoney( new LLUUID(), 10, &quot;Image Upload&quot; );
+					slClient.Self.GiveMoney( LLUUID.Zero, 10, &quot;Image Upload&quot; );
 					break;
 				default:
 					throw new Exception(&quot;AssetManager: Unknown sinktype (&quot; + sinkType + &quot;)&quot;);
@@ -122,162 +98,122 @@
                 throw new Exception(&quot;An existing asset upload is currently in-progress.&quot;);
             }
 
-			Packet packet;
-            curUploadRequest = new TransferRequest();
-            curUploadRequest.Completed = false;
-			curUploadRequest.TransactionID = LLUUID.GenerateUUID();
+            try
+            {
+                curUploadRequest = new AssetRequestUpload(slClient, LLUUID.GenerateUUID(), asset);
 
-			if( asset.AssetData.Length &gt; 500 )
-			{
-                packet = AssetPacketHelpers.AssetUploadRequestHeaderOnly(asset, curUploadRequest.TransactionID);
-				slClient.Network.SendPacket(packet);
-                if (DEBUG_PACKETS) { Console.WriteLine(packet); }
-                curUploadRequest.AssetData = asset.AssetData;
-			} 
-			else 
-			{
-                packet = AssetPacketHelpers.AssetUploadRequest(asset, curUploadRequest.TransactionID);
-				slClient.Network.SendPacket(packet);
-                if (DEBUG_PACKETS) { Console.WriteLine(packet); }
+                LLUUID assetID = curUploadRequest.DoUpload();
+                if (asset.Type == Asset.ASSET_TYPE_IMAGE)
+                {
+                    //SinkFee(SINK_FEE_IMAGE);
+                }
+                return assetID;
             }
+            finally
+            {
+                curUploadRequest = null;
+            }
+		}
 
-			while( curUploadRequest.Completed == false )
-			{
-				slClient.Tick();
-			}
+        /// &lt;summary&gt;
+        /// Get the Asset data for an item, must be used when requesting a Notecard
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt;
+		public void GetInventoryAsset( InventoryItem item )
+		{
+			LLUUID TransferID = LLUUID.GenerateUUID();
 
-            if (curUploadRequest.Status == false)
-			{
-                throw new Exception(curUploadRequest.StatusMsg);
-			} else {
-				if( asset.Type == Asset.ASSET_TYPE_IMAGE )
-				{
-					SinkFee( SINK_FEE_IMAGE );
-				}
+            AssetRequestDownload request = new AssetRequestDownload(TransferID);
+            request.Size = int.MaxValue; // Number of bytes expected
+            request.Received = 0; // Number of bytes received
+            request.UpdateLastPacketTime(); // last time we recevied a packet for this request
 
-                asset.AssetID = curUploadRequest.AssetID;
+            htDownloadRequests[TransferID] = request;
 
-                return asset.AssetID;
-			}
+			Packet packet = AssetPacketHelpers.TransferRequest(slClient.Network.SessionID, slClient.Network.AgentID, TransferID, item );
+			slClient.Network.SendPacket(packet);
+
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
+
+            request.Completed.WaitOne();
+
+            item.SetAssetData(request.AssetData);
 		}
 
         /// &lt;summary&gt;
-        /// Get the Asset data for an item
+        /// Get Asset data, works with BodyShapes (type 13) but does not work with Notecards(type 7)
         /// &lt;/summary&gt;
-        /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt;
-		public void GetInventoryAsset( InventoryItem item )
+        /// &lt;param name=&quot;asset&quot;&gt;&lt;/param&gt;
+        public void GetInventoryAsset(Asset asset)
 		{
 			LLUUID TransferID = LLUUID.GenerateUUID();
 
-			TransferRequest tr = new TransferRequest();
-			tr.Completed  = false;
-			tr.Size		  = int.MaxValue; // Number of bytes expected
-			tr.Received   = 0; // Number of bytes received
-			tr.LastPacketTime = Helpers.GetUnixTime(); // last time we recevied a packet for this request
+            AssetRequestDownload request = new AssetRequestDownload(TransferID);
+            request.Size = int.MaxValue; // Number of bytes expected
+            request.Received = 0; // Number of bytes received
+            request.UpdateLastPacketTime(); // last time we recevied a packet for this request
 
-			htDownloadRequests[TransferID] = tr;
+            htDownloadRequests[TransferID] = request;
 
-			Packet packet = AssetPacketHelpers.TransferRequest(slClient.Network.SessionID, slClient.Network.AgentID, TransferID, item );
+			Packet packet = AssetPacketHelpers.TransferRequest4BodyShape(slClient.Network.SessionID, slClient.Network.AgentID, TransferID, asset );
 			slClient.Network.SendPacket(packet);
-            if (DEBUG_PACKETS) { Console.WriteLine(packet); }
 
-			while( tr.Completed == false )
-			{
-				slClient.Tick();
-			}
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
 
-			item.SetAssetData( tr.AssetData );
+            request.Completed.WaitOne();
+
+            asset.AssetData = request.AssetData;
+            
 		}
 
+
         private void AssetUploadCompleteCallbackHandler(Packet packet, Simulator simulator)
 		{
-            if (DEBUG_PACKETS) { Console.WriteLine(packet); }
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
+
             Packets.AssetUploadCompletePacket reply = (AssetUploadCompletePacket)packet;
 
-            curUploadRequest.AssetID = reply.AssetBlock.UUID;
-            bool Success = reply.AssetBlock.Success;
-
-			if( Success )
-			{
-                curUploadRequest.Completed = true;
-                curUploadRequest.Status = true;
-                curUploadRequest.StatusMsg = &quot;Success&quot;;
-			} 
-			else 
-			{
-                curUploadRequest.Completed = true;
-                curUploadRequest.Status = false;
-                curUploadRequest.StatusMsg = &quot;Server returned failed&quot;;
-			}
+            curUploadRequest.UploadComplete(reply.AssetBlock.UUID, reply.AssetBlock.Success);
 		}
 
         private void RequestXferCallbackHandler(Packet packet, Simulator simulator)
 		{
-            if (DEBUG_PACKETS) { Console.WriteLine(packet); }
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
+
             RequestXferPacket reply = (RequestXferPacket)packet;
 
             ulong XferID   = reply.XferID.ID;
-			LLUUID AssetID = reply.XferID.VFileID;
+			// LLUUID AssetID = reply.XferID.VFileID; //Not used...
 
-            // Setup to send the first packet
-            curUploadRequest.LastPacketNumSent = 0;
-
-			byte[] packetData = new byte[1004];
-
-            // Prefix the first Xfer packet with the data length
-            // FIXME: Apply endianness patch
-            Array.Copy(BitConverter.GetBytes((int)curUploadRequest.AssetData.Length), 0, packetData, 0, 4);
-            Array.Copy(curUploadRequest.AssetData, 0, packetData, 4, 1000);
-
-            packet = AssetPacketHelpers.SendXferPacket(XferID, packetData, 0);
-			slClient.Network.SendPacket(packet);
-            if (DEBUG_PACKETS) { Console.WriteLine(packet); }
+            curUploadRequest.RequestXfer(XferID);
         }
 
         private void ConfirmXferPacketCallbackHandler(Packet packet, Simulator simulator)
         {
-            if (DEBUG_PACKETS) { Console.WriteLine(packet); }
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
+
             ConfirmXferPacketPacket reply = (ConfirmXferPacketPacket)packet;
 
-            ulong XferID = reply.XferID.ID;
-            uint PacketNumConfirmed = reply.XferID.Packet;
-
-            if (PacketNumConfirmed == curUploadRequest.LastPacketNumSent)
-            {
-                curUploadRequest.LastPacketNumSent += 1;
-
-                uint i = curUploadRequest.LastPacketNumSent;
-                int numPackets = curUploadRequest.AssetData.Length / 1000;
-
-                if (i &lt; numPackets)
-                {
-                    byte[] packetData = new byte[1000];
-                    Array.Copy(curUploadRequest.AssetData, i * 1000, packetData, 0, 1000);
-
-                    packet = AssetPacketHelpers.SendXferPacket(XferID, packetData, i);
-                    slClient.Network.SendPacket(packet);
-                    if (DEBUG_PACKETS) { Console.WriteLine(packet); }
-                }
-                else
-                {
-                    // The last packet has to be handled slightly differently
-                    int lastLen = curUploadRequest.AssetData.Length - (numPackets * 1000);
-                    byte[] packetData = new byte[lastLen];
-                    Array.Copy(curUploadRequest.AssetData, numPackets * 1000, packetData, 0, lastLen);
-
-                    uint lastPacket = (uint)int.MaxValue + (uint)numPackets + (uint)1;
-                    packet = AssetPacketHelpers.SendXferPacket(XferID, packetData, lastPacket);
-                    slClient.Network.SendPacket(packet);
-                    if (DEBUG_PACKETS) { Console.WriteLine(packet); }
-                }
-            } else {
-                throw new Exception(&quot;Something is wrong with uploading assets, a confirmation came in for a packet we didn't send.&quot;);
-            }
+            curUploadRequest.ConfirmXferPacket(reply.XferID.ID, reply.XferID.Packet);
         }
 
+
         private void TransferInfoCallbackHandler(Packet packet, Simulator simulator)
         {
-            if (DEBUG_PACKETS) { Console.WriteLine(packet); }
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
+
             TransferInfoPacket reply = (TransferInfoPacket)packet;
 
             LLUUID TransferID = reply.TransferInfo.TransferID;
@@ -285,8 +221,8 @@
             int Status = reply.TransferInfo.Status;
 
             // Lookup the request for this packet
-            TransferRequest tr = (TransferRequest)htDownloadRequests[TransferID];
-            if (tr == null)
+            AssetRequestDownload request = htDownloadRequests[TransferID];
+            if (request == null)
             {
                 return;
             }
@@ -294,24 +230,26 @@
             // Mark it as either not found or update the request information
             if (Status == -2)
             {
-                tr.Completed = true;
-                tr.Status = false;
-                tr.StatusMsg = &quot;Asset Status -2 :: Likely Status Not Found&quot;;
+                request.Status = false;
+                request.StatusMsg = &quot;Asset Status -2 :: Likely Status Not Found&quot;;
 
-                tr.Size = 1;
-                tr.AssetData = new byte[1];
-
+                request.Size = 0;
+                request.AssetData = new byte[0];
+                request.Completed.Set();
             }
             else
             {
-                tr.Size = Size;
-                tr.AssetData = new byte[Size];
+                request.Size = Size;
+                request.AssetData = new byte[Size];
             }
         }
 
         private void TransferPacketCallbackHandler(Packet packet, Simulator simulator)
         {
-            if (DEBUG_PACKETS) { Console.WriteLine(packet); }
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
+
             TransferPacketPacket reply = (TransferPacketPacket)packet;
 
             LLUUID TransferID = reply.TransferData.TransferID;
@@ -319,19 +257,23 @@
 
 
             // Append data to data received.
-            TransferRequest tr = (TransferRequest)htDownloadRequests[TransferID];
-            if (tr == null)
+            AssetRequestDownload request = htDownloadRequests[TransferID];
+            if (request == null)
             {
                 return;
             }
 
-            Array.Copy(Data, 0, tr.AssetData, tr.Received, Data.Length);
-            tr.Received += Data.Length;
-
-            // If we've gotten all the data, mark it completed.
-            if (tr.Received &gt;= tr.Size)
+            lock (request)
             {
-                tr.Completed = true;
+                Array.Copy(Data, 0, request.AssetData, request.Received, Data.Length);
+                request.Received += Data.Length;
+
+                // If we've gotten all the data, mark it completed.
+                if (request.Received &gt;= request.Size)
+                {
+                    Console.WriteLine(&quot;Download Complete&quot;);
+                    request.Completed.Set();
+                }
             }
         }
 	}

Modified: branches/aditi/libsecondlife-cs/AssetSystem/AssetPacketHelpers.cs
===================================================================
--- branches/aditi/libsecondlife-cs/AssetSystem/AssetPacketHelpers.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/AssetSystem/AssetPacketHelpers.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -37,13 +37,15 @@
 	/// &lt;/summary&gt;
     public class AssetPacketHelpers
 	{
+        private const bool DEBUG_PACKETS = true;
+
         /// &lt;summary&gt;
         /// Upload a small asset where the entire asset will fit in a single packet (less then 500 bytes)
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;asset&quot;&gt;&lt;/param&gt;
         public static Packet AssetUploadRequest(Asset asset, LLUUID TransactionID)
 		{
-            if (asset.AssetData.Length &gt; 500)
+            if (asset.AssetData.Length &gt; 1000)
             {
                 throw new Exception(&quot;Asset too large to use AssetUploadRequest, use AssetUploadRequestHaderOnly() instead.&quot;);
             }
@@ -111,6 +113,11 @@
         /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt;
         public static Packet TransferRequest(LLUUID SessionID, LLUUID AgentID, LLUUID TransferID, InventoryItem item)
 		{
+            if (item.Asset.Type != 7)
+            {
+                Console.WriteLine(&quot;Warning: TransferRequest may not work for items other then notecards of type 7&quot;);
+            }
+
 			byte[] param = new byte[100];
 			int pos = 0;
 
@@ -145,5 +152,30 @@
             return p;
         }
 
+        public static Packet TransferRequest4BodyShape(LLUUID SessionID, LLUUID AgentID, LLUUID TransferID, Asset asset)
+        {
+            if (asset.Type != 13)
+            {
+                Console.WriteLine(&quot;Warning: TransferRequest4BodyShape may not work for items of types other then 13&quot;);
+            }
+
+            byte[] param = new byte[20];
+            int pos = 0;
+
+            Array.Copy(asset.AssetID.Data, 0, param, pos, 16);
+            pos += 16;
+
+            param[pos] = (byte)asset.Type;
+            pos += 1;
+
+
+            TransferRequestPacket p = new TransferRequestPacket();
+            p.TransferInfo.TransferID = TransferID;
+            p.TransferInfo.Params = param;
+            p.TransferInfo.ChannelType = 2;
+            p.TransferInfo.SourceType = 2;
+            p.TransferInfo.Priority = (float)101.0;
+            return p;
+        }
 	}
 }

Copied: branches/aditi/libsecondlife-cs/AssetSystem/AssetRequestDownload.cs (from rev 649, trunk/libsecondlife-cs/AssetSystem/AssetRequestDownload.cs)

Copied: branches/aditi/libsecondlife-cs/AssetSystem/AssetRequestUpload.cs (from rev 649, trunk/libsecondlife-cs/AssetSystem/AssetRequestUpload.cs)

Copied: branches/aditi/libsecondlife-cs/AssetSystem/BodyPart.cs (from rev 649, trunk/libsecondlife-cs/AssetSystem/BodyPart.cs)

Copied: branches/aditi/libsecondlife-cs/AssetSystem/BodyShape (from rev 649, trunk/libsecondlife-cs/AssetSystem/BodyShape)

Deleted: branches/aditi/libsecondlife-cs/AssetSystem/FastImageTool.cs
===================================================================
--- branches/aditi/libsecondlife-cs/AssetSystem/FastImageTool.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/AssetSystem/FastImageTool.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,280 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-//See FastImageApp for an example! :)
-//Please excuse my mess :/
-using System;
-using System.Collections;
-using System.Text;
-using libsecondlife;
-using libsecondlife.Packets;
-
-namespace libsecondlife.AssetSystem.FastImageTool
-{
-    public delegate void ImageFinishedCallback(LLUUID id, byte[] data); //this delegate is called when an image completed.
-
-    public class Image
-    {
-        public static void debug(string message)
-        {
-            //Console.WriteLine(&quot;FIT:IMAGE DEBUG -&gt; &quot; + message);
-        }
-
-        public LLUUID image_key = new LLUUID();
-        public byte[] data = null; //raw image data 
-        public bool[] packet_progress = null; //stores true/false depending on if the packet was recieved or not.
-
-        public int datapacket_length = 0;
-        private ImageFinishedCallback image_finished_callback;
-        public uint assetdata_length = 0;
-        public ushort packets_expected = 0;
-        public bool is_working = false;
-        public bool is_done = false;
-        public bool recieved_data_packet = false;
-        public int ticks_since_last_reply = 0;
-
-        public Image(LLUUID image, ImageFinishedCallback datahandler)
-        {
-            if (datahandler != null) image_finished_callback = datahandler;
-            else throw new Exception(&quot;ImageFinished callback is incorrect!&quot;);
-            debug(&quot;Image class defined for &quot; + image);
-            ticks_since_last_reply = Environment.TickCount;
-            image_key = image;
-
-        }
-        private bool IsAllDone()
-        {
-            foreach (bool status in packet_progress)
-            {
-                if (status == false) return false;
-            }
-            return true;
-        }
-        public int PacketNeeded()
-        {
-            if (packet_progress == null) return 0; //we didnt recieve the first packet yet!
-            for (int x = 0; x &lt; packet_progress.Length; ++x)
-            {
-                if (packet_progress[x] == false) return x;
-            }
-            return -1;
-        }
-        public void Update(Packet p)
-        {
-            if (is_done) return;
-
-            is_working = true;
-            if (p.Type == PacketType.ImageData)
-            {
-                ImageDataPacket reply = (ImageDataPacket)p;
-
-                if (reply.ImageID.ID != image_key) return; //this should never be met, but a justincase
-
-                datapacket_length = reply.ImageData.Data.Length;
-                assetdata_length = reply.ImageID.Size;
-                packets_expected = reply.ImageID.Packets;
-
-                data = new byte[assetdata_length];
-                packet_progress = new bool[packets_expected];
-
-                packet_progress[0] = true; //set the first packet to true, since we get it in the initial datapacket
-                Array.Copy(reply.ImageData.Data, 0, data, 0, datapacket_length);
-
-                recieved_data_packet = true;
-                debug(&quot;recieved imagedata packet ( &quot; + image_key + &quot; )&quot;);
-            }
-            else if (p.Type == PacketType.ImagePacket)
-            {
-                ImagePacketPacket reply = (ImagePacketPacket)p;
-
-                if (recieved_data_packet == false) return; //ignore image packet if it was premature.
-
-                if (reply.ImageID.ID != image_key) return; //one again, should never be met..
-
-                long packet_id = Convert.ToInt64(reply.ImageID.Packet);
-                Array.Copy(reply.ImageData.Data, 0, data, datapacket_length + (1000 * (packet_id - 1)), reply.ImageData.Data.Length);
-                if (packet_id &lt; 0 || packet_id &gt; packets_expected) throw new Exception(&quot;Uhm, something went wrong - packet was out of bounds (&quot; + image_key + &quot; - &quot; + packet_id + &quot;)&quot;);
-                packet_progress[packet_id] = true;
-                //debug(&quot;recieved imagepacket packet ( &quot; + image_key + &quot; #&quot; + reply.ImageID.Packet + &quot;)&quot;);
-            }
-            else
-            {
-                is_working = false;
-                throw new Exception(&quot;Invalid packet passed through Image class&quot;);
-            }
-
-            if (IsAllDone())
-            {
-                is_done = true;
-                image_finished_callback(image_key, data);
-            }
-
-            ticks_since_last_reply = Environment.TickCount;
-            is_working = false;
-        }
-    }
-
-    public class ImageManager
-    {
-        public static void debug(string message)
-        {
-            //Console.WriteLine(&quot;FIT:IMAGEMANAGER DEBUG -&gt; &quot; + message);
-        }
-
-        public SecondLife client;
-        private ImageFinishedCallback image_finished_callback;
-        public Hashtable images = new Hashtable();
-
-        public ImageManager(SecondLife slclient, ImageFinishedCallback datahandler)
-        {
-            if (datahandler != null) image_finished_callback = datahandler;
-            else throw new Exception(&quot;ImageFinished callback is incorrect!&quot;);
-            client = slclient;
-
-            client.Network.RegisterCallback(PacketType.ImageNotInDatabase, new PacketCallback(ImagePacketHandler));
-            client.Network.RegisterCallback(PacketType.ImageData, new PacketCallback(ImagePacketHandler));
-            client.Network.RegisterCallback(PacketType.ImagePacket, new PacketCallback(ImagePacketHandler));
-        }
-
-        public bool Exists(LLUUID image)
-        {
-            if (images[image] == null) return false;
-            else return true;
-        }
-        public void Add(LLUUID image)
-        {
-            if (!Exists(image)) images.Add(image, new Image(image, new ImageFinishedCallback(ImageProcessor))); //lots of images! :D
-        }
-        public void Remove(LLUUID image)
-        {
-            if (Exists(image)) images.Remove(image);
-        }
-
-        private void ImageProcessor(LLUUID id, byte[] thedata)
-        {
-            //this function processes the data from a completed data
-            //through the defined delagate when this class was created
-            //and then removes it for memory preservation! :)
-
-            image_finished_callback(id, thedata);
-            if (images[id] != null) this.Remove(id);
-            debug(&quot;Removed &quot; + id + &quot; from the imagemanager&quot;);
-        }
-
-        private void ImagePacketHandler(Packet bundle, Simulator region)
-        {
-            if (bundle.Type == PacketType.ImageData)
-            {
-                LLUUID id = ((ImageDataPacket)bundle).ImageID.ID;
-                if (images[id] != null) ((Image)(images[id])).Update(bundle);
-                else return;
-            }
-            else if (bundle.Type == PacketType.ImagePacket)
-            {
-                LLUUID id = ((ImagePacketPacket)bundle).ImageID.ID;
-                if (images[id] != null) ((Image)(images[id])).Update(bundle);
-                else return;
-            }
-            else if (bundle.Type == PacketType.ImageNotInDatabase)
-            {
-                ImageNotInDatabasePacket reply = (ImageNotInDatabasePacket)bundle;
-                if (images[reply.ImageID] != null) images.Remove(reply.ImageID);
-                else return;
-            }
-        }
-
-        public void Update()
-        {
-            Hashtable ims = new Hashtable();
-            try
-            {
-                foreach (DictionaryEntry ent in images)
-                {
-                    Image tmp = (Image)ent.Value;
-                    int pkt_needed = tmp.PacketNeeded();
-                    if (!tmp.is_done &amp;&amp; !tmp.is_working &amp;&amp; (tmp.ticks_since_last_reply &lt; (Environment.TickCount - 500)) &amp;&amp; pkt_needed != -1)
-                    {
-                        ims.Add((LLUUID)ent.Key, tmp.PacketNeeded());
-                    }
-                }
-            }
-            catch
-            {
-                return;
-            }
-            if (ims.Count == 0) return; //no images to update at this time, go ahead and exit.
-            RequestImagePacket rip = new RequestImagePacket();
-
-
-            //go ahead and do the silly security stuff in this packet
-            rip.AgentData.AgentID = client.Network.AgentID;
-            rip.AgentData.SessionID = client.Network.SessionID;
-
-            int argh = ims.Count;
-            if (argh &gt; 15) argh = 15;
-            rip.RequestImage = new RequestImagePacket.RequestImageBlock[argh];
-
-            int a = 0; //our counter in the next foreach loop.
-            try
-            {
-                foreach (DictionaryEntry ent in ims)
-                {
-                    if (a &lt; 15)
-                    {
-                        rip.RequestImage[a] = new RequestImagePacket.RequestImageBlock();
-                        rip.RequestImage[a].DiscardLevel = 0;
-                        rip.RequestImage[a].DownloadPriority = 1210000; //not sure what to set this as..
-                        rip.RequestImage[a].Image = new LLUUID(ent.Key.ToString());
-                        rip.RequestImage[a].Packet = Convert.ToUInt32(ent.Value);
-                        rip.RequestImage[a].Type = 0; //again, not sure what it is.
-                        ++a; //increment a
-                    }
-
-                }
-            }
-            catch
-            {
-                //shh...
-                return;
-            }
-
-            client.Network.SendPacket((Packet)rip, client.Network.CurrentSim);
-            debug(&quot;Sent packet! &quot; + argh + &quot; image requests sent this time..&quot;);
-        }
-
-        public bool AllImagesDone()
-        {
-            foreach (Image im in images.Values)
-            {
-                if (im.is_done == false) return false;
-            }
-            return true;
-        }
-
-
-    }
-}

Modified: branches/aditi/libsecondlife-cs/AssetSystem/ImageManager.cs
===================================================================
--- branches/aditi/libsecondlife-cs/AssetSystem/ImageManager.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/AssetSystem/ImageManager.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -24,8 +24,13 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+//#define DEBUG_PACKETS
+
+
 using System;
 using System.Collections.Generic;
+using System.IO;
+using System.Threading;
 
 using libsecondlife;
 using libsecondlife.Packets;
@@ -34,20 +39,33 @@
 
 namespace libsecondlife.AssetSystem
 {
-	/// &lt;summary&gt;
+    public delegate void ImageRetrievedCallback(LLUUID id, byte[] data, bool cached, string statusmsg); //this delegate is called when an image completed.
+
+    /// &lt;summary&gt;
 	/// Manages the uploading and downloading of Images from SecondLife
 	/// &lt;/summary&gt;
 	public class ImageManager
 	{
-		private SecondLife slClient;
 
+        private SecondLife slClient;
+
+        public enum CacheTypes {None, Memory, Disk};
+        private CacheTypes CacheType;
+        private string CacheDirectory = &quot;ImageCache&quot;;
+        private Dictionary&lt;LLUUID, Byte[]&gt; CacheTable = new Dictionary&lt;LLUUID, byte[]&gt;();
+        private List&lt;LLUUID&gt; CachedDiskIndex = new List&lt;LLUUID&gt;();
+
         private ImagePacketHelpers ImagePacketHelper;
 
 		private Dictionary&lt;LLUUID, TransferRequest&gt; htDownloadRequests = new Dictionary&lt;LLUUID,TransferRequest&gt;();
 
+        public ImageRetrievedCallback OnImageRetrieved;
+
 		private class TransferRequest
 		{
-			public bool Completed;
+            public ManualResetEvent ReceivedHeaderPacket = new ManualResetEvent(false);
+            public ManualResetEvent Completed = new ManualResetEvent(false);
+
 			public bool Status;
 			public string StatusMsg;
 
@@ -60,8 +78,6 @@
 
 			public TransferRequest()
 			{
-				Completed = false;
-
 				Status		= false;
 				StatusMsg	= &quot;&quot;;
 
@@ -75,43 +91,198 @@
         /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
         public ImageManager(SecondLife client)
 		{
-			slClient = client;
+            Init(client, CacheTypes.None, null);
+        }
 
-            ImagePacketHelper = new ImagePacketHelpers(client.Network.AgentID, client.Network.SessionID);
+        /// &lt;summary&gt;
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;ctype&quot;&gt;The type of Cache system to use for images.&lt;/param&gt;
+        public ImageManager(SecondLife client, CacheTypes ctype)
+        {
+            Init(client, ctype, null);
+        }
 
-			PacketCallback ImageDataCallback = new PacketCallback(ImageDataCallbackHandler);
-			slClient.Network.RegisterCallback(PacketType.ImageData, ImageDataCallback);
+        /// &lt;summary&gt;
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;ctype&quot;&gt;The type of Cache system to use for images.&lt;/param&gt;
+        /// &lt;param name=&quot;directory&quot;&gt;The directory to use for disk based caching.&lt;/param&gt;
+        public ImageManager(SecondLife client, CacheTypes ctype, String directory)
+        {
+            Init(client, ctype, directory);
+        }
 
-            PacketCallback ImagePacketCallback = new PacketCallback(ImagePacketCallbackHandler);
-            slClient.Network.RegisterCallback(PacketType.ImagePacket, ImagePacketCallback);
+        /// &lt;summary&gt;
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;ctype&quot;&gt;The type of Cache system to use for images.&lt;/param&gt;
+        /// &lt;param name=&quot;directory&quot;&gt;The directory to use for disk based caching.&lt;/param&gt;
+        private void Init(SecondLife client, CacheTypes ctype, string directory)
+        {
+            slClient = client;
 
-            PacketCallback ImageNotInDatabaseCallback = new PacketCallback(ImageNotInDatabaseCallbackHandler);
-            slClient.Network.RegisterCallback(PacketType.ImageNotInDatabase, ImageNotInDatabaseCallback);
+            // Setup Image Caching
+            CacheType = ctype;
+            if (ctype == CacheTypes.Disk)
+            {
+                if (directory != null)
+                {
+                    CacheDirectory = directory;
+                }
+
+                try
+                {
+                    if (!Directory.Exists(CacheDirectory))
+                    {
+                        Directory.CreateDirectory(CacheDirectory);
+                    }
+                }
+                catch (Exception e)
+                {
+                    Console.WriteLine(&quot;ERROR: Disk Cache directory could not be established, defaulting to Memory Cache.&quot;);
+                    Console.WriteLine(e.Message);
+
+                    CacheType = CacheTypes.Memory;
+                }
+
+            }
+
+            // Image Packet Helpers
+            ImagePacketHelper = new ImagePacketHelpers(client);
+
+            // Image Callbacks
+            slClient.Network.RegisterCallback(PacketType.ImageData, new NetworkManager.PacketCallback(ImageDataCallbackHandler));
+            slClient.Network.RegisterCallback(PacketType.ImagePacket, new NetworkManager.PacketCallback(ImagePacketCallbackHandler));
+            slClient.Network.RegisterCallback(PacketType.ImageNotInDatabase, new NetworkManager.PacketCallback(ImageNotInDatabaseCallbackHandler));
         }
 
+        private void CacheImage(LLUUID ImageID, byte[] ImageData)
+        {
+            switch (CacheType)
+            {
+                case CacheTypes.Memory:
+                    CacheTable[ImageID] = ImageData;
+                    break;
+                case CacheTypes.Disk:
+                    String filepath = Path.Combine(CacheDirectory, ImageID.ToStringHyphenated());
+                    File.WriteAllBytes(filepath, ImageData);
+                    CachedDiskIndex.Add(ImageID);
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        private byte[] CachedImage(LLUUID ImageID)
+        {
+            switch (CacheType)
+            {
+                case CacheTypes.Memory:
+                    if (CacheTable.ContainsKey(ImageID))
+                    {
+                        return CacheTable[ImageID];
+                    }
+                    else
+                    {
+                        return null;
+                    }
+                case CacheTypes.Disk:
+                    String filepath = Path.Combine(CacheDirectory, ImageID.ToStringHyphenated());
+                    if (File.Exists(filepath))
+                    {
+                        return File.ReadAllBytes(filepath);
+                    }
+                    else
+                    {
+                        return null;
+                    }
+
+                default:
+                    return null;
+            }
+        }
+
+        public bool isCachedImage(LLUUID ImageID)
+        {
+            if (ImageID == null)
+            {
+                throw new Exception(&quot;Don't go calling isCachedImage() with a null...&quot;);
+            }
+
+            switch (CacheType)
+            {
+                case CacheTypes.Memory:
+                    return CacheTable.ContainsKey(ImageID);
+                case CacheTypes.Disk:
+                    if (CachedDiskIndex.Contains(ImageID))
+                    {
+                        return true;
+                    }
+                    else
+                    {
+                        String filepath = Path.Combine(CacheDirectory, ImageID.ToStringHyphenated());
+                        if (File.Exists(filepath))
+                        {
+                            CachedDiskIndex.Add(ImageID);
+                            return true;
+                        }
+                        else
+                        {
+                            return false;
+                        }
+                    }
+                default:
+                    return false;
+            }
+        }
+
+        public bool isDownloadingImages()
+        {
+            bool isDownloading = false;
+            lock (htDownloadRequests)
+            {
+                isDownloading = htDownloadRequests.Count &gt; 0 ? true : false;
+            }
+            return isDownloading;
+        }
+
         /// &lt;summary&gt;
         /// Requests an image from SecondLife and blocks until it's received.
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;ImageID&quot;&gt;The Image's AssetID&lt;/param&gt;
         public byte[] RequestImage(LLUUID ImageID)
 		{
-			TransferRequest tr = new TransferRequest();
-			tr.Completed  = false;
-			tr.Size		  = int.MaxValue; // Number of bytes expected
-			tr.Received   = 0; // Number of bytes received
-			tr.LastPacket = Helpers.GetUnixTime(); // last time we recevied a packet for this request
+            byte[] imgData = CachedImage(ImageID);
+            if (imgData != null)
+            {
+                return imgData;
+            }
 
-			htDownloadRequests[ImageID] = tr;
+            TransferRequest tr;
+            lock (htDownloadRequests)
+            {
+                if (htDownloadRequests.ContainsKey(ImageID) == false)
+                {
+                    tr = new TransferRequest();
+                    tr.Size = int.MaxValue; // Number of bytes expected
+                    tr.Received = 0; // Number of bytes received
+                    tr.LastPacket = Helpers.GetUnixTime(); // last time we recevied a packet for this request
 
-            Packet packet = ImagePacketHelper.RequestImage(ImageID);
-			slClient.Network.SendPacket(packet);
-            Console.WriteLine(packet);
+                    htDownloadRequests[ImageID] = tr;
 
-			while( tr.Completed == false )
-			{
-				slClient.Tick();
-			}
+                    Packet packet = ImagePacketHelper.RequestImage(ImageID);
+                    slClient.Network.SendPacket(packet);
+                }
+                else
+                {
+                    tr = htDownloadRequests[ImageID];
+                }
+            }
 
+            // Wait for transfer to complete.
+            tr.Completed.WaitOne();
+
 			if( tr.Status == true )
 			{
 				return tr.AssetData;
@@ -120,10 +291,43 @@
 			{
 				throw new Exception( &quot;RequestImage: &quot; + tr.StatusMsg );
 			}
-
 		}
 
+        /// &lt;summary&gt;
+        /// Requests an image from SecondLife.
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;ImageID&quot;&gt;The Image's AssetID&lt;/param&gt;
+        public void RequestImageAsync(LLUUID ImageID)
+        {
+            if (ImageID == null)
+            {
+                throw new Exception(&quot;WTF!!!  Don't request Image Assets by passing in an ImageID of null&quot;);
+            }
 
+            byte[] imgData = CachedImage(ImageID);
+            if (imgData != null)
+            {
+                FireImageRetrieved(ImageID, imgData, true);
+            }
+
+            lock (htDownloadRequests)
+            {
+                if (htDownloadRequests.ContainsKey(ImageID) == false)
+                {
+                    TransferRequest tr = new TransferRequest();
+                    tr.Size = int.MaxValue; // Number of bytes expected
+                    tr.Received = 0; // Number of bytes received
+                    tr.LastPacket = Helpers.GetUnixTime(); // last time we recevied a packet for this request
+
+                    htDownloadRequests[ImageID] = tr;
+
+                    Packet packet = ImagePacketHelper.RequestImage(ImageID);
+                    slClient.Network.SendPacket(packet);
+                }
+            }
+        }
+
+
         /// &lt;summary&gt;
         /// Handles the Image Data packet, which includes the ID, and Size of the image, 
         /// along with the first block of data for the image.  If the image is small enough
@@ -133,7 +337,10 @@
         /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
         public void ImageDataCallbackHandler(Packet packet, Simulator simulator)
 		{
-            Console.WriteLine(packet);
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
+
             ImageDataPacket reply = (ImageDataPacket)packet;
 
 			LLUUID ImageID = reply.ImageID.ID;
@@ -142,12 +349,19 @@
 			byte[] Data    = reply.ImageData.Data;
 
             // Lookup the request that this packet is for
-			TransferRequest tr = (TransferRequest)htDownloadRequests[ImageID];
-			if( tr == null )
-			{
-                // Received a packet for an image we didn't request...
-				return;
-			}
+            TransferRequest tr;
+            lock (htDownloadRequests)
+            {
+                try
+                {
+                    tr = htDownloadRequests[ImageID];
+                }
+                catch (Exception)
+                {
+                    // Received a packet for an image we didn't request...
+                    return;
+                }
+            }
 
             // Initialize the request so that it's data buffer is the right size for the image
 			tr.Size = Size;
@@ -158,11 +372,18 @@
 			Array.Copy(Data, 0, tr.AssetData, tr.Received, Data.Length);
 			tr.Received += (uint)Data.Length;
 
+            // Mark that the TransferRequest has received this header packet
+            tr.ReceivedHeaderPacket.Set();
+
 			// If we've gotten all the data, mark it completed.
 			if( tr.Received &gt;= tr.Size )
 			{
-				tr.Completed = true;
 				tr.Status	 = true;
+                tr.Completed.Set();
+
+                // Fire off image downloaded event
+                CacheImage(ImageID, tr.AssetData);
+                FireImageRetrieved(ImageID, tr.AssetData, false);
 			}
 		}
 
@@ -173,12 +394,20 @@
         /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
         public void ImagePacketCallbackHandler(Packet packet, Simulator simulator)
 		{
-            Console.WriteLine(packet);
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
+
             ImagePacketPacket reply = (ImagePacketPacket)packet;
             
+            LLUUID ImageID = reply.ImageID.ID;
 
             // Lookup the request for this packet
-			TransferRequest tr = (TransferRequest)htDownloadRequests[reply.ImageID.ID];
+            TransferRequest tr;
+            lock (htDownloadRequests)
+            {
+                tr = (TransferRequest)htDownloadRequests[ImageID];
+            }
 			if( tr == null )
 			{
                 // Received a packet that doesn't belong to any requests in our queue, strange...
@@ -190,7 +419,12 @@
             // then once we've received all data packets, it should be re-assembled into a complete array and marked
             // completed.
 
+            // FIXME: Sometimes this gets called before ImageDataCallbackHandler, when that
+            // happens tr.AssetData will be null.  Implimenting the above TODO should fix this.
 
+            // Wait until we've received the header packet for this image, which creates the AssetData array
+            tr.ReceivedHeaderPacket.WaitOne();
+
             // Add this packet's data to the request.
             Array.Copy(reply.ImageData.Data, 0, tr.AssetData, tr.BaseDataReceived + (1000 * (reply.ImageID.Packet - 1)), reply.ImageData.Data.Length);
             tr.Received += (uint)reply.ImageData.Data.Length;
@@ -198,8 +432,12 @@
 			// If we've gotten all the data, mark it completed.
 			if( tr.Received &gt;= tr.Size )
 			{
-				tr.Completed = true;
-				tr.Status	 = true;
+                tr.Status = true;
+                tr.Completed.Set();
+
+                // Fire off image downloaded event
+                CacheImage(ImageID, tr.AssetData);
+                FireImageRetrieved(ImageID, tr.AssetData, false);
 			}		
 		}
 
@@ -208,7 +446,46 @@
         /// &lt;/summary&gt;
         public void ImageNotInDatabaseCallbackHandler(Packet packet, Simulator simulator)
         {
-            Console.WriteLine(packet);
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
+
+            ImageNotInDatabasePacket reply = (ImageNotInDatabasePacket)packet;
+
+            LLUUID ImageID = reply.ImageID.ID;
+
+            // Lookup the request for this packet
+			TransferRequest tr;
+            lock (htDownloadRequests)
+            {
+                tr = (TransferRequest)htDownloadRequests[ImageID];
+            }
+			if( tr == null )
+			{
+                // Received a packet that doesn't belong to any requests in our queue, strange...
+				return;
+			}
+
+            tr.Status = false;
+            tr.StatusMsg = &quot;Image not in database&quot;;
+            tr.Completed.Set();
+
+            // Fire off image downloaded event
+            FireImageRetrieved(ImageID, null, false, tr.StatusMsg);
         }
+
+        private void FireImageRetrieved(LLUUID ImageID, byte[] ImageData, bool cached)
+        {
+            FireImageRetrieved(ImageID, ImageData, cached, &quot;&quot;);
+        }
+
+        private void FireImageRetrieved(LLUUID ImageID, byte[] ImageData, bool cached, string status)
+        {
+            if (OnImageRetrieved != null)
+            {
+                OnImageRetrieved(ImageID, ImageData, cached, status);
+            }
+        }
+
     }
 }
\ No newline at end of file

Modified: branches/aditi/libsecondlife-cs/AssetSystem/ImagePacketHelpers.cs
===================================================================
--- branches/aditi/libsecondlife-cs/AssetSystem/ImagePacketHelpers.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/AssetSystem/ImagePacketHelpers.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -37,13 +37,11 @@
 	/// &lt;/summary&gt;
     public class ImagePacketHelpers
 	{
-        private LLUUID AgentID;
-        private LLUUID SessionID;
+        private SecondLife Client;
 
-        public ImagePacketHelpers(LLUUID AgentID, LLUUID SessionID)
+        public ImagePacketHelpers(SecondLife client)
 		{
-            this.AgentID   = AgentID;
-            this.SessionID = SessionID;
+            this.Client   = client;
 		}
 
 
@@ -63,11 +61,10 @@
             p.RequestImage[0].Image            = imageID;
 
             //FIXME: Find out what the appropriate values are here.
-            Console.WriteLine(&quot;Don't know what the valid value should be for Type in RequestImage&quot;);
             p.RequestImage[0].Type             = 0;
 
-            p.AgentData.AgentID = AgentID;
-            p.AgentData.SessionID = SessionID;
+            p.AgentData.AgentID   = Client.Network.AgentID;
+            p.AgentData.SessionID = Client.Network.SessionID;
 
             return p;
 		}

Modified: branches/aditi/libsecondlife-cs/Avatar.cs
===================================================================
--- branches/aditi/libsecondlife-cs/Avatar.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/Avatar.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -42,7 +42,7 @@
     /// &lt;param name=&quot;FromName&quot;&gt;&lt;/param&gt;
     /// &lt;param name=&quot;ID&quot;&gt;&lt;/param&gt;
     public delegate void ChatCallback(string message, byte audible, byte type, byte sourcetype,
-        string fromName, LLUUID id);
+        string fromName, LLUUID id, LLUUID ownerid, LLVector3 position);
 
     /// &lt;summary&gt;
     /// Triggered when the L$ account balance for this avatar changes
@@ -68,7 +68,7 @@
     /// &lt;param name=&quot;binaryBucket&quot;&gt;&lt;/param&gt;
     public delegate void InstantMessageCallback(LLUUID fromAgentID, string fromAgentName, 
         LLUUID toAgentID, uint parentEstateID, LLUUID regionID, LLVector3 position, 
-        bool dialog, bool groupIM, LLUUID imSessionID, DateTime timestamp, string message, 
+        byte dialog, bool groupIM, LLUUID imSessionID, DateTime timestamp, string message, 
         byte offline, byte[] binaryBucket);
 
     /// &lt;summary&gt;
@@ -89,11 +89,91 @@
         Finished
     }
 
+    public enum InstantMessageDialog
+    {
+        RequestTeleport = 22,
+        AcceptTeleport = 23,
+        DenyTeleport = 24
+    }
+
     /// &lt;summary&gt;
     /// Basic class to hold other Avatar's data.
     /// &lt;/summary&gt;
     public class Avatar
     {
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        [Flags]
+        public enum AgentUpdateFlags
+        {
+            /// &lt;summary&gt;Move Forward (SL Keybinding: W/Up Arrow)&lt;/summary&gt;
+            AGENT_CONTROL_AT_POS = 0x1 &lt;&lt; CONTROL_AT_POS_INDEX,
+            /// &lt;summary&gt;Move Backward (SL Keybinding: S/Down Arrow)&lt;/summary&gt;
+            AGENT_CONTROL_AT_NEG = 0x1 &lt;&lt; CONTROL_AT_NEG_INDEX,
+            /// &lt;summary&gt;Move Left (SL Keybinding: Shift-(A/Left Arrow))&lt;/summary&gt;
+            AGENT_CONTROL_LEFT_POS = 0x1 &lt;&lt; CONTROL_LEFT_POS_INDEX,
+            /// &lt;summary&gt;Move Right (SL Keybinding: Shift-(D/Right Arrow))&lt;/summary&gt;
+            AGENT_CONTROL_LEFT_NEG = 0x1 &lt;&lt; CONTROL_LEFT_NEG_INDEX,
+            /// &lt;summary&gt;Not Flying: Jump/Flying: Move Up (SL Keybinding: E)&lt;/summary&gt;
+            AGENT_CONTROL_UP_POS = 0x1 &lt;&lt; CONTROL_UP_POS_INDEX,
+            /// &lt;summary&gt;Not Flying: Croutch/Flying: Move Down (SL Keybinding: C)&lt;/summary&gt;
+            AGENT_CONTROL_UP_NEG = 0x1 &lt;&lt; CONTROL_UP_NEG_INDEX,
+            /// &lt;summary&gt;Unused&lt;/summary&gt;
+            AGENT_CONTROL_PITCH_POS = 0x1 &lt;&lt; CONTROL_PITCH_POS_INDEX,
+            /// &lt;summary&gt;Unused&lt;/summary&gt;
+            AGENT_CONTROL_PITCH_NEG = 0x1 &lt;&lt; CONTROL_PITCH_NEG_INDEX,
+            /// &lt;summary&gt;Unused&lt;/summary&gt;
+            AGENT_CONTROL_YAW_POS = 0x1 &lt;&lt; CONTROL_YAW_POS_INDEX,
+            /// &lt;summary&gt;Unused&lt;/summary&gt;
+            AGENT_CONTROL_YAW_NEG = 0x1 &lt;&lt; CONTROL_YAW_NEG_INDEX,
+            /// &lt;summary&gt;ORed with AGENT_CONTROL_AT_* if the keyboard is being used&lt;/summary&gt;
+            AGENT_CONTROL_FAST_AT = 0x1 &lt;&lt; CONTROL_FAST_AT_INDEX,
+            /// &lt;summary&gt;ORed with AGENT_CONTROL_LEFT_* if the keyboard is being used&lt;/summary&gt;
+            AGENT_CONTROL_FAST_LEFT = 0x1 &lt;&lt; CONTROL_FAST_LEFT_INDEX,
+            /// &lt;summary&gt;ORed with AGENT_CONTROL_UP_* if the keyboard is being used&lt;/summary&gt;
+            AGENT_CONTROL_FAST_UP = 0x1 &lt;&lt; CONTROL_FAST_UP_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_FLY = 0x1 &lt;&lt; CONTROL_FLY_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_STOP = 0x1 &lt;&lt; CONTROL_STOP_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_FINISH_ANIM = 0x1 &lt;&lt; CONTROL_FINISH_ANIM_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_STAND_UP = 0x1 &lt;&lt; CONTROL_STAND_UP_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_SIT_ON_GROUND = 0x1 &lt;&lt; CONTROL_SIT_ON_GROUND_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_MOUSELOOK = 0x1 &lt;&lt; CONTROL_MOUSELOOK_INDEX,
+            /// &lt;summary&gt;Legacy, used if a key was pressed for less than a certain amount of time&lt;/summary&gt;
+            AGENT_CONTROL_NUDGE_AT_POS = 0x1 &lt;&lt; CONTROL_NUDGE_AT_POS_INDEX,
+            /// &lt;summary&gt;Legacy, used if a key was pressed for less than a certain amount of time&lt;/summary&gt;
+            AGENT_CONTROL_NUDGE_AT_NEG = 0x1 &lt;&lt; CONTROL_NUDGE_AT_NEG_INDEX,
+            /// &lt;summary&gt;Legacy, used if a key was pressed for less than a certain amount of time&lt;/summary&gt;
+            AGENT_CONTROL_NUDGE_LEFT_POS = 0x1 &lt;&lt; CONTROL_NUDGE_LEFT_POS_INDEX,
+            /// &lt;summary&gt;Legacy, used if a key was pressed for less than a certain amount of time&lt;/summary&gt;
+            AGENT_CONTROL_NUDGE_LEFT_NEG = 0x1 &lt;&lt; CONTROL_NUDGE_LEFT_NEG_INDEX,
+            /// &lt;summary&gt;Legacy, used if a key was pressed for less than a certain amount of time&lt;/summary&gt;
+            AGENT_CONTROL_NUDGE_UP_POS = 0x1 &lt;&lt; CONTROL_NUDGE_UP_POS_INDEX,
+            /// &lt;summary&gt;Legacy, used if a key was pressed for less than a certain amount of time&lt;/summary&gt;
+            AGENT_CONTROL_NUDGE_UP_NEG = 0x1 &lt;&lt; CONTROL_NUDGE_UP_NEG_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_TURN_LEFT = 0x1 &lt;&lt; CONTROL_TURN_LEFT_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_TURN_RIGHT = 0x1 &lt;&lt; CONTROL_TURN_RIGHT_INDEX,
+            /// &lt;summary&gt;Set when the avatar is idled or set to away. Note that the away animation is 
+            /// activated separately from setting this flag&lt;/summary&gt;
+            AGENT_CONTROL_AWAY = 0x1 &lt;&lt; CONTROL_AWAY_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_LBUTTON_DOWN = 0x1 &lt;&lt; CONTROL_LBUTTON_DOWN_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_LBUTTON_UP = 0x1 &lt;&lt; CONTROL_LBUTTON_UP_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_ML_LBUTTON_DOWN = 0x1 &lt;&lt; CONTROL_ML_LBUTTON_DOWN_INDEX,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AGENT_CONTROL_ML_LBUTTON_UP = 0x1 &lt;&lt; CONTROL_ML_LBUTTON_UP_INDEX
+        }
+
         /// &lt;summary&gt;The Avatar's UUID, asset server&lt;/summary&gt;
         public LLUUID ID;
         /// &lt;summary&gt;Avatar ID in Region (sim) it is in&lt;/summary&gt;
@@ -110,44 +190,82 @@
         public LLQuaternion Rotation;
         /// &lt;summary&gt;Region (aka sim) the Avatar is in&lt;/summary&gt;
         public Region CurrentRegion;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public string BornOn;
-        
+        /// &lt;summary&gt;&lt;/summary&gt;
         public LLUUID ProfileImage;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public LLUUID PartnerID;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public string AboutText;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public uint WantToMask;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public string WantToText;
-        
+        /// &lt;summary&gt;&lt;/summary&gt;
         public uint SkillsMask;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public string SkillsText;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public string FirstLifeText;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public LLUUID FirstLifeImage;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public bool Identified;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public bool Transacted;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public bool AllowPublish;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public bool MaturePublish;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public string CharterMember;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public float Behavior;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public float Appearance;
-
+        /// &lt;summary&gt;&lt;/summary&gt;
         public float Building;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public string LanguagesText;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public TextureEntry Textures;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public string ProfileURL;
 
-        public string LanguagesText;
+        protected const int CONTROL_AT_POS_INDEX = 0;
+        protected const int CONTROL_AT_NEG_INDEX = 1;
+        protected const int CONTROL_LEFT_POS_INDEX = 2;
+        protected const int CONTROL_LEFT_NEG_INDEX = 3;
+        protected const int CONTROL_UP_POS_INDEX = 4;
+        protected const int CONTROL_UP_NEG_INDEX = 5;
+        protected const int CONTROL_PITCH_POS_INDEX = 6;
+        protected const int CONTROL_PITCH_NEG_INDEX = 7;
+        protected const int CONTROL_YAW_POS_INDEX = 8;
+        protected const int CONTROL_YAW_NEG_INDEX = 9;
+        protected const int CONTROL_FAST_AT_INDEX = 10;
+        protected const int CONTROL_FAST_LEFT_INDEX = 11;
+        protected const int CONTROL_FAST_UP_INDEX = 12;
+        protected const int CONTROL_FLY_INDEX = 13;
+        protected const int CONTROL_STOP_INDEX = 14;
+        protected const int CONTROL_FINISH_ANIM_INDEX = 15;
+        protected const int CONTROL_STAND_UP_INDEX = 16;
+        protected const int CONTROL_SIT_ON_GROUND_INDEX = 17;
+        protected const int CONTROL_MOUSELOOK_INDEX = 18;
+        protected const int CONTROL_NUDGE_AT_POS_INDEX = 19;
+        protected const int CONTROL_NUDGE_AT_NEG_INDEX = 20;
+        protected const int CONTROL_NUDGE_LEFT_POS_INDEX = 21;
+        protected const int CONTROL_NUDGE_LEFT_NEG_INDEX = 22;
+        protected const int CONTROL_NUDGE_UP_POS_INDEX = 23;
+        protected const int CONTROL_NUDGE_UP_NEG_INDEX = 24;
+        protected const int CONTROL_TURN_LEFT_INDEX = 25;
+        protected const int CONTROL_TURN_RIGHT_INDEX = 26;
+        protected const int CONTROL_AWAY_INDEX = 27;
+        protected const int CONTROL_LBUTTON_DOWN_INDEX = 28;
+        protected const int CONTROL_LBUTTON_UP_INDEX = 29;
+        protected const int CONTROL_ML_LBUTTON_DOWN_INDEX = 30;
+        protected const int CONTROL_ML_LBUTTON_UP_INDEX = 31;
+        protected const int TOTAL_CONTROLS = 32;
     }
 
     /// &lt;summary&gt;
@@ -165,27 +283,27 @@
         public event BalanceCallback OnBalanceUpdated;
 
         /// &lt;summary&gt;Your (client) Avatar UUID, asset server&lt;/summary&gt;
-        public LLUUID ID;
+        public LLUUID ID = LLUUID.Zero;
         /// &lt;summary&gt;Your (client) Avatar ID, local to Region/sim&lt;/summary&gt;
         public uint LocalID;
         /// &lt;summary&gt;Avatar First Name (i.e. Philip)&lt;/summary&gt;
-        public string FirstName;
+        public string FirstName = &quot;&quot;;
         /// &lt;summary&gt;Avatar Last Name (i.e. Linden)&lt;/summary&gt;
-        public string LastName;
+        public string LastName = &quot;&quot;;
         /// &lt;summary&gt;&lt;/summary&gt;
         public string TeleportMessage;
         /// &lt;summary&gt;Current position of avatar&lt;/summary&gt;
-        public LLVector3 Position;
+        public LLVector3 Position = LLVector3.Zero;
         /// &lt;summary&gt;Current rotation of avatar&lt;/summary&gt;
-        public LLQuaternion Rotation;
+        public LLQuaternion Rotation = LLQuaternion.Identity;
         /// &lt;summary&gt;The point the avatar is currently looking at
         /// (may not stay updated)&lt;/summary&gt;
-        public LLVector3 LookAt;
+        public LLVector3 LookAt = LLVector3.Zero;
         /// &lt;summary&gt;Position avatar client will goto when login to 'home' or during
         /// teleport request to 'home' region.&lt;/summary&gt;
-        public LLVector3 HomePosition;
+        public LLVector3 HomePosition = LLVector3.Zero;
         /// &lt;summary&gt;LookAt point saved/restored with HomePosition&lt;/summary&gt;
-        public LLVector3 HomeLookAt;
+        public LLVector3 HomeLookAt = LLVector3.Zero;
         /// &lt;summary&gt;Gets the health of the agent&lt;/summary&gt;
         protected float health;
         public float Health
@@ -212,42 +330,38 @@
         /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
         public MainAvatar(SecondLife client)
         {
-            PacketCallback callback;
+            NetworkManager.PacketCallback callback;
             Client = client;
             TeleportMessage = &quot;&quot;;
 
-            // Create emtpy vectors for now
-            HomeLookAt = HomePosition = Position = LookAt = new LLVector3();
-            Rotation = new LLQuaternion();
-
             // Coarse location callback
-            Client.Network.RegisterCallback(PacketType.CoarseLocationUpdate, new PacketCallback(CoarseLocationHandler));
+            Client.Network.RegisterCallback(PacketType.CoarseLocationUpdate, new NetworkManager.PacketCallback(CoarseLocationHandler));
 
             // Teleport callbacks
-            callback = new PacketCallback(TeleportHandler);
+            callback = new NetworkManager.PacketCallback(TeleportHandler);
             Client.Network.RegisterCallback(PacketType.TeleportStart, callback);
             Client.Network.RegisterCallback(PacketType.TeleportProgress, callback);
             Client.Network.RegisterCallback(PacketType.TeleportFailed, callback);
             Client.Network.RegisterCallback(PacketType.TeleportFinish, callback);
 
             // Instant Message callback
-            Client.Network.RegisterCallback(PacketType.ImprovedInstantMessage, new PacketCallback(InstantMessageHandler));
+            Client.Network.RegisterCallback(PacketType.ImprovedInstantMessage, new NetworkManager.PacketCallback(InstantMessageHandler));
 
             // Chat callback
-            Client.Network.RegisterCallback(PacketType.ChatFromSimulator, new PacketCallback(ChatHandler));
+            Client.Network.RegisterCallback(PacketType.ChatFromSimulator, new NetworkManager.PacketCallback(ChatHandler));
 
             TeleportTimer = new Timer(18000);
             TeleportTimer.Elapsed += new ElapsedEventHandler(TeleportTimerEvent);
             TeleportTimeout = false;
 
             // Movement complete callback
-            Client.Network.RegisterCallback(PacketType.AgentMovementComplete, new PacketCallback(MovementCompleteHandler));
+            Client.Network.RegisterCallback(PacketType.AgentMovementComplete, new NetworkManager.PacketCallback(MovementCompleteHandler));
 
             // Health callback
-            Client.Network.RegisterCallback(PacketType.HealthMessage, new PacketCallback(HealthHandler));
+            Client.Network.RegisterCallback(PacketType.HealthMessage, new NetworkManager.PacketCallback(HealthHandler));
 
             // Money callbacks
-            callback = new PacketCallback(BalanceHandler);
+            callback = new NetworkManager.PacketCallback(BalanceHandler);
             Client.Network.RegisterCallback(PacketType.MoneyBalanceReply, callback);
             Client.Network.RegisterCallback(PacketType.MoneySummaryReply, callback);
             Client.Network.RegisterCallback(PacketType.AdjustBalance, callback);
@@ -327,9 +441,9 @@
             }
 
             // These fields are mandatory, even if we don't have valid values for them
-            im.MessageBlock.Position = new LLVector3();
+            im.MessageBlock.Position = LLVector3.Zero;
                 //TODO: Allow region id to be correctly set by caller or fetched from Client.*
-            im.MessageBlock.RegionID = new LLUUID(); 
+            im.MessageBlock.RegionID = LLUUID.Zero; 
 
 
             // Send the message
@@ -402,10 +516,23 @@
         public void GiveMoney(LLUUID target, int amount, string description)
         {
             // 5001 - transaction type for av to av money transfers
+            
             GiveMoney(target, amount, description, 5001);
         }
 
         /// &lt;summary&gt;
+        /// Toggle running on or off
+        /// &lt;/summary&gt;
+        public void SetAlwaysRun(bool running)
+        {
+            SetAlwaysRunPacket run = new SetAlwaysRunPacket();
+            run.AgentData.AgentID = Client.Network.AgentID;
+            run.AgentData.SessionID = Client.Network.SessionID;
+            run.AgentData.AlwaysRun = running;
+            Client.Network.SendPacket(run);
+        }
+
+        /// &lt;summary&gt;
         /// Give Money to destionation Object or Avatar
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;target&quot;&gt;UUID of the Target Object/Avatar&lt;/param&gt;
@@ -422,11 +549,85 @@
             money.MoneyData.DestID = target;
             money.MoneyData.SourceID = this.ID;
             money.MoneyData.TransactionType = transactiontype;
+            money.MoneyData.AggregatePermInventory = 0; //TODO: whats this?
+            money.MoneyData.AggregatePermNextOwner = 0; //TODO: whats this?
+            money.MoneyData.Flags = 0; //TODO: whats this?
+            money.MoneyData.Amount = amount;
 
             Client.Network.SendPacket((Packet)money);
         }
 
         /// &lt;summary&gt;
+        /// Send an AgentAnimation packet that will toggle animations on or off
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;animations&quot;&gt;A list of animation UUIDs, and whether to
+        /// turn that animation on or off&lt;/param&gt;
+        public void Animate(Dictionary&lt;LLUUID, bool&gt; animations)
+        {
+            AgentAnimationPacket animate = new AgentAnimationPacket();
+
+            animate.AgentData.AgentID = Client.Network.AgentID;
+            animate.AgentData.SessionID = Client.Network.SessionID;
+            animate.AnimationList = new AgentAnimationPacket.AnimationListBlock[animations.Count];
+            int i = 0;
+
+            foreach (KeyValuePair&lt;LLUUID, bool&gt; animation in animations)
+            {
+                animate.AnimationList[i] = new AgentAnimationPacket.AnimationListBlock();
+                animate.AnimationList[i].AnimID = animation.Key;
+                animate.AnimationList[i].StartAnim = animation.Value;
+
+                i++;
+            }
+
+            Client.Network.SendPacket(animate);
+        }
+
+        /// &lt;summary&gt;
+        /// Use the autopilot sim function to move the avatar to a new position
+        /// &lt;/summary&gt;
+        /// &lt;remarks&gt;The z value is currently not handled properly by the simulator&lt;/remarks&gt;
+        /// &lt;param name=&quot;globalX&quot;&gt;Integer value for the global X coordinate to move to&lt;/param&gt;
+        /// &lt;param name=&quot;globalY&quot;&gt;Integer value for the global Y coordinate to move to&lt;/param&gt;
+        /// &lt;param name=&quot;z&quot;&gt;Floating-point value for the Z coordinate to move to&lt;/param&gt;
+        /// &lt;example&gt;AutoPilot(252620, 247078, 20.2674);&lt;/example&gt;
+        public void AutoPilot(ulong globalX, ulong globalY, float z)
+        {
+            GenericMessagePacket autopilot = new GenericMessagePacket();
+
+            autopilot.AgentData.AgentID = Client.Network.AgentID;
+            autopilot.AgentData.SessionID = Client.Network.SessionID;
+            autopilot.MethodData.Invoice = LLUUID.Zero;
+            autopilot.MethodData.Method = Helpers.StringToField(&quot;autopilot&quot;);
+            autopilot.ParamList = new GenericMessagePacket.ParamListBlock[3];
+            autopilot.ParamList[0] = new GenericMessagePacket.ParamListBlock();
+            autopilot.ParamList[0].Parameter = Helpers.StringToField(globalX.ToString());
+            autopilot.ParamList[1] = new GenericMessagePacket.ParamListBlock();
+            autopilot.ParamList[1].Parameter = Helpers.StringToField(globalY.ToString());
+            autopilot.ParamList[2] = new GenericMessagePacket.ParamListBlock();
+            // TODO: Do we need to prevent z coordinates from being sent in 1.4827e-18 notation?
+            autopilot.ParamList[2].Parameter = Helpers.StringToField(z.ToString());
+
+            Client.Network.SendPacket(autopilot);
+        }
+
+        /// &lt;summary&gt;
+        /// Use the autopilot sim function to move the avatar to a new position
+        /// &lt;/summary&gt;
+        /// &lt;remarks&gt;The z value is currently not handled properly by the simulator&lt;/remarks&gt;
+        /// &lt;param name=&quot;localX&quot;&gt;Integer value for the local X coordinate to move to&lt;/param&gt;
+        /// &lt;param name=&quot;localY&quot;&gt;Integer value for the local Y coordinate to move to&lt;/param&gt;
+        /// &lt;param name=&quot;z&quot;&gt;Floating-point value for the Z coordinate to move to&lt;/param&gt;
+        /// &lt;example&gt;AutoPilot(252620, 247078, 20.2674);&lt;/example&gt;
+        public void AutoPilotLocal(int localX, int localY, float z)
+        {
+            GridRegion gr = Client.Network.CurrentSim.Region.GridRegionData;
+            ulong GridCornerX = ((ulong)gr.X * (ulong)256) + (ulong)localX;
+            ulong GridCornerY = ((ulong)gr.Y * (ulong)256) + (ulong)localY;
+            AutoPilot(GridCornerX, GridCornerY, z);
+        }
+
+        /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
@@ -528,7 +729,7 @@
         /// &lt;returns&gt;&lt;/returns&gt;
         public bool Teleport(string simName, LLVector3 position)
         {
-            position.Z = 0;
+            //position.Z = 0; //why was this here?
             return Teleport(simName, position, new LLVector3(0, 1.0F, 0));
         }
 
@@ -566,7 +767,7 @@
                     {
                         // Request the region info again
                         Client.Grid.AddSim(simName);
-
+                        
                         System.Threading.Thread.Sleep(1000);
                     }
                 }
@@ -583,6 +784,104 @@
         }
 
         /// &lt;summary&gt;
+        /// Respond to a teleport lure by either accepting it and initiating 
+        /// the teleport, or denying it
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;requesterID&quot;&gt;UUID of the avatar requesting the teleport&lt;/param&gt;
+        /// &lt;param name=&quot;accept&quot;&gt;Accept the teleport request or deny it&lt;/param&gt;
+        public void TeleportLureRespond(LLUUID requesterID, bool accept)
+        {
+            ImprovedInstantMessagePacket im = new ImprovedInstantMessagePacket();
+
+            im.AgentData.AgentID = Client.Network.AgentID;
+            im.AgentData.SessionID = Client.Network.SessionID;
+            im.MessageBlock.BinaryBucket = new byte[0];
+            im.MessageBlock.FromAgentName = Helpers.StringToField(this.FirstName + &quot; &quot; + this.LastName);
+            im.MessageBlock.FromGroup = false;
+            im.MessageBlock.ID = Client.Network.AgentID;
+            im.MessageBlock.Message = new byte[0];
+            im.MessageBlock.Offline = 0;
+            im.MessageBlock.ParentEstateID = 0;
+            im.MessageBlock.Position = this.Position;
+            im.MessageBlock.RegionID = LLUUID.Zero;
+            im.MessageBlock.Timestamp = 0;
+            im.MessageBlock.ToAgentID = requesterID;
+
+            if (accept)
+            {
+                im.MessageBlock.Dialog = (byte)InstantMessageDialog.AcceptTeleport;
+                
+                Client.Network.SendPacket(im);
+
+                TeleportLureRequestPacket lure = new TeleportLureRequestPacket();
+
+                lure.Info.AgentID = Client.Network.AgentID;
+                lure.Info.SessionID = Client.Network.SessionID;
+                lure.Info.LureID = Client.Network.AgentID;
+                lure.Info.TeleportFlags = 4; // TODO: What does this mean?
+
+                Client.Network.SendPacket(lure);
+            }
+            else
+            {
+                im.MessageBlock.Dialog = (byte)InstantMessageDialog.DenyTeleport;
+
+                Client.Network.SendPacket(im);
+            }
+        }
+
+        /// &lt;summary&gt;
+        /// Grabs an object
+        /// &lt;/summary&gt;
+        public void Grab(uint objectLocalID)
+        {
+            ObjectGrabPacket grab = new ObjectGrabPacket();
+            grab.AgentData.AgentID = Client.Network.AgentID;
+            grab.AgentData.SessionID = Client.Network.SessionID;
+            grab.ObjectData.LocalID = objectLocalID;
+            grab.ObjectData.GrabOffset = new LLVector3(0, 0, 0);
+            Client.Network.SendPacket(grab);
+        }
+
+        /// &lt;summary&gt;
+        /// Drags on an object
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;objectID&quot;&gt;Strangely, LLUID instead of local ID&lt;/param&gt;
+        /// &lt;param name=&quot;grabPosition&quot;&gt;Drag target in region coordinates&lt;/param&gt;
+        public void GrabUpdate(LLUUID objectID, LLVector3 grabPosition)
+        {
+            ObjectGrabUpdatePacket grab = new ObjectGrabUpdatePacket();
+            grab.AgentData.AgentID = Client.Network.AgentID;
+            grab.AgentData.SessionID = Client.Network.SessionID;
+            grab.ObjectData.ObjectID = objectID;
+            grab.ObjectData.GrabOffsetInitial = new LLVector3(0, 0, 0);
+            grab.ObjectData.GrabPosition = grabPosition;
+            grab.ObjectData.TimeSinceLast = 0;
+            Client.Network.SendPacket(grab);
+        }
+
+        /// &lt;summary&gt;
+        /// Releases a grabbed object
+        /// &lt;/summary&gt;
+        public void DeGrab(uint objectLocalID)
+        {
+            ObjectDeGrabPacket degrab = new ObjectDeGrabPacket();
+            degrab.AgentData.AgentID = Client.Network.AgentID;
+            degrab.AgentData.SessionID = Client.Network.SessionID;
+            degrab.ObjectData.LocalID = objectLocalID;
+            Client.Network.SendPacket(degrab);
+        }
+
+        /// &lt;summary&gt;
+        /// Touches an object
+        /// &lt;/summary&gt;
+        public void Touch(uint objectLocalID)
+        {
+            Client.Self.Grab(objectLocalID);
+            Client.Self.DeGrab(objectLocalID);
+        }
+
+        /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
@@ -601,21 +900,23 @@
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;reliable&quot;&gt;&lt;/param&gt;
-        public void UpdateCamera(bool reliable)
+        public void UpdateCamera(Avatar.AgentUpdateFlags controlFlags, LLVector3 position, LLVector3 forwardAxis,
+            LLVector3 leftAxis, LLVector3 upAxis, LLQuaternion bodyRotation, LLQuaternion headRotation, float farClip,
+            bool reliable)
         {
             AgentUpdatePacket update = new AgentUpdatePacket();
             update.AgentData.AgentID = Client.Network.AgentID;
             update.AgentData.SessionID = Client.Network.SessionID;
             update.AgentData.State = 0;
-            update.AgentData.BodyRotation = new LLQuaternion(0, 0.6519076f, 0, 0);
-            update.AgentData.HeadRotation = new LLQuaternion();
             // Semi-sane default values
-            update.AgentData.CameraCenter = new LLVector3(9.549901f, 7.033957f, 11.75f);
-            update.AgentData.CameraAtAxis = new LLVector3(0.7f, 0.7f, 0);
-            update.AgentData.CameraLeftAxis = new LLVector3(-0.7f, 0.7f, 0);
-            update.AgentData.CameraUpAxis = new LLVector3(0.1822026f, 0.9828722f, 0);
-            update.AgentData.Far = 384;
-            update.AgentData.ControlFlags = 0; // TODO: What is this?
+            update.AgentData.BodyRotation = bodyRotation; //new LLQuaternion(0, 0.6519076f, 0, 0);
+            update.AgentData.HeadRotation = headRotation; //LLQuaternion.Identity;
+            update.AgentData.CameraCenter = position; //new LLVector3(9.549901f, 7.033957f, 11.75f);
+            update.AgentData.CameraAtAxis = forwardAxis; //new LLVector3(0.7f, 0.7f, 0);
+            update.AgentData.CameraLeftAxis = leftAxis; //new LLVector3(-0.7f, 0.7f, 0);
+            update.AgentData.CameraUpAxis = upAxis; //new LLVector3(0.1822026f, 0.9828722f, 0);
+            update.AgentData.Far = farClip;
+            update.AgentData.ControlFlags = (uint)controlFlags;
             update.AgentData.Flags = 0;
             update.Header.Reliable = reliable;
 
@@ -663,7 +964,7 @@
                         , im.MessageBlock.ParentEstateID
                         , im.MessageBlock.RegionID
                         , im.MessageBlock.Position
-                        , Convert.ToBoolean(im.MessageBlock.Dialog)
+                        , im.MessageBlock.Dialog
                         , im.MessageBlock.FromGroup
                         , im.MessageBlock.ID
                         , new DateTime(im.MessageBlock.Timestamp)
@@ -689,8 +990,15 @@
 
                 if (OnChat != null)
                 {
-                    OnChat(Helpers.FieldToString(chat.ChatData.Message), chat.ChatData.Audible, chat.ChatData.ChatType, 
-                        chat.ChatData.SourceType, Helpers.FieldToString(chat.ChatData.FromName), chat.ChatData.SourceID);
+                    OnChat(Helpers.FieldToString(chat.ChatData.Message)
+                            , chat.ChatData.Audible
+                            , chat.ChatData.ChatType
+                            , chat.ChatData.SourceType
+                            , Helpers.FieldToString(chat.ChatData.FromName)
+                            , chat.ChatData.SourceID
+                            , chat.ChatData.OwnerID
+                            , chat.ChatData.Position
+                            );
                 }
             }
         }
@@ -753,6 +1061,8 @@
         {
             if (packet.Type == PacketType.TeleportStart)
             {
+                Client.DebugLog(&quot;TeleportStart received from &quot; + simulator.ToString());
+
                 TeleportMessage = &quot;Teleport started&quot;;
                 TeleportStat = TeleportStatus.Start;
 
@@ -763,6 +1073,8 @@
             }
             else if (packet.Type == PacketType.TeleportProgress)
             {
+                Client.DebugLog(&quot;TeleportProgress received from &quot; + simulator.ToString());
+
                 TeleportMessage = Helpers.FieldToString(((TeleportProgressPacket)packet).Info.Message);
                 TeleportStat = TeleportStatus.Progress;
 
@@ -773,6 +1085,8 @@
             }
             else if (packet.Type == PacketType.TeleportFailed)
             {
+                Client.DebugLog(&quot;TeleportFailed received from &quot; + simulator.ToString());
+
                 TeleportMessage = Helpers.FieldToString(((TeleportFailedPacket)packet).Info.Reason);
                 TeleportStat = TeleportStatus.Failed;
 
@@ -785,32 +1099,28 @@
             }
             else if (packet.Type == PacketType.TeleportFinish)
             {
+                Client.DebugLog(&quot;TeleportFinish received from &quot; + simulator.ToString());
+
                 TeleportFinishPacket finish = (TeleportFinishPacket)packet;
 
                 // Connect to the new sim
                 Simulator sim = Client.Network.Connect(new IPAddress((long)finish.Info.SimIP), finish.Info.SimPort, 
                     simulator.CircuitCode, true);
                 
-                if ( sim != null)
+                if (sim != null)
                 {
                     TeleportMessage = &quot;Teleport finished&quot;;
                     TeleportStat = TeleportStatus.Finished;
 
                     // Move the avatar in to the new sim
                     CompleteAgentMovementPacket move = new CompleteAgentMovementPacket();
-
                     move.AgentData.AgentID = Client.Network.AgentID;
                     move.AgentData.SessionID = Client.Network.SessionID;
                     move.AgentData.CircuitCode = simulator.CircuitCode;
+                    Client.Network.SendPacket(move, sim);
 
-                    Client.Network.SendPacket((Packet)move);
+                    Client.Log(&quot;Moved to new sim &quot; + sim.ToString(), Helpers.LogLevel.Info);
 
-                    Client.DebugLog(move.ToString());
-
-                    Client.Log(&quot;Moved to new sim &quot; + Client.Network.CurrentSim.Region.Name + &quot;(&quot; + 
-                        Client.Network.CurrentSim.IPEndPoint.ToString() + &quot;)&quot;,
-                        Helpers.LogLevel.Info);
-
                     if (OnBeginTeleport != null)
                     {
                         OnBeginTeleport(TeleportMessage, TeleportStat);
@@ -818,6 +1128,7 @@
                     else
                     {
                         // Sleep a little while so we can collect parcel information
+                        // FIXME: This doesn't belong in libsecondlife
                         System.Threading.Thread.Sleep(1000);
                     }
                 }

Modified: branches/aditi/libsecondlife-cs/AvatarManager.cs
===================================================================
--- branches/aditi/libsecondlife-cs/AvatarManager.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/AvatarManager.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -32,26 +32,42 @@
 namespace libsecondlife
 {
     /// &lt;summary&gt;
-    /// Triggered after friend request packet is sent out
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;AgentID&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;Online&quot;&gt;&lt;/param&gt;
-    public delegate void FriendNotificationCallback(LLUUID agentID, bool online);
-
-    /// &lt;summary&gt;
-    /// Triggered when a UUIDNameReply is received
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;names&quot;&gt;&lt;/param&gt;
-    public delegate void AgentNamesCallback(Dictionary&lt;LLUUID, string&gt; names);
-    public delegate void AvatarPropertiesCallback(Avatar avatar);
-    public delegate void AvatarNameCallback(Avatar avatar);
-    public delegate void AvatarStatisticsCallback(Avatar avatar);
-    public delegate void AvatarIntrestsCallback(Avatar avatar);
-    /// &lt;summary&gt;
     /// 
     /// &lt;/summary&gt;
     public class AvatarManager
     {
+        /// &lt;summary&gt;
+        /// Triggered after friend request packet is sent out
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;AgentID&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;Online&quot;&gt;&lt;/param&gt;
+        public delegate void FriendNotificationCallback(LLUUID agentID, bool online);
+        /// &lt;summary&gt;
+        /// Triggered when a UUIDNameReply is received
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;names&quot;&gt;&lt;/param&gt;
+        public delegate void AgentNamesCallback(Dictionary&lt;LLUUID, string&gt; names);
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;avatar&quot;&gt;&lt;/param&gt;
+        public delegate void AvatarPropertiesCallback(Avatar avatar);
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;avatar&quot;&gt;&lt;/param&gt;
+        public delegate void AvatarNameCallback(Avatar avatar);
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;avatar&quot;&gt;&lt;/param&gt;
+        public delegate void AvatarStatisticsCallback(Avatar avatar);
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;avatar&quot;&gt;&lt;/param&gt;
+        public delegate void AvatarInterestsCallback(Avatar avatar);
+
         /// &lt;summary&gt;Triggered whenever a friend comes online or goes offline&lt;/summary&gt;
         public event FriendNotificationCallback OnFriendNotification;
 
@@ -60,7 +76,12 @@
         private AgentNamesCallback OnAgentNames;
         private Dictionary&lt;LLUUID, AvatarPropertiesCallback&gt; AvatarPropertiesCallbacks;
 	    private Dictionary&lt;LLUUID, AvatarStatisticsCallback&gt; AvatarStatisticsCallbacks;
-        private Dictionary&lt;LLUUID, AvatarIntrestsCallback&gt; AvatarIntrestsCallbacks;
+        private Dictionary&lt;LLUUID, AvatarInterestsCallback&gt; AvatarInterestsCallbacks;
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
         public AvatarManager(SecondLife client)
         {
             Client = client;
@@ -68,15 +89,15 @@
             //Callback Dictionaries
             AvatarPropertiesCallbacks = new Dictionary&lt;LLUUID, AvatarPropertiesCallback&gt;();
 	        AvatarStatisticsCallbacks = new Dictionary&lt;LLUUID, AvatarStatisticsCallback&gt;();
-            AvatarIntrestsCallbacks = new Dictionary&lt;LLUUID, AvatarIntrestsCallback&gt;();
+            AvatarInterestsCallbacks = new Dictionary&lt;LLUUID, AvatarInterestsCallback&gt;();
             // Friend notification callback
-            PacketCallback callback = new PacketCallback(FriendNotificationHandler);
+            NetworkManager.PacketCallback callback = new NetworkManager.PacketCallback(FriendNotificationHandler);
             Client.Network.RegisterCallback(PacketType.OnlineNotification, callback);
             Client.Network.RegisterCallback(PacketType.OfflineNotification, callback);
-            Client.Network.RegisterCallback(PacketType.UUIDNameReply, new PacketCallback(GetAgentNameHandler));
-            Client.Network.RegisterCallback(PacketType.AvatarPropertiesReply, new PacketCallback(AvatarPropertiesHandler));
-	        Client.Network.RegisterCallback(PacketType.AvatarStatisticsReply, new PacketCallback(AvatarStatisticsHandler));
-            Client.Network.RegisterCallback(PacketType.AvatarInterestsReply, new PacketCallback(AvatarIntrestsHandler));
+            Client.Network.RegisterCallback(PacketType.UUIDNameReply, new NetworkManager.PacketCallback(GetAgentNameHandler));
+            Client.Network.RegisterCallback(PacketType.AvatarPropertiesReply, new NetworkManager.PacketCallback(AvatarPropertiesHandler));
+            Client.Network.RegisterCallback(PacketType.AvatarStatisticsReply, new NetworkManager.PacketCallback(AvatarStatisticsHandler));
+            Client.Network.RegisterCallback(PacketType.AvatarInterestsReply, new NetworkManager.PacketCallback(AvatarInterestsHandler));
         }
               
 
@@ -92,12 +113,55 @@
             }
         }
 
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
         public bool Contains(LLUUID id)
         {
             return Avatars.ContainsKey(id);
         }
 
         /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt;
+        public void UpdateAvatar(Avatar a)
+        {
+            //Basic profile properties
+            AvatarPropertiesUpdatePacket apup = new AvatarPropertiesUpdatePacket();
+            AvatarPropertiesUpdatePacket.AgentDataBlock adb = new AvatarPropertiesUpdatePacket.AgentDataBlock();
+            adb.AgentID = a.ID;
+            adb.SessionID = Client.Network.SessionID;
+            apup.AgentData = adb;
+            AvatarPropertiesUpdatePacket.PropertiesDataBlock pdb = new AvatarPropertiesUpdatePacket.PropertiesDataBlock();
+            pdb.AllowPublish = a.AllowPublish;
+            pdb.FLAboutText = Helpers.StringToField(a.FirstLifeText);
+            pdb.FLImageID = a.FirstLifeImage;
+            pdb.ImageID = a.ProfileImage;
+            pdb.MaturePublish = a.MaturePublish;
+            pdb.ProfileURL = Helpers.StringToField(a.ProfileURL);
+            apup.PropertiesData = pdb;
+            //Intrests
+            AvatarInterestsUpdatePacket aiup = new AvatarInterestsUpdatePacket();
+            AvatarInterestsUpdatePacket.AgentDataBlock iadb = new AvatarInterestsUpdatePacket.AgentDataBlock();
+            iadb.AgentID = a.ID;
+            iadb.SessionID = Client.Network.SessionID;
+            aiup.AgentData = iadb;
+            AvatarInterestsUpdatePacket.PropertiesDataBlock ipdb = new AvatarInterestsUpdatePacket.PropertiesDataBlock();
+            ipdb.LanguagesText = Helpers.StringToField(a.LanguagesText);
+            ipdb.SkillsMask = a.SkillsMask;
+            ipdb.SkillsText = Helpers.StringToField(a.SkillsText);
+            ipdb.WantToMask = a.WantToMask;
+            ipdb.WantToText = Helpers.StringToField(a.WantToText);
+            aiup.PropertiesData = ipdb;
+            //Send packets
+            Client.Network.SendPacket(apup);
+            Client.Network.SendPacket(aiup);
+        }
+
+        /// &lt;summary&gt;
         /// This function will only check if the avatar name exists locally,
         /// it will not do any networking calls to fetch the name
         /// &lt;/summary&gt;
@@ -341,6 +405,7 @@
             av.MaturePublish = reply.PropertiesData.MaturePublish;
             av.Identified = reply.PropertiesData.Identified;
             av.Transacted = reply.PropertiesData.Transacted;
+            av.ProfileURL = Helpers.FieldToString(reply.PropertiesData.ProfileURL);
             //reassign in the cache
             Avatars[av.ID] = av;
             //Heaven forbid that we actually get a packet we didn't ask for.
@@ -349,12 +414,12 @@
             }
         }
 
-        public void BeginAvatarPropertiesRequest(LLUUID avatarid, AvatarPropertiesCallback apc, AvatarStatisticsCallback asc, AvatarIntrestsCallback aic)
+        public void BeginAvatarPropertiesRequest(LLUUID avatarid, AvatarPropertiesCallback apc, AvatarStatisticsCallback asc, AvatarInterestsCallback aic)
         {
             //Set teh callback!
             AvatarPropertiesCallbacks[avatarid] = apc;
 	        AvatarStatisticsCallbacks[avatarid] = asc;
-            AvatarIntrestsCallbacks[avatarid] = aic;
+            AvatarInterestsCallbacks[avatarid] = aic;
             //Oh noes
             //Packet construction, good times
             AvatarPropertiesRequestPacket aprp = new AvatarPropertiesRequestPacket();
@@ -367,7 +432,7 @@
             Client.Network.SendPacket(aprp);
         }
 
-        public void AvatarIntrestsHandler(Packet packet, Simulator simulator)
+        private void AvatarInterestsHandler(Packet packet, Simulator simulator)
         {
             AvatarInterestsReplyPacket airp = (AvatarInterestsReplyPacket)packet;
             Avatar av;
@@ -391,8 +456,8 @@
                 av.SkillsText = Helpers.FieldToString(airp.PropertiesData.SkillsText);
                 av.LanguagesText = Helpers.FieldToString(airp.PropertiesData.LanguagesText);
             }
-            if (AvatarIntrestsCallbacks.ContainsKey(airp.AgentData.AvatarID) &amp;&amp; AvatarIntrestsCallbacks[airp.AgentData.AvatarID] != null)
-                AvatarIntrestsCallbacks[airp.AgentData.AvatarID](av);
+            if (AvatarInterestsCallbacks.ContainsKey(airp.AgentData.AvatarID) &amp;&amp; AvatarInterestsCallbacks[airp.AgentData.AvatarID] != null)
+                AvatarInterestsCallbacks[airp.AgentData.AvatarID](av);
         }
     }
 }

Modified: branches/aditi/libsecondlife-cs/GridManager.cs
===================================================================
--- branches/aditi/libsecondlife-cs/GridManager.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/GridManager.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -66,6 +66,22 @@
 		public GridRegion() 
 		{
 		}
+
+        public override string ToString()
+        {
+            string output = &quot;GridRegion&quot;;
+            output += Environment.NewLine + &quot;Name: &quot; + Name;
+            output += Environment.NewLine + &quot;RegionHandle: &quot; + RegionHandle;
+            output += Environment.NewLine + &quot;X: &quot; + X;
+            output += Environment.NewLine + &quot;Y: &quot; + Y;
+            output += Environment.NewLine + &quot;MapImageID: &quot; + MapImageID;
+            output += Environment.NewLine + &quot;Access: &quot; + Access;
+            output += Environment.NewLine + &quot;RegionFlags: &quot; + RegionFlags;
+            output += Environment.NewLine + &quot;WaterHeight: &quot; + WaterHeight;
+            output += Environment.NewLine + &quot;Agents: &quot; + Agents;
+
+            return output;
+        }
 	}
 
 	/// &lt;summary&gt;
@@ -96,10 +112,10 @@
 		{
 			Client = client;
 			Regions = new Dictionary&lt;string, GridRegion&gt;();
-            SunDirection = new LLVector3();
+            SunDirection = LLVector3.Zero;
 
-			Client.Network.RegisterCallback(PacketType.MapBlockReply, new PacketCallback(MapBlockReplyHandler));
-            Client.Network.RegisterCallback(PacketType.SimulatorViewerTimeMessage, new PacketCallback(TimeMessageHandler));
+            Client.Network.RegisterCallback(PacketType.MapBlockReply, new NetworkManager.PacketCallback(MapBlockReplyHandler));
+            Client.Network.RegisterCallback(PacketType.SimulatorViewerTimeMessage, new NetworkManager.PacketCallback(TimeMessageHandler));
 		}
 
         /// &lt;summary&gt;

Modified: branches/aditi/libsecondlife-cs/GroupManager.cs
===================================================================
--- branches/aditi/libsecondlife-cs/GroupManager.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/GroupManager.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -144,7 +144,7 @@
         public Group(LLUUID id)
         {
             ID = id;
-            InsigniaID = new LLUUID();
+            InsigniaID = LLUUID.Zero;
         }
 
         /// &lt;summary&gt;
@@ -397,17 +397,17 @@
             GroupRolesCaches = new Dictionary&lt;LLUUID, Dictionary&lt;LLUUID, GroupRole&gt;&gt;();
             GroupRolesMembersCaches = new Dictionary&lt;LLUUID, List&lt;KeyValuePair&lt;LLUUID, LLUUID&gt;&gt;&gt;();
 
-            Client.Network.RegisterCallback(PacketType.AgentGroupDataUpdate, new PacketCallback(GroupDataHandler));
-            Client.Network.RegisterCallback(PacketType.GroupTitlesReply, new PacketCallback(GroupTitlesHandler));
-            Client.Network.RegisterCallback(PacketType.GroupProfileReply, new PacketCallback(GroupProfileHandler));
-            Client.Network.RegisterCallback(PacketType.GroupMembersReply, new PacketCallback(GroupMembersHandler));
-            Client.Network.RegisterCallback(PacketType.GroupRoleDataReply, new PacketCallback(GroupRoleDataHandler));
-            Client.Network.RegisterCallback(PacketType.GroupRoleMembersReply, new PacketCallback(GroupRoleMembersHandler));
-            Client.Network.RegisterCallback(PacketType.GroupActiveProposalItemReply, new PacketCallback(GroupActiveProposalItemHandler));
-            Client.Network.RegisterCallback(PacketType.GroupVoteHistoryItemReply, new PacketCallback(GroupVoteHistoryItemHandler));
-            Client.Network.RegisterCallback(PacketType.GroupAccountSummaryReply, new PacketCallback(GroupAccountSummaryHandler));
-            Client.Network.RegisterCallback(PacketType.GroupAccountDetailsReply, new PacketCallback(GroupAccountDetailsHandler));
-            Client.Network.RegisterCallback(PacketType.GroupAccountTransactionsReply, new PacketCallback(GroupAccountTransactionsHandler));
+            Client.Network.RegisterCallback(PacketType.AgentGroupDataUpdate, new NetworkManager.PacketCallback(GroupDataHandler));
+            Client.Network.RegisterCallback(PacketType.GroupTitlesReply, new NetworkManager.PacketCallback(GroupTitlesHandler));
+            Client.Network.RegisterCallback(PacketType.GroupProfileReply, new NetworkManager.PacketCallback(GroupProfileHandler));
+            Client.Network.RegisterCallback(PacketType.GroupMembersReply, new NetworkManager.PacketCallback(GroupMembersHandler));
+            Client.Network.RegisterCallback(PacketType.GroupRoleDataReply, new NetworkManager.PacketCallback(GroupRoleDataHandler));
+            Client.Network.RegisterCallback(PacketType.GroupRoleMembersReply, new NetworkManager.PacketCallback(GroupRoleMembersHandler));
+            Client.Network.RegisterCallback(PacketType.GroupActiveProposalItemReply, new NetworkManager.PacketCallback(GroupActiveProposalItemHandler));
+            Client.Network.RegisterCallback(PacketType.GroupVoteHistoryItemReply, new NetworkManager.PacketCallback(GroupVoteHistoryItemHandler));
+            Client.Network.RegisterCallback(PacketType.GroupAccountSummaryReply, new NetworkManager.PacketCallback(GroupAccountSummaryHandler));
+            Client.Network.RegisterCallback(PacketType.GroupAccountDetailsReply, new NetworkManager.PacketCallback(GroupAccountDetailsHandler));
+            Client.Network.RegisterCallback(PacketType.GroupAccountTransactionsReply, new NetworkManager.PacketCallback(GroupAccountTransactionsHandler));
         }
 
         /// &lt;summary&gt;

Copied: branches/aditi/libsecondlife-cs/Helpers.cs (from rev 649, trunk/libsecondlife-cs/Helpers.cs)

Modified: branches/aditi/libsecondlife-cs/InventorySystem/InventoryFolder.cs
===================================================================
--- branches/aditi/libsecondlife-cs/InventorySystem/InventoryFolder.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/InventorySystem/InventoryFolder.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -56,8 +56,8 @@
             : base(manager)
         {
             _Name = &quot;&quot;;
-            _FolderID = new LLUUID();
-            _ParentID = new LLUUID();
+            _FolderID = LLUUID.Zero;
+            _ParentID = LLUUID.Zero;
             _Type = -1;
         }
 

Modified: branches/aditi/libsecondlife-cs/InventorySystem/InventoryImage.cs
===================================================================
--- branches/aditi/libsecondlife-cs/InventorySystem/InventoryImage.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/InventorySystem/InventoryImage.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -21,7 +21,7 @@
 				} 
 				else 
 				{
-					if( (AssetID != null) &amp;&amp; (AssetID != new LLUUID()) )
+                    if ((AssetID != null) &amp;&amp; (AssetID != LLUUID.Zero))
 					{
 						base.iManager.AssetManager.GetInventoryAsset( this );
 						return ((AssetImage)Asset).J2CData;
@@ -55,6 +55,7 @@
 			}
 
 			this.iManager = manager;
+            this._ItemID = ii._ItemID;
 			this._Asset = ii._Asset;
 			this._AssetID = ii._AssetID;
 			this._BaseMask = ii._BaseMask;

Modified: branches/aditi/libsecondlife-cs/InventorySystem/InventoryItem.cs
===================================================================
--- branches/aditi/libsecondlife-cs/InventorySystem/InventoryItem.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/InventorySystem/InventoryItem.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -25,7 +25,7 @@
             }
         }
 
-        internal LLUUID _FolderID = new LLUUID();
+        internal LLUUID _FolderID = LLUUID.Zero;
         public LLUUID FolderID
         {
             get { return _FolderID; }
@@ -59,7 +59,10 @@
                     throw new Exception(&quot;You can not change an item's ID once it's been set.&quot;);
                 }
             }
-            get { return _ItemID; }
+            get 
+            {
+                return _ItemID; 
+            }
         }
 
         internal sbyte _InvType = 0;
@@ -102,13 +105,13 @@
         }
 
 
-        internal LLUUID _OwnerID = new LLUUID();
+        internal LLUUID _OwnerID = LLUUID.Zero;
         public LLUUID OwnerID
         {
             get { return _OwnerID; }
         }
 
-        internal LLUUID _CreatorID = new LLUUID();
+        internal LLUUID _CreatorID = LLUUID.Zero;
         public LLUUID CreatorID
         {
             get { return _CreatorID; }
@@ -125,7 +128,7 @@
                 }
                 else
                 {
-                    if ((AssetID != null) &amp;&amp; (AssetID != new LLUUID()))
+                    if ((AssetID != null) &amp;&amp; (AssetID != LLUUID.Zero))
                     {
                         base.iManager.AssetManager.GetInventoryAsset(this);
                         return Asset;
@@ -135,20 +138,20 @@
             }
         }
 
-        internal LLUUID _TransactionID = new LLUUID();
+        internal LLUUID _TransactionID = LLUUID.Zero;
         public LLUUID TransactionID
         {
             get { return _TransactionID; }
         }
 
-        internal LLUUID _AssetID = new LLUUID();
+        internal LLUUID _AssetID = LLUUID.Zero;
         public LLUUID AssetID
         {
             get { return _AssetID; }
         }
 
 
-        internal LLUUID _GroupID = new LLUUID();
+        internal LLUUID _GroupID = LLUUID.Zero;
         public LLUUID GroupID
         {
             get { return _GroupID; }
@@ -264,6 +267,7 @@
         internal InventoryItem(InventoryManager manager, InventoryDescendentsPacket.ItemDataBlock itemData)
             : base(manager)
         {
+
             _Name = System.Text.Encoding.UTF8.GetString(itemData.Name).Trim().Replace(&quot;\0&quot;, &quot;&quot;);
             _Description = System.Text.Encoding.UTF8.GetString(itemData.Description).Trim().Replace(&quot;\0&quot;, &quot;&quot;);
             _CreationDate = itemData.CreationDate;
@@ -271,6 +275,7 @@
             _InvType = itemData.InvType;
             _Type = itemData.Type;
 
+            _ItemID = itemData.ItemID;
             _AssetID = itemData.AssetID;
             _FolderID = itemData.FolderID;
 
@@ -480,8 +485,17 @@
             output += &quot;groupmask = '&quot; + GroupMask + &quot;' &quot;;
             output += &quot;ownermask = '&quot; + OwnerMask + &quot;' &quot;;
 
-            output += &quot;/&gt;\n&quot;;
+            output += &quot;&gt;&quot;;
 
+            if (outputAssets)
+            {
+                if (AssetID != LLUUID.Zero)
+                {
+                    output += xmlSafe(Helpers.FieldToString(Asset.AssetData));
+                }
+            }
+            output += &quot;&lt;/item&gt;&quot;;
+
             return output;
         }
     }

Modified: branches/aditi/libsecondlife-cs/InventorySystem/InventoryManager.cs
===================================================================
--- branches/aditi/libsecondlife-cs/InventorySystem/InventoryManager.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/InventorySystem/InventoryManager.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -24,8 +24,11 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+//#define DEBUG_PACKETS
+
 using System;
 using System.Collections.Generic;
+using System.Threading;
 
 using libsecondlife;
 using libsecondlife.AssetSystem;
@@ -40,9 +43,7 @@
     /// &lt;/summary&gt;
     public class InventoryManager
     {
-        private const bool DEBUG_PACKETS = true;
 
-
         // Reference to the SLClient Library
         private SecondLife slClient;
 
@@ -67,9 +68,9 @@
 
         // Used to track current item being created
         private InventoryItem iiCreationInProgress;
-        private bool ItemCreationInProgress;
+        public ManualResetEvent ItemCreationCompleted;
 
-        private uint LastPacketRecieved;
+        private int LastPacketRecievedAtTick;
 
         // Each InventorySystem needs to be initialized with a client and root folder.
         public InventoryManager(SecondLife client, LLUUID rootFolder)
@@ -87,12 +88,10 @@
             resetFoldersByUUID();
 
             // Setup the callback for Inventory Downloads
-            PacketCallback InventoryDescendentsCallback = new PacketCallback(InventoryDescendentsHandler);
-            slClient.Network.RegisterCallback(PacketType.InventoryDescendents, InventoryDescendentsCallback);
+            slClient.Network.RegisterCallback(PacketType.InventoryDescendents, new NetworkManager.PacketCallback(InventoryDescendentsHandler));
 
             // Setup the callback for Inventory Creation Update
-            PacketCallback UpdateCreateInventoryItemCallback = new PacketCallback(UpdateCreateInventoryItemHandler);
-            slClient.Network.RegisterCallback(PacketType.UpdateCreateInventoryItem, UpdateCreateInventoryItemCallback);
+            slClient.Network.RegisterCallback(PacketType.UpdateCreateInventoryItem, new NetworkManager.PacketCallback(UpdateCreateInventoryItemHandler));
 
         }
 
@@ -246,23 +245,33 @@
 
         internal void ItemCreate(InventoryItem iitem)
         {
-            if (ItemCreationInProgress)
+            if( iiCreationInProgress != null )
             {
                 throw new Exception(&quot;Can only create one item at a time, and an item creation is already in progress.&quot;);
             }
-            else
+
+            try
             {
-                ItemCreationInProgress = true;
+                ItemCreationCompleted = new ManualResetEvent(false);
                 iiCreationInProgress = iitem;
-            }
 
-            Packet packet = InvPacketHelper.CreateInventoryItem(iitem);
-            slClient.Network.SendPacket(packet);
-            if (DEBUG_PACKETS) { Console.WriteLine(packet); }
 
-            while (ItemCreationInProgress)
+                Packet packet = InvPacketHelper.CreateInventoryItem(iitem);
+                int i = 0;
+                do
+                {
+                    if (i++ &gt; 10)
+                        throw new Exception(&quot;Could not create &quot; + iitem.Name);
+                    slClient.Network.SendPacket(packet);
+
+#if DEBUG_PACKETS
+                Console.WriteLine(packet);
+#endif
+                } while (!ItemCreationCompleted.WaitOne(5000, false));
+            }
+            finally
             {
-                slClient.Tick();
+                iiCreationInProgress = null;
             }
         }
 
@@ -270,19 +279,27 @@
         {
             Packet packet = InvPacketHelper.UpdateInventoryItem(iitem);
             slClient.Network.SendPacket(packet);
+
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet); 
+            #endif         
         }
 
         internal void ItemCopy(LLUUID ItemID, LLUUID TargetFolderID)
         {
             Packet packet = InvPacketHelper.CopyInventoryItem(ItemID, TargetFolderID);
             slClient.Network.SendPacket(packet);
+
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet); 
+            #endif         
         }
 
         internal void ItemGiveTo(InventoryItem iitem, LLUUID ToAgentID)
         {
             LLUUID MessageID = LLUUID.GenerateUUID();
 
-            Packet packet = InvPacketHelper.ImprovedInstantMessage(
+            Packet packet = InvPacketHelper.GiveItemViaImprovedInstantMessage(
                 MessageID
                 , ToAgentID
                 , slClient.Self.FirstName + &quot; &quot; + slClient.Self.LastName
@@ -292,6 +309,9 @@
 
             slClient.Network.SendPacket(packet);
 
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet); 
+            #endif         
         }
 
         internal void ItemRemove(InventoryItem iitem)
@@ -301,6 +321,10 @@
 
             Packet packet = InvPacketHelper.RemoveInventoryItem(iitem.ItemID);
             slClient.Network.SendPacket(packet);
+
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet); 
+            #endif         
         }
 
         internal InventoryNotecard NewNotecard(string Name, string Description, string Body, LLUUID FolderID)
@@ -356,7 +380,7 @@
             }
 
             // Set last packet received to now, just so out time-out timer works
-            LastPacketRecieved = Helpers.GetUnixTime();
+            LastPacketRecievedAtTick = Environment.TickCount;
 
             // Send Packet requesting the root Folder, 
             // this should recurse through all folders
@@ -366,14 +390,15 @@
             {
                 if (htFolderDownloadStatus.Count == 0)
                 {
-                    DescendentRequest dr = (DescendentRequest)alFolderRequestQueue[0];
+                    DescendentRequest dr = alFolderRequestQueue[0];
                     alFolderRequestQueue.RemoveAt(0);
                     RequestFolder(dr);
                 }
 
-                if ((Helpers.GetUnixTime() - LastPacketRecieved) &gt; 10)
+                int curTick = Environment.TickCount;
+                if ((curTick - LastPacketRecievedAtTick) &gt; 10000)
                 {
-                    Console.WriteLine(&quot;Time-out while waiting for packets (&quot; + (Helpers.GetUnixTime() - LastPacketRecieved) + &quot; seconds since last packet)&quot;);
+                    Console.WriteLine(&quot;Time-out while waiting for packets (&quot; + ((curTick - LastPacketRecievedAtTick) / 1000) + &quot; seconds since last packet)&quot;);
                     Console.WriteLine(&quot;Current Status:&quot;);
 
                     // have to make a seperate list otherwise we run into modifying the original array
@@ -387,12 +412,12 @@
 
                     foreach (DescendentRequest dr in htFolderDownloadStatus.Values)
                     {
-                        Console.WriteLine(dr.FolderID + &quot; &quot; + dr.Expected + &quot; / &quot; + dr.Received + &quot; / &quot; + dr.LastReceived);
+                        Console.WriteLine(dr.FolderID + &quot; &quot; + dr.Expected + &quot; / &quot; + dr.Received + &quot; / &quot; + dr.LastReceivedAtTick);
 
                         alRestartList.Add(dr);
                     }
 
-                    LastPacketRecieved = Helpers.GetUnixTime();
+                    LastPacketRecievedAtTick = Environment.TickCount;
                     foreach (DescendentRequest dr in alRestartList)
                     {
                         RequestFolder(dr);
@@ -408,13 +433,15 @@
 
         public void UpdateCreateInventoryItemHandler(Packet packet, Simulator simulator)
         {
-            if (DEBUG_PACKETS) { Console.WriteLine(packet); }
+            #if DEBUG_PACKETS
+                Console.WriteLine(packet);
+            #endif
 
-            if (ItemCreationInProgress)
+            if (iiCreationInProgress != null)
             {
                 UpdateCreateInventoryItemPacket reply = (UpdateCreateInventoryItemPacket)packet;
 
-                // User internal variable references, so we don't fire off any update code by using the public accessors
+                // Use internal variable references, so we don't fire off any update code by using the public accessors
 
                 iiCreationInProgress._ItemID = reply.InventoryData[0].ItemID;
 
@@ -441,7 +468,7 @@
 
                 // NOT USED YET: iiCreationInProgress._CallbackID = reply.InventoryData[0].CallbackID;
 
-                ItemCreationInProgress = false;
+                ItemCreationCompleted.Set();
             }
             else
             {
@@ -455,12 +482,12 @@
         {
             InventoryDescendentsPacket reply = (InventoryDescendentsPacket)packet;
 
-            LastPacketRecieved = Helpers.GetUnixTime();
+            LastPacketRecievedAtTick = Environment.TickCount;
 
             InventoryItem invItem;
             InventoryFolder invFolder;
 
-            LLUUID uuidFolderID = new LLUUID();
+            LLUUID uuidFolderID = LLUUID.Zero;
 
             int iDescendentsExpected = int.MaxValue;
             int iDescendentsReceivedThisBlock = 0;
@@ -473,27 +500,34 @@
                 {
                     iDescendentsReceivedThisBlock++;
 
-                    invItem = new InventoryItem(this, itemBlock);
+                    if (itemBlock.ItemID == LLUUID.Zero)
+                    {
+                        // this shouldn't ever happen, but unless you've uploaded an invalid item
+                        // to yourself while developping inventory code
+                    }
+                    else
+                    {
+                        invItem = new InventoryItem(this, itemBlock);
 
-                    InventoryFolder ifolder = (InventoryFolder)htFoldersByUUID[invItem.FolderID];
+                        InventoryFolder ifolder = (InventoryFolder)htFoldersByUUID[invItem.FolderID];
 
-                    if (ifolder.alContents.Contains(invItem) == false)
-                    {
-                        if ((invItem.InvType == 7) &amp;&amp; (invItem.Type == Asset.ASSET_TYPE_NOTECARD))
+                        if (ifolder.alContents.Contains(invItem) == false)
                         {
-                            InventoryItem temp = new InventoryNotecard(this, invItem);
-                            invItem = temp;
-                        }
+                            if ((invItem.InvType == 7) &amp;&amp; (invItem.Type == Asset.ASSET_TYPE_NOTECARD))
+                            {
+                                InventoryItem temp = new InventoryNotecard(this, invItem);
+                                invItem = temp;
+                            }
 
-                        if ((invItem.InvType == 0) &amp;&amp; (invItem.Type == Asset.ASSET_TYPE_IMAGE))
-                        {
-                            InventoryItem temp = new InventoryImage(this, invItem);
-                            invItem = temp;
+                            if ((invItem.InvType == 0) &amp;&amp; (invItem.Type == Asset.ASSET_TYPE_IMAGE))
+                            {
+                                InventoryItem temp = new InventoryImage(this, invItem);
+                                invItem = temp;
+                            }
+
+                            ifolder.alContents.Add(invItem);
                         }
-
-                        ifolder.alContents.Add(invItem);
                     }
-
                 }
             }
 
@@ -560,14 +594,13 @@
             }
             else
             {
-
                 // This one packet didn't have all the descendents we're expecting
                 // so update the total we're expecting, and update the total downloaded
 
                 DescendentRequest dr = (DescendentRequest)htFolderDownloadStatus[uuidFolderID];
                 dr.Expected = iDescendentsExpected;
                 dr.Received += iDescendentsReceivedThisBlock;
-                dr.LastReceived = Helpers.GetUnixTime();
+                dr.LastReceivedAtTick = Environment.TickCount;
 
                 if (dr.Received &gt;= dr.Expected)
                 {
@@ -589,7 +622,7 @@
 
             public int Expected = int.MaxValue;
             public int Received = 0;
-            public uint LastReceived = 0;
+            public int LastReceivedAtTick = 0;
 
             public bool FetchFolders = true;
             public bool FetchItems = true;
@@ -597,7 +630,7 @@
             public DescendentRequest(LLUUID folderID)
             {
                 FolderID = folderID;
-                LastReceived = Helpers.GetUnixTime();
+                LastReceivedAtTick = Environment.TickCount;
             }
 
             public DescendentRequest(LLUUID folderID, bool fetchFolders, bool fetchItems)
@@ -605,7 +638,7 @@
                 FolderID = folderID;
                 FetchFolders = fetchFolders;
                 FetchItems = fetchItems;
-                LastReceived = Helpers.GetUnixTime();
+                LastReceivedAtTick = Environment.TickCount;
             }
 
         }

Modified: branches/aditi/libsecondlife-cs/InventorySystem/InventoryNotecard.cs
===================================================================
--- branches/aditi/libsecondlife-cs/InventorySystem/InventoryNotecard.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/InventorySystem/InventoryNotecard.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -18,7 +18,7 @@
 				{
 					return ((AssetNotecard)Asset).Body;
 				} else {
-					if( (AssetID != null) &amp;&amp; (AssetID != new LLUUID()) )
+                    if ((AssetID != null) &amp;&amp; (AssetID != LLUUID.Zero))
 					{
 						base.iManager.AssetManager.GetInventoryAsset( this );
 						return ((AssetNotecard)Asset).Body;
@@ -64,6 +64,7 @@
 			}
 
 			this.iManager = manager;
+            this._ItemID = ii._ItemID;
 			this._Asset = ii._Asset;
 			this._AssetID = ii._AssetID;
 			this._BaseMask = ii._BaseMask;

Modified: branches/aditi/libsecondlife-cs/InventorySystem/InventoryPacketHelper.cs
===================================================================
--- branches/aditi/libsecondlife-cs/InventorySystem/InventoryPacketHelper.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/InventorySystem/InventoryPacketHelper.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -230,7 +230,7 @@
 
         }
 
-		public Packet ImprovedInstantMessage(
+		public Packet GiveItemViaImprovedInstantMessage(
 			LLUUID ID
 			, LLUUID ToAgentID
 			, String FromAgentName
@@ -258,7 +258,7 @@
 
             // TODO: Either overload this method to allow inclusion of region info or
             // overload the ImprovedInstantMessage in the avatar class to allow item payloads
-            p.MessageBlock.RegionID = new LLUUID();
+            p.MessageBlock.RegionID = LLUUID.Zero;
             p.MessageBlock.ParentEstateID = (uint)0;
 
             return p;
@@ -271,7 +271,7 @@
             CreateInventoryItemPacket p = new CreateInventoryItemPacket();
 
             p.InventoryBlock.CallbackID    = 0;
-            p.InventoryBlock.TransactionID = new LLUUID();
+            p.InventoryBlock.TransactionID = LLUUID.Zero;
 
             p.InventoryBlock.WearableType  = 0; //TODO: Specify the current type here
             p.InventoryBlock.Type    = iitem.Type;
@@ -362,7 +362,7 @@
 			/* IDs */
             CRC += iitem.AssetID.CRC(); // AssetID
             CRC += iitem.FolderID.CRC(); // FolderID
-            CRC += iitem.ItemID==null?new LLUUID().CRC():iitem.ItemID.CRC(); // ItemID
+            CRC += iitem.ItemID == null ? LLUUID.Zero.CRC() : iitem.ItemID.CRC(); // ItemID
 
 			/* Permission stuff */
             CRC += iitem.CreatorID.CRC(); // CreatorID

Modified: branches/aditi/libsecondlife-cs/JSON/JSONTokener.cs
===================================================================
--- branches/aditi/libsecondlife-cs/JSON/JSONTokener.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/JSON/JSONTokener.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -274,20 +274,12 @@
 
             if ((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '.' || b == '-' || b == '+')
             {
-                try
-                {
-                    return Convert.ToInt32(s);
-                }
-                catch
-                {
-                }
-                try
-                {
-                    return Convert.ToDouble(s, NumberFormatInfo.InvariantInfo);
-                }
-                catch
-                {
-                }
+                int intResult;
+                if (Int32.TryParse(s, out intResult))
+                    return intResult;
+                double doubleResult;
+                if (Double.TryParse(s, out doubleResult))
+                    return doubleResult;
             }
             if (s == &quot;&quot;)
             {

Modified: branches/aditi/libsecondlife-cs/NetworkManager.cs
===================================================================
--- branches/aditi/libsecondlife-cs/NetworkManager.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/NetworkManager.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -25,55 +25,22 @@
  */
 
 using System;
-using System.Text;
 using System.Timers;
 using System.Collections.Generic;
 using System.Net;
 using System.Net.Sockets;
-using System.Security.Cryptography;
 using Nwc.XmlRpc;
 using Nii.JSON;
 using libsecondlife.Packets;
+using System.Globalization;
 
 namespace libsecondlife
 {
     /// &lt;summary&gt;
-    /// 
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;packet&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
-	public delegate void PacketCallback(Packet packet, Simulator simulator);
-    /// &lt;summary&gt;
-    /// 
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;reason&quot;&gt;&lt;/param&gt;
-    public delegate void SimDisconnectCallback(Simulator simulator, DisconnectType reason);
-    /// &lt;summary&gt;
-    /// 
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;reason&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;
-    public delegate void DisconnectCallback(DisconnectType reason, string message);
-
-    /// &lt;summary&gt;
-    /// 
-    /// &lt;/summary&gt;
-    public enum DisconnectType
-    {
-        /// &lt;summary&gt;&lt;/summary&gt;
-        ClientInitiated,
-        /// &lt;summary&gt;&lt;/summary&gt;
-        ServerInitiated,
-        /// &lt;summary&gt;&lt;/summary&gt;
-        NetworkTimeout
-    }
-
-    /// &lt;summary&gt;
     /// This exception is thrown whenever a network operation is attempted 
     /// without a network connection.
     /// &lt;/summary&gt;
-	public class NotConnectedException : ApplicationException { }
+    public class NotConnectedException : ApplicationException { }
 
 	internal class AcceptAllCertificatePolicy : ICertificatePolicy
 	{
@@ -94,11 +61,17 @@
     /// Simulator is a wrapper for a network connection to a simulator and the
     /// Region class representing the block of land in the metaverse.
     /// &lt;/summary&gt;
-	public class Simulator
-	{
-        /// &lt;summary&gt;
-        /// The Region class that this Simulator wraps
-        /// &lt;/summary&gt;
+    public class Simulator
+    {
+        /// &lt;summary&gt;A public reference to the client that this Simulator object
+        /// is attached to&lt;/summary&gt;
+        public SecondLife Client;
+
+        /// &lt;summary&gt;The maximum size of the sequence number inbox, used to 
+        /// check for resent and/or duplicate packets&lt;/summary&gt;
+        public const int INBOX_SIZE = 10000;
+
+        /// &lt;summary&gt;The Region class that this Simulator wraps&lt;/summary&gt;
         public Region Region;
 
         /// &lt;summary&gt;
@@ -133,23 +106,28 @@
         /// Used internally to track sim disconnections, do not modify this 
         /// variable.
         /// &lt;/summary&gt;
-        public bool DisconnectCandidate;
-        
-        private SecondLife Client;
-		private NetworkManager Network;
-		private Dictionary&lt;PacketType,List&lt;PacketCallback&gt;&gt; Callbacks;
-		private ushort Sequence;
-		private byte[] RecvBuffer;
-		private Socket Connection;
-		private AsyncCallback ReceivedData;
-		private Dictionary&lt;int, Packet&gt; NeedAck;
-		private SortedList&lt;ushort, ushort&gt; Inbox;
-        private List&lt;uint&gt; PendingAcks;
-		private bool connected;
-		private uint circuitCode;
-		private IPEndPoint ipEndPoint;
-		private EndPoint endPoint;
+        public bool DisconnectCandidate = false;
+
+        private NetworkManager Network;
+        private Dictionary&lt;PacketType, List&lt;NetworkManager.PacketCallback&gt;&gt; Callbacks;
+        private ushort Sequence = 0;
+        private byte[] RecvBuffer = new byte[4092];
+        private byte[] ZeroBuffer = new byte[4092];
+        private byte[] ZeroOutBuffer = new byte[4092];
+        private Socket Connection = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
+        private AsyncCallback ReceivedData;
+        private Dictionary&lt;int, Packet&gt; NeedAck = new Dictionary&lt;int, Packet&gt;();
+        private Queue&lt;ushort&gt; Inbox = new Queue&lt;ushort&gt;(INBOX_SIZE);
+        private List&lt;uint&gt; PendingAcks = new List&lt;uint&gt;();
+        private bool connected = false;
+        private uint circuitCode;
+        private IPEndPoint ipEndPoint;
+        private EndPoint endPoint;
         private System.Timers.Timer AckTimer;
+        // Every tick, all ACKs are sent out and the age of unACKed packets is checked
+        private int TickLength = 500;
+        // Number of milliseconds before a packet is assumed lost and resent
+        private int ResendTimeout = 4000;
 
         /// &lt;summary&gt;
         /// 
@@ -159,36 +137,24 @@
         /// &lt;param name=&quot;circuit&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;ip&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;port&quot;&gt;&lt;/param&gt;
-		public Simulator(SecondLife client, Dictionary&lt;PacketType,List&lt;PacketCallback&gt;&gt; callbacks, uint circuit, 
-			IPAddress ip, int port)
-		{
+        public Simulator(SecondLife client, Dictionary&lt;PacketType, List&lt;NetworkManager.PacketCallback&gt;&gt; callbacks,
+            uint circuit, IPAddress ip, int port)
+        {
             Client = client;
             Network = client.Network;
             Callbacks = callbacks;
             Region = new Region(client);
             circuitCode = circuit;
-            Sequence = 0;
-            RecvBuffer = new byte[2048];
-            Connection = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
-            connected = false;
-            DisconnectCandidate = false;
-            AckTimer = new System.Timers.Timer(500);
+            AckTimer = new System.Timers.Timer(TickLength);
             AckTimer.Elapsed += new ElapsedEventHandler(AckTimer_Elapsed);
 
-            // Initialize the dictionary for reliable packets waiting on ACKs from the server
-            NeedAck = new Dictionary&lt;int, Packet&gt;();
+            // Initialize the callback for receiving a new packet
+            ReceivedData = new AsyncCallback(OnReceivedData);
 
-            // Initialize the lists of sequence numbers we've received so far
-            Inbox = new SortedList&lt;ushort, ushort&gt;();
-            PendingAcks = new List&lt;uint&gt;();
-
             Client.Log(&quot;Connecting to &quot; + ip.ToString() + &quot;:&quot; + port, Helpers.LogLevel.Info);
 
             try
             {
-                // Setup the callback
-                ReceivedData = new AsyncCallback(OnReceivedData);
-
                 // Create an endpoint that we will be communicating with (need it in two 
                 // types due to .NET weirdness)
                 ipEndPoint = new IPEndPoint(ip, port);
@@ -227,25 +193,25 @@
                 Console.WriteLine(e.ToString());
                 Client.Log(e.ToString(), Helpers.LogLevel.Error);
             }
-		}
+        }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
-		public void Disconnect()
-		{
-			// Send the CloseCircuit notice
+        public void Disconnect()
+        {
+            // Send the CloseCircuit notice
             CloseCircuitPacket close = new CloseCircuitPacket();
-			
+
             try
             {
                 Connection.Send(close.ToBytes());
-			}
-			catch (SocketException)
-			{
-				// There's a high probability of this failing if the network is
+            }
+            catch (SocketException)
+            {
+                // There's a high probability of this failing if the network is
                 // disconnected, so don't even bother logging the error
-			}
+            }
 
             try
             {
@@ -258,30 +224,41 @@
             }
 
             connected = false;
-		}
+        }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;packet&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;incrementSequence&quot;&gt;&lt;/param&gt;
-		public void SendPacket(Packet packet, bool incrementSequence)
-		{
-			byte[] buffer;
-			int bytes;
+        public void SendPacket(Packet packet, bool incrementSequence)
+        {
+            byte[] buffer;
+            int bytes;
 
-			if (!connected &amp;&amp; packet.Type != PacketType.UseCircuitCode)
-			{
-				Client.Log(&quot;Trying to send a &quot; + packet.Type.ToString() + &quot; packet when the socket is closed&quot;,
-					Helpers.LogLevel.Warning);
-				
-				throw new NotConnectedException();
-			}
+            if (!connected &amp;&amp; packet.Type != PacketType.UseCircuitCode)
+            {
+                Client.Log(&quot;Trying to send a &quot; + packet.Type.ToString() + &quot; packet when the socket is closed&quot;,
+                    Helpers.LogLevel.Warning);
 
+                throw new NotConnectedException();
+            }
+
+            if (packet.Header.AckList.Length &gt; 0)
+            {
+                // Scrub any appended ACKs since all of the ACK handling is done here
+                packet.Header.AckList = new uint[0];
+            }
+            packet.Header.AppendedAcks = false;
+
             if (incrementSequence)
             {
-                // Set the sequence number here since we are manually serializing the packet
-                packet.Header.Sequence = ++Sequence;
+                // Set the sequence number
+                if (Sequence == ushort.MaxValue)
+                    Sequence = 0;
+                else
+                    Sequence++;
+                packet.Header.Sequence = Sequence;
 
                 if (packet.Header.Reliable)
                 {
@@ -329,24 +306,29 @@
             buffer = packet.ToBytes();
             bytes = buffer.Length;
 
-            // Zerocode if needed
-            if (packet.Header.Zerocoded)
-            {
-                byte[] zeroBuffer = new byte[4096];
-                bytes = Helpers.ZeroEncode(buffer, bytes, zeroBuffer);
-
-                buffer = zeroBuffer;
-            }
-
             try
             {
-                Connection.Send(buffer, bytes, SocketFlags.None);
+                // Zerocode if needed
+                if (packet.Header.Zerocoded)
+                {
+                    lock (ZeroOutBuffer)
+                    {
+                        bytes = Helpers.ZeroEncode(buffer, bytes, ZeroOutBuffer);
+                        Connection.Send(ZeroOutBuffer, bytes, SocketFlags.None);
+                    }
+                }
+                else
+                {
+                    Connection.Send(buffer, bytes, SocketFlags.None);
+                }
             }
             catch (SocketException e)
             {
                 Client.Log(e.ToString(), Helpers.LogLevel.Error);
+
+                // FIXME: Assume this socket is dead and Disconnect()
             }
-		}
+        }
 
         /// &lt;summary&gt;
         /// 
@@ -369,6 +351,11 @@
             }
         }
 
+        public override string ToString()
+        {
+            return Region.Name + &quot; (&quot; + ipEndPoint.ToString() + &quot;)&quot;;
+        }
+
         private void SendAck(ushort id)
         {
             PacketAckPacket ack = new PacketAckPacket();
@@ -407,7 +394,6 @@
                     }
 
                     acks.Header.Reliable = false;
-
                     SendPacket(acks, true);
 
                     PendingAcks.Clear();
@@ -415,8 +401,28 @@
             }
         }
 
-		private void OnReceivedData(IAsyncResult result)
-		{
+        private void ResendUnacked()
+        {
+            int now = Environment.TickCount;
+
+            lock (NeedAck)
+            {
+                foreach (Packet packet in NeedAck.Values)
+                {
+                    if (now - packet.TickCount &gt; ResendTimeout)
+                    {
+                        Client.Log(&quot;Resending &quot; + packet.Type.ToString() + &quot; packet, &quot; + 
+                            (now - packet.TickCount) + &quot;ms have passed&quot;, Helpers.LogLevel.Info);
+
+                        packet.Header.Resent = true;
+                        SendPacket(packet, false);
+                    }
+                }
+            }
+        }
+
+        private void OnReceivedData(IAsyncResult result)
+        {
             Packet packet = null;
             int numBytes;
 
@@ -434,13 +440,13 @@
                     numBytes = Connection.EndReceiveFrom(result, ref endPoint);
 
                     int packetEnd = numBytes - 1;
-                    packet = Packet.BuildPacket(RecvBuffer, ref packetEnd);
+                    packet = Packet.BuildPacket(RecvBuffer, ref packetEnd, ZeroBuffer);
 
                     Connection.BeginReceiveFrom(RecvBuffer, 0, RecvBuffer.Length, SocketFlags.None, ref endPoint, ReceivedData, null);
                 }
                 catch (SocketException)
                 {
-                    Client.Log(endPoint.ToString() + &quot; socket is closed, shutting down &quot; + this.Region.Name, 
+                    Client.Log(endPoint.ToString() + &quot; socket is closed, shutting down &quot; + this.Region.Name,
                         Helpers.LogLevel.Info);
 
                     connected = false;
@@ -465,32 +471,38 @@
                 }
 
                 // Check if we already received this packet
-                lock (Inbox)
+                if (Inbox.Contains(packet.Header.Sequence))
                 {
-                    if (Inbox.ContainsKey(packet.Header.Sequence))
-                    {
-                        Client.Log(&quot;Received a duplicate &quot; + packet.Type.ToString() + &quot;, sequence=&quot; +
-                            packet.Header.Sequence + &quot;, resent=&quot; + ((packet.Header.Resent) ? &quot;Yes&quot; : &quot;No&quot;),
-                            Helpers.LogLevel.Info);
+                    Client.Log(&quot;Received a duplicate &quot; + packet.Type.ToString() + &quot;, sequence=&quot; +
+                        packet.Header.Sequence + &quot;, resent=&quot; + ((packet.Header.Resent) ? &quot;Yes&quot; : &quot;No&quot;) +
+                        &quot;, Inbox.Count=&quot; + Inbox.Count + &quot;, NeedAck.Count=&quot; + NeedAck.Count,
+                        Helpers.LogLevel.Info);
 
-                        // Send an ACK for this packet immediately
-                        SendAck(packet.Header.Sequence);
+                    // Send an ACK for this packet immediately
+                    SendAck(packet.Header.Sequence);
 
-                        // Avoid firing a callback twice for the same packet
-                        return;
-                    }
-                    else
+                    // Avoid firing a callback twice for the same packet
+                    return;
+                }
+                else
+                {
+                    lock (PendingAcks)
                     {
-                        Inbox.Add(packet.Header.Sequence, packet.Header.Sequence);
-
-                        lock (PendingAcks)
-                        {
-                            PendingAcks.Add((uint)packet.Header.Sequence);
-                        }
+                        PendingAcks.Add((uint)packet.Header.Sequence);
                     }
                 }
             }
 
+            // Add this packet to our inbox
+            lock (Inbox)
+            {
+                if (Inbox.Count &gt;= INBOX_SIZE)
+                {
+                    Inbox.Dequeue();
+                }
+                Inbox.Enqueue(packet.Header.Sequence);
+            }
+
             // Handle appended ACKs
             if (packet.Header.AppendedAcks)
             {
@@ -498,14 +510,7 @@
                 {
                     foreach (ushort ack in packet.Header.AckList)
                     {
-                        if (NeedAck.ContainsKey(ack))
-                        {
-                            NeedAck.Remove(ack);
-                        }
-                        else
-                        {
-                            Client.Log(&quot;Appended ACK for a packet we didn't send: &quot; + ack, Helpers.LogLevel.Warning);
-                        }
+                        NeedAck.Remove(ack);
                     }
                 }
             }
@@ -513,10 +518,10 @@
             // Handle PacketAck packets
             if (packet.Type == PacketType.PacketAck)
             {
+                PacketAckPacket ackPacket = (PacketAckPacket)packet;
+
                 lock (NeedAck)
                 {
-                    PacketAckPacket ackPacket = (PacketAckPacket)packet;
-
                     foreach (PacketAckPacket.PacketsBlock block in ackPacket.Packets)
                     {
                         NeedAck.Remove((ushort)block.ID);
@@ -530,10 +535,10 @@
             {
                 if (Callbacks.ContainsKey(packet.Type))
                 {
-                    List&lt;PacketCallback&gt; callbackArray = Callbacks[packet.Type];
+                    List&lt;NetworkManager.PacketCallback&gt; callbackArray = Callbacks[packet.Type];
 
                     // Fire any registered callbacks
-                    foreach (PacketCallback callback in callbackArray)
+                    foreach (NetworkManager.PacketCallback callback in callbackArray)
                     {
                         if (callback != null)
                         {
@@ -541,13 +546,13 @@
                         }
                     }
                 }
-                
+
                 if (Callbacks.ContainsKey(PacketType.Default))
                 {
-                    List&lt;PacketCallback&gt; callbackArray = Callbacks[PacketType.Default];
+                    List&lt;NetworkManager.PacketCallback&gt; callbackArray = Callbacks[PacketType.Default];
 
                     // Fire any registered callbacks
-                    foreach (PacketCallback callback in callbackArray)
+                    foreach (NetworkManager.PacketCallback callback in callbackArray)
                     {
                         if (callback != null)
                         {
@@ -565,15 +570,13 @@
 
         private void AckTimer_Elapsed(object sender, ElapsedEventArgs ea)
         {
-            if (!connected)
+            if (connected)
             {
-                AckTimer.Stop();
-                return;
+                SendAcks();
+                ResendUnacked();
             }
-
-            SendAcks();
         }
-	}
+    }
 
     /// &lt;summary&gt;
     /// NetworkManager is responsible for managing the network layer of 
@@ -581,31 +584,68 @@
     /// outgoing traffic and deserializes incoming traffic, and provides
     /// instances of delegates for network-related events.
     /// &lt;/summary&gt;
-	public class NetworkManager
-	{
+    public class NetworkManager
+    {
         /// &lt;summary&gt;
+        /// Coupled with RegisterCallback(), this is triggered whenever a packet
+        /// of a registered type is received
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;packet&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        public delegate void PacketCallback(Packet packet, Simulator simulator);
+        /// &lt;summary&gt;
+        /// Triggered when a simulator other than the simulator that is currently
+        /// being occupied disconnects for whatever reason
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;The simulator that disconnected, which will become a null
+        /// reference after the callback is finished&lt;/param&gt;
+        /// &lt;param name=&quot;reason&quot;&gt;Enumeration explaining the reason for the disconnect&lt;/param&gt;
+        public delegate void SimDisconnectCallback(Simulator simulator, DisconnectType reason);
+        /// &lt;summary&gt;
+        /// Triggered when we are logged out of the grid due to a simulator request,
+        /// client request, network timeout, or any other cause
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;reason&quot;&gt;Enumeration explaining the reason for the disconnect&lt;/param&gt;
+        /// &lt;param name=&quot;message&quot;&gt;If we were logged out by the simulator, this 
+        /// is a message explaining why&lt;/param&gt;
+        public delegate void DisconnectCallback(DisconnectType reason, string message);
+
+        /// &lt;summary&gt;
+        /// Explains why a simulator or the grid disconnected from us
+        /// &lt;/summary&gt;
+        public enum DisconnectType
+        {
+            /// &lt;summary&gt;The client requested the logout or simulator disconnect&lt;/summary&gt;
+            ClientInitiated,
+            /// &lt;summary&gt;The server notified us that it is disconnecting&lt;/summary&gt;
+            ServerInitiated,
+            /// &lt;summary&gt;Either a socket was closed or network traffic timed out&lt;/summary&gt;
+            NetworkTimeout
+        }
+
+        /// &lt;summary&gt;
         /// The permanent UUID for the logged in avatar
         /// &lt;/summary&gt;
-		public LLUUID AgentID;
+        public LLUUID AgentID;
         /// &lt;summary&gt;
         /// A temporary UUID assigned to this session, used for secure 
         /// transactions
         /// &lt;/summary&gt;
-		public LLUUID SessionID;
+        public LLUUID SessionID;
         /// &lt;summary&gt;
         /// A string holding a descriptive error on login failure, empty
         /// otherwise
         /// &lt;/summary&gt;
-		public string LoginError;
+        public string LoginError;
         /// &lt;summary&gt;
         /// The simulator that the logged in avatar is currently occupying
         /// &lt;/summary&gt;
-		public Simulator CurrentSim;
+        public Simulator CurrentSim;
         /// &lt;summary&gt;
         /// The complete dictionary of all the login values returned by the 
         /// RPC login server, converted to native data types wherever possible
         /// &lt;/summary&gt;
-		public Dictionary&lt;string, object&gt; LoginValues;
+        public Dictionary&lt;string, object&gt; LoginValues;
         /// &lt;summary&gt;
         /// Shows whether the network layer is logged in to the grid or not
         /// &lt;/summary&gt;
@@ -624,9 +664,9 @@
         /// &lt;/summary&gt;
         public DisconnectCallback OnDisconnected;
 
-		private Dictionary&lt;PacketType,List&lt;PacketCallback&gt;&gt; Callbacks;
-		private SecondLife Client;
-		private List&lt;Simulator&gt; Simulators;
+        private Dictionary&lt;PacketType, List&lt;PacketCallback&gt;&gt; Callbacks;
+        private SecondLife Client;
+        private List&lt;Simulator&gt; Simulators;
         private System.Timers.Timer DisconnectTimer;
         private bool connected;
 
@@ -634,41 +674,41 @@
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
-		public NetworkManager(SecondLife client)
-		{
-			Client = client;
-			Simulators = new List&lt;Simulator&gt;();
-			Callbacks = new Dictionary&lt;PacketType, List&lt;PacketCallback&gt;&gt;();
-			CurrentSim = null;
-			LoginValues = null;
+        public NetworkManager(SecondLife client)
+        {
+            Client = client;
+            Simulators = new List&lt;Simulator&gt;();
+            Callbacks = new Dictionary&lt;PacketType, List&lt;PacketCallback&gt;&gt;();
+            CurrentSim = null;
+            LoginValues = null;
 
-			// Register the internal callbacks
-			RegisterCallback(PacketType.RegionHandshake, new PacketCallback(RegionHandshakeHandler));
-			RegisterCallback(PacketType.StartPingCheck, new PacketCallback(StartPingCheckHandler));
-			RegisterCallback(PacketType.ParcelOverlay, new PacketCallback(ParcelOverlayHandler));
-			RegisterCallback(PacketType.EnableSimulator, new PacketCallback(EnableSimulatorHandler));
+            // Register the internal callbacks
+            RegisterCallback(PacketType.RegionHandshake, new PacketCallback(RegionHandshakeHandler));
+            RegisterCallback(PacketType.StartPingCheck, new PacketCallback(StartPingCheckHandler));
+            RegisterCallback(PacketType.ParcelOverlay, new PacketCallback(ParcelOverlayHandler));
+            RegisterCallback(PacketType.EnableSimulator, new PacketCallback(EnableSimulatorHandler));
             RegisterCallback(PacketType.KickUser, new PacketCallback(KickUserHandler));
 
             // Disconnect a sim if no network traffic has been received for 15 seconds
             DisconnectTimer = new System.Timers.Timer(15000);
             DisconnectTimer.Elapsed += new ElapsedEventHandler(DisconnectTimer_Elapsed);
-		}
+        }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt;
-		public void RegisterCallback(PacketType type, PacketCallback callback)
-		{
-			if (!Callbacks.ContainsKey(type))
-			{
-				Callbacks[type] = new List&lt;PacketCallback&gt;();
-			}
+        public void RegisterCallback(PacketType type, PacketCallback callback)
+        {
+            if (!Callbacks.ContainsKey(type))
+            {
+                Callbacks[type] = new List&lt;PacketCallback&gt;();
+            }
 
             List&lt;PacketCallback&gt; callbackArray = Callbacks[type];
-			callbackArray.Add(callback);
-		}
+            callbackArray.Add(callback);
+        }
 
         /// &lt;summary&gt;
         /// 
@@ -676,51 +716,51 @@
         /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt;
         public void UnregisterCallback(PacketType type, PacketCallback callback)
-		{
-			if (!Callbacks.ContainsKey(type))
-			{
-				Client.Log(&quot;Trying to unregister a callback for packet &quot; + type.ToString() + 
-					&quot; when no callbacks are setup for that packet&quot;, Helpers.LogLevel.Info);
-				return;
-			}
+        {
+            if (!Callbacks.ContainsKey(type))
+            {
+                Client.Log(&quot;Trying to unregister a callback for packet &quot; + type.ToString() +
+                    &quot; when no callbacks are setup for that packet&quot;, Helpers.LogLevel.Info);
+                return;
+            }
 
             List&lt;PacketCallback&gt; callbackArray = Callbacks[type];
 
-			if (callbackArray.Contains(callback))
-			{
-				callbackArray.Remove(callback);
-			}
-			else
-			{
+            if (callbackArray.Contains(callback))
+            {
+                callbackArray.Remove(callback);
+            }
+            else
+            {
                 Client.Log(&quot;Trying to unregister a non-existant callback for packet &quot; + type.ToString(),
-					Helpers.LogLevel.Info);
-			}
-		}
+                    Helpers.LogLevel.Info);
+            }
+        }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;packet&quot;&gt;&lt;/param&gt;
-		public void SendPacket(Packet packet)
-		{
-			if (CurrentSim != null &amp;&amp; CurrentSim.Connected)
-			{
-				CurrentSim.SendPacket(packet, true);
-			}
-		}
+        public void SendPacket(Packet packet)
+        {
+            if (CurrentSim != null &amp;&amp; CurrentSim.Connected)
+            {
+                CurrentSim.SendPacket(packet, true);
+            }
+        }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;packet&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
-		public void SendPacket(Packet packet, Simulator simulator)
-		{
-            if (simulator.Connected)
+        public void SendPacket(Packet packet, Simulator simulator)
+        {
+            if (simulator != null &amp;&amp; simulator.Connected)
             {
                 simulator.SendPacket(packet, true);
             }
-		}
+        }
 
         /// &lt;summary&gt;
         /// 
@@ -737,7 +777,21 @@
                 throw new NotConnectedException();
             }
         }
+        /// &lt;summary&gt;
+        /// Use this if you want to login to a specific location
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;sim&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;z&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;string with a value that can be used in the start field in .DefaultLoginValues()&lt;/returns&gt;
 
+        public static string StartLocation(string sim, int x, int y, int z)
+        {
+            //uri:sim&amp;x&amp;y&amp;z
+            return &quot;uri:&quot; + sim.ToLower() + &quot;&amp;&quot; + x + &quot;&amp;&quot; + y + &quot;&amp;&quot; + z;
+        }
+
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
@@ -749,17 +803,47 @@
         /// &lt;returns&gt;&lt;/returns&gt;
         public static Dictionary&lt;string, object&gt; DefaultLoginValues(
             string firstName, string lastName, string password, string userAgent, string author)
-		{
-			return DefaultLoginValues(firstName, lastName, password, &quot;00:00:00:00:00:00&quot;, &quot;last&quot;, 
-				1, 50, 50, 50, &quot;Win&quot;, &quot;0&quot;, userAgent, author);
-		}
+        {
+            return DefaultLoginValues(firstName, lastName, password, &quot;00:00:00:00:00:00&quot;, &quot;last&quot;,
+                1, 50, 50, 50, &quot;Win&quot;, &quot;0&quot;, userAgent, author, false);
+        }
 
-        public static Dictionary&lt;string, object&gt; DefaultLoginValues(string firstName, 
-            string lastName, string password, string mac, string startLocation, string platform, 
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;firstName&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;lastName&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;password&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;userAgent&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;author&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public static Dictionary&lt;string, object&gt; DefaultLoginValues(
+            string firstName, string lastName, string password, string startLocation, string userAgent, string author,
+            bool md5pass)
+        {
+            return DefaultLoginValues(firstName, lastName, password, &quot;00:00:00:00:00:00&quot;, startLocation,
+                1, 50, 50, 50, &quot;Win&quot;, &quot;0&quot;, userAgent, author, md5pass);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;firstName&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;lastName&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;password&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;mac&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;startLocation&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;platform&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;viewerDigest&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;userAgent&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;author&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public static Dictionary&lt;string, object&gt; DefaultLoginValues(string firstName,
+            string lastName, string password, string mac, string startLocation, string platform,
             string viewerDigest, string userAgent, string author)
         {
             return DefaultLoginValues(firstName, lastName, password, mac, startLocation,
-                1, 50, 50, 50, platform, viewerDigest, userAgent, author);
+                1, 50, 50, 50, platform, viewerDigest, userAgent, author, false);
         }
 
         /// &lt;summary&gt;
@@ -779,37 +863,28 @@
         /// &lt;param name=&quot;userAgent&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;author&quot;&gt;&lt;/param&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
-        public static Dictionary&lt;string, object&gt; DefaultLoginValues(string firstName, 
-            string lastName, string password, string mac, string startLocation, int major, int minor, 
-            int patch, int build, string platform, string viewerDigest, string userAgent, string author)
-		{
+        public static Dictionary&lt;string, object&gt; DefaultLoginValues(string firstName,
+            string lastName, string password, string mac, string startLocation, int major, int minor,
+            int patch, int build, string platform, string viewerDigest, string userAgent, string author, bool md5pass)
+        {
             Dictionary&lt;string, object&gt; values = new Dictionary&lt;string, object&gt;();
 
-			// Generate an MD5 hash of the password
-			MD5 md5 = new MD5CryptoServiceProvider();
-			byte[] hash = md5.ComputeHash(Encoding.ASCII.GetBytes(password));
-			StringBuilder passwordDigest = new StringBuilder();
-			// Convert the hash to a hex string
-			foreach(byte b in hash)
-			{
-				passwordDigest.AppendFormat(&quot;{0:x2}&quot;, b);
-			}
+            values[&quot;first&quot;] = firstName;
+            values[&quot;last&quot;] = lastName;
+            values[&quot;passwd&quot;] = md5pass ? password : Helpers.MD5(password);
+            values[&quot;start&quot;] = startLocation;
+            values[&quot;major&quot;] = major;
+            values[&quot;minor&quot;] = minor;
+            values[&quot;patch&quot;] = patch;
+            values[&quot;build&quot;] = build;
+            values[&quot;platform&quot;] = platform;
+            values[&quot;mac&quot;] = mac;
+            values[&quot;agree_to_tos&quot;] = &quot;true&quot;;
+            values[&quot;read_critical&quot;] = &quot;true&quot;;
+            values[&quot;viewer_digest&quot;] = viewerDigest;
+            values[&quot;user-agent&quot;] = userAgent + &quot; (&quot; + Helpers.VERSION + &quot;)&quot;;
+            values[&quot;author&quot;] = author;
 
-			values[&quot;first&quot;] = firstName;
-			values[&quot;last&quot;] = lastName;
-			values[&quot;passwd&quot;] = &quot;$1$&quot; + passwordDigest;
-			values[&quot;start&quot;] = startLocation;
-			values[&quot;major&quot;] = major;
-			values[&quot;minor&quot;] = minor;
-			values[&quot;patch&quot;] = patch;
-			values[&quot;build&quot;] = build;
-			values[&quot;platform&quot;] = platform;
-			values[&quot;mac&quot;] = mac;
-			values[&quot;agree_to_tos&quot;] = &quot;true&quot;;
-			values[&quot;viewer_digest&quot;] = viewerDigest;
-			values[&quot;user-agent&quot;] = userAgent + &quot; (&quot; + Helpers.VERSION + &quot;)&quot;;
-			values[&quot;author&quot;] = author;
-
             // Build the options array
             List&lt;object&gt; optionsArray = new List&lt;object&gt;();
             optionsArray.Add(&quot;inventory-root&quot;);
@@ -829,14 +904,42 @@
 
             values[&quot;options&quot;] = optionsArray;
 
-			return values;
-		}
+            return values;
+        }
 
+        /// &lt;summary&gt;
+        /// Assigned by the OnConnected event. Raised when login was a success
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;sender&quot;&gt;Reference to the SecondLife class that called the event&lt;/param&gt;
+        public delegate void ConnectedCallback(object sender);
+
+        /// &lt;summary&gt;
+        /// Event raised when the client was able to connected successfully.
+        /// &lt;/summary&gt;
+        /// &lt;remarks&gt;Uses the ConnectedCallback delegate.&lt;/remarks&gt;
+        public event ConnectedCallback OnConnected;
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;firstName&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;lastName&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;password&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;userAgent&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;author&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
         public bool Login(string firstName, string lastName, string password, string userAgent, string author)
         {
-            Dictionary&lt;string, object&gt; loginParams = NetworkManager.DefaultLoginValues(firstName, lastName, 
-                password, userAgent, author);
+            Dictionary&lt;string, object&gt; loginParams = NetworkManager.DefaultLoginValues(firstName, lastName,
+                password, &quot;last&quot;, userAgent, author, false);
+            return Login(loginParams);
+        }
 
+        public bool Login(string firstName, string lastName, string password, string userAgent, string start,
+            string author, bool md5pass)
+        {
+            Dictionary&lt;string, object&gt; loginParams = NetworkManager.DefaultLoginValues(firstName, lastName,
+                password, userAgent, start, author, md5pass);
             return Login(loginParams);
         }
 
@@ -846,9 +949,9 @@
         /// &lt;param name=&quot;loginParams&quot;&gt;&lt;/param&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
         public bool Login(Dictionary&lt;string, object&gt; loginParams)
-		{
+        {
             return Login(loginParams, SecondLife.LOGIN_SERVER);
-		}
+        }
 
         /// &lt;summary&gt;
         /// 
@@ -857,33 +960,33 @@
         /// &lt;param name=&quot;url&quot;&gt;&lt;/param&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
         public bool Login(Dictionary&lt;string, object&gt; loginParams, string url)
-		{
-			XmlRpcResponse result;
-			XmlRpcRequest xmlrpc = new XmlRpcRequest();
-			xmlrpc.MethodName = &quot;login_to_simulator&quot;;
-			xmlrpc.Params.Clear();
-			xmlrpc.Params.Add(loginParams);
+        {
+            XmlRpcResponse result;
+            XmlRpcRequest xmlrpc = new XmlRpcRequest();
+            xmlrpc.MethodName = &quot;login_to_simulator&quot;;
+            xmlrpc.Params.Clear();
+            xmlrpc.Params.Add(loginParams);
 
-			try
-			{
-				result = (XmlRpcResponse)xmlrpc.Send(url);
-			}
-			catch (Exception e)
-			{
-				LoginError = e.Message;
-				LoginValues = null;
-				return false;
-			}
+            try
+            {
+                result = (XmlRpcResponse)xmlrpc.Send(url);
+            }
+            catch (Exception e)
+            {
+                LoginError = &quot;XML-RPC Error: &quot; + e.Message;
+                LoginValues = null;
+                return false;
+            }
 
-			if (result.IsFault)
-			{
-				Client.Log(&quot;Fault &quot; + result.FaultCode + &quot;: &quot; + result.FaultString, Helpers.LogLevel.Error);
-				LoginError = &quot;Fault &quot; + result.FaultCode + &quot;: &quot; + result.FaultString;
-				LoginValues = null;
-				return false;
-			}
+            if (result.IsFault)
+            {
+                Client.Log(&quot;Fault &quot; + result.FaultCode + &quot;: &quot; + result.FaultString, Helpers.LogLevel.Error);
+                LoginError = &quot;XML-RPC Fault: &quot; + result.FaultCode + &quot;: &quot; + result.FaultString;
+                LoginValues = null;
+                return false;
+            }
 
-			LoginValues = (Dictionary&lt;string, object&gt;)result.Value;
+            LoginValues = (Dictionary&lt;string, object&gt;)result.Value;
 
             if ((string)LoginValues[&quot;login&quot;] == &quot;indeterminate&quot;)
             {
@@ -891,24 +994,24 @@
                 LoginError = &quot;Got a redirect, login with the official client to update&quot;;
                 return false;
             }
-			else if ((string)LoginValues[&quot;login&quot;] == &quot;false&quot;)
-			{
-				LoginError = LoginValues[&quot;reason&quot;] + &quot;: &quot; + LoginValues[&quot;message&quot;];
-				return false;
-			}
+            else if ((string)LoginValues[&quot;login&quot;] == &quot;false&quot;)
+            {
+                LoginError = LoginValues[&quot;reason&quot;] + &quot;: &quot; + LoginValues[&quot;message&quot;];
+                return false;
+            }
             else if ((string)LoginValues[&quot;login&quot;] != &quot;true&quot;)
             {
                 LoginError = &quot;Unknown error&quot;;
                 return false;
             }
 
-			System.Text.RegularExpressions.Regex LLSDtoJSON = 
-				new System.Text.RegularExpressions.Regex(@&quot;('|r([0-9])|r(\-))&quot;);
-			string json;
-			Dictionary&lt;string, object&gt; jsonObject = null;
-			LLVector3 vector = null;
-			LLVector3 posVector = null;
-			LLVector3 lookatVector = null;
+            System.Text.RegularExpressions.Regex LLSDtoJSON =
+                new System.Text.RegularExpressions.Regex(@&quot;('|r([0-9])|r(\-))&quot;);
+            string json;
+            Dictionary&lt;string, object&gt; jsonObject = null;
+            LLVector3 vector = null;
+            LLVector3 posVector = null;
+            LLVector3 lookatVector = null;
             ulong regionHandle = 0;
 
             try
@@ -925,12 +1028,20 @@
                     JSONArray jsonVector = (JSONArray)jsonObject[&quot;vector&quot;];
 
                     // Convert the JSON object to an LLVector3
-                    vector = new LLVector3(Convert.ToSingle(jsonVector[0]),
-                        Convert.ToSingle(jsonVector[1]), Convert.ToSingle(jsonVector[2]));
+                    vector = new LLVector3(Convert.ToSingle(jsonVector[0], CultureInfo.InvariantCulture),
+                        Convert.ToSingle(jsonVector[1], CultureInfo.InvariantCulture), Convert.ToSingle(jsonVector[2], CultureInfo.InvariantCulture));
 
                     LoginValues[&quot;look_at&quot;] = vector;
                 }
+            }
+            catch (Exception e)
+            {
+                Client.Log(e.ToString(), Helpers.LogLevel.Warning);
+                LoginValues[&quot;look_at&quot;] = null;
+            }
 
+            try
+            {
                 if (LoginValues.ContainsKey(&quot;home&quot;))
                 {
                     Dictionary&lt;string, object&gt; home;
@@ -943,13 +1054,13 @@
 
                     // Create the position vector
                     JSONArray array = (JSONArray)jsonObject[&quot;position&quot;];
-                    posVector = new LLVector3(Convert.ToSingle(array[0]), Convert.ToSingle(array[1]),
-                        Convert.ToSingle(array[2]));
+                    posVector = new LLVector3(Convert.ToSingle(array[0], CultureInfo.InvariantCulture), Convert.ToSingle(array[1], CultureInfo.InvariantCulture),
+                        Convert.ToSingle(array[2], CultureInfo.InvariantCulture));
 
                     // Create the look_at vector
                     array = (JSONArray)jsonObject[&quot;look_at&quot;];
-                    lookatVector = new LLVector3(Convert.ToSingle(array[0]),
-                        Convert.ToSingle(array[1]), Convert.ToSingle(array[2]));
+                    lookatVector = new LLVector3(Convert.ToSingle(array[0], CultureInfo.InvariantCulture),
+                        Convert.ToSingle(array[1], CultureInfo.InvariantCulture), Convert.ToSingle(array[2], CultureInfo.InvariantCulture));
 
                     // Create the regionhandle
                     array = (JSONArray)jsonObject[&quot;region_handle&quot;];
@@ -959,13 +1070,21 @@
                     Client.Self.LookAt = lookatVector;
 
                     // Create a dictionary to hold the home values
-                    home = new Dictionary&lt;string,object&gt;();
+                    home = new Dictionary&lt;string, object&gt;();
                     home[&quot;position&quot;] = posVector;
                     home[&quot;look_at&quot;] = lookatVector;
                     home[&quot;region_handle&quot;] = regionHandle;
                     LoginValues[&quot;home&quot;] = home;
                 }
+            }
+            catch (Exception e)
+            {
+                Client.Log(e.ToString(), Helpers.LogLevel.Warning);
+                LoginValues[&quot;home&quot;] = null;
+            }
 
+            try
+            {
                 this.AgentID = new LLUUID((string)LoginValues[&quot;agent_id&quot;]);
                 this.SessionID = new LLUUID((string)LoginValues[&quot;session_id&quot;]);
                 Client.Self.ID = this.AgentID;
@@ -980,6 +1099,7 @@
                     IPAddress.Parse((string)LoginValues[&quot;sim_ip&quot;]), (int)LoginValues[&quot;sim_port&quot;]);
                 if (!simulator.Connected)
                 {
+                    LoginError = &quot;Unable to connect to the simulator&quot;;
                     return false;
                 }
 
@@ -996,6 +1116,7 @@
 
                 DisconnectTimer.Start();
                 connected = true;
+                if (OnConnected != null) OnConnected(this.Client);
                 return true;
             }
             catch (Exception e)
@@ -1003,7 +1124,7 @@
                 Client.Log(&quot;Login error: &quot; + e.ToString(), Helpers.LogLevel.Error);
                 return false;
             }
-		}
+        }
 
         /// &lt;summary&gt;
         /// 
@@ -1013,14 +1134,14 @@
         /// &lt;param name=&quot;circuitCode&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;setDefault&quot;&gt;&lt;/param&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
-		public Simulator Connect(IPAddress ip, ushort port, uint circuitCode, bool setDefault)
-		{
-			Simulator simulator = new Simulator(Client, this.Callbacks, circuitCode, ip, (int)port);
+        public Simulator Connect(IPAddress ip, ushort port, uint circuitCode, bool setDefault)
+        {
+            Simulator simulator = new Simulator(Client, this.Callbacks, circuitCode, ip, (int)port);
 
-			if (!simulator.Connected)
-			{
+            if (!simulator.Connected)
+            {
                 simulator = null;
-				return null;
+                return null;
             }
 
             lock (Simulators)
@@ -1029,19 +1150,19 @@
             }
 
             if (setDefault)
-			{
-				CurrentSim = simulator;
-			}
+            {
+                CurrentSim = simulator;
+            }
 
             DisconnectTimer.Start();
             connected = true;
-			return simulator;
-		}
+            return simulator;
+        }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
-		public void Logout()
+        public void Logout()
         {
             // This will catch a Logout when the client is not logged in
             if (CurrentSim == null || !connected)
@@ -1059,10 +1180,10 @@
             logout.AgentData.AgentID = AgentID;
             logout.AgentData.SessionID = SessionID;
 
-			CurrentSim.SendPacket(logout, true);
+            CurrentSim.SendPacket(logout, true);
 
             // TODO: We should probably check if the server actually received the logout request
-            
+
             // Shutdown the network layer
             Shutdown();
 
@@ -1070,7 +1191,7 @@
             {
                 OnDisconnected(DisconnectType.ClientInitiated, &quot;&quot;);
             }
-		}
+        }
 
         /// &lt;summary&gt;
         /// 
@@ -1098,6 +1219,8 @@
         /// &lt;/summary&gt;
         private void Shutdown()
         {
+            Client.Log(&quot;NetworkManager shutdown initiated&quot;, Helpers.LogLevel.Info);
+
             lock (Simulators)
             {
                 // Disconnect all simulators except the current one
@@ -1128,48 +1251,18 @@
             // Request the economy data
             SendPacket(new EconomyDataRequestPacket());
 
-            // TODO: The client sends this early in the login sequence, should we?
-            //ViewerEffectPacket effect = new ViewerEffectPacket();
-            //effect.Effect = new ViewerEffectPacket.EffectBlock[1];
-            //effect.Effect[0] = new ViewerEffectPacket.EffectBlock();
-            //effect.Effect[0].Color = new byte[] { 0xFF, 0xFF, 0xFF, 0xFF };
-            //effect.Effect[0].Duration = 0.5f;
-            //effect.Effect[0].ID = new LLUUID(&quot;c696075e53c6153f3d8e0c3e24541936&quot;);
-            //effect.Effect[0].Type = 9;
-            //effect.Effect[0].TypeData = new byte[56];
-            //Array.Copy(new byte[] { 0x28, 0xF0, 0x10, 0x41 }, 0, effect.Effect[0].TypeData, 36, 4);
-            //Array.Copy(new byte[] { 0x50, 0xD0, 0x0E, 0x41 }, 0, effect.Effect[0].TypeData, 44, 4);
-            //Array.Copy(new byte[] { 0x24, 0x40 }, 0, effect.Effect[0].TypeData, 54, 2);
-            //effect.Header.Reliable = false;
-            //SendPacket(effect);
-
-            // TODO: Is this throttle necessary/good, and what does it do?
-            AgentThrottlePacket throttle = new AgentThrottlePacket();
-            throttle.AgentData.AgentID = this.AgentID;
-            throttle.AgentData.SessionID = this.SessionID;
-            throttle.AgentData.CircuitCode = this.CurrentSim.CircuitCode;
-            throttle.Throttle.GenCounter = 0;
-            throttle.Throttle.Throttles = new byte[] 
-                { 0x00, 0x00, 0x96, 0x47, 0x00, 0x00, 0xAA, 0x47, 0x00, 0x00, 0x88, 0x46, 0x00, 0x00, 0x88, 0x46, 
-                  0x00, 0x00, 0x5F, 0x48, 0x00, 0x00, 0x5F, 0x48, 0x00, 0x00, 0xDC, 0x47 };
-            SendPacket(throttle);
-
             // TODO: We should be setting the initial avatar height/width around here 
             //Client.Avatar.SetHeightWidth(676, 909);
 
             // Set the initial avatar camera position
-            Client.Self.UpdateCamera(true);
+            Avatar.AgentUpdateFlags controlFlags = Avatar.AgentUpdateFlags.AGENT_CONTROL_FINISH_ANIM;
+            LLVector3 position = new LLVector3(128, 128, 32);
+            LLVector3 forwardAxis = new LLVector3(0, 0.999999f, 0);
+            LLVector3 leftAxis = new LLVector3(0.999999f, 0, 0);
+            LLVector3 upAxis = new LLVector3(0, 0, 0.999999f);
+            Client.Self.UpdateCamera(controlFlags, position, forwardAxis, leftAxis, upAxis, LLQuaternion.Identity,
+                LLQuaternion.Identity, 384.0f, true);
 
-            // TODO: What animation are we stopping here?
-            //AgentAnimationPacket animation = new AgentAnimationPacket();
-            //animation.AgentData.AgentID = AgentID;
-            //animation.AgentData.SessionID = SessionID;
-            //animation.AnimationList = new AgentAnimationPacket.AnimationListBlock[1];
-            //animation.AnimationList[0] = new AgentAnimationPacket.AnimationListBlock();
-            //animation.AnimationList[0].AnimID = new LLUUID(&quot;efcf670c2d188128973a034ebc806b67&quot;);
-            //animation.AnimationList[0].StartAnim = false;
-            //SendPacket(animation);
-
             // TODO: Do we ever want to set this to true?
             SetAlwaysRunPacket run = new SetAlwaysRunPacket();
             run.AgentData.AgentID = AgentID;
@@ -1188,7 +1281,7 @@
             MoneyBalanceRequestPacket money = new MoneyBalanceRequestPacket();
             money.AgentData.AgentID = AgentID;
             money.AgentData.SessionID = SessionID;
-            money.MoneyData.TransactionID = new LLUUID();
+            money.MoneyData.TransactionID = LLUUID.Zero;
             SendPacket(money);
 
             // FIXME: MainAvatar can request the info if it wants to use it
@@ -1196,16 +1289,17 @@
             //update.AgentData.AgentID = AgentID;
             //update.AgentData.SessionID = SessionID;
             //SendPacket(update);
-
-            // TODO: What is the purpose of this? Information is currently unused
-            RequestGrantedProxiesPacket proxies = new RequestGrantedProxiesPacket();
-            proxies.AgentData.AgentID = AgentID;
-            proxies.AgentData.SessionID = SessionID;
-            SendPacket(proxies);
         }
 
         private void DisconnectTimer_Elapsed(object sender, ElapsedEventArgs ev)
         {
+            if (CurrentSim == null)
+            {
+                DisconnectTimer.Stop();
+                connected = false;
+                return;
+            }
+
             // If the current simulator is disconnected, shutdown+callback+return
             if (CurrentSim.DisconnectCandidate)
             {
@@ -1265,8 +1359,8 @@
             }
         }
 
-		private void StartPingCheckHandler(Packet packet, Simulator simulator)
-		{
+        private void StartPingCheckHandler(Packet packet, Simulator simulator)
+        {
             StartPingCheckPacket incomingPing = (StartPingCheckPacket)packet;
             CompletePingCheckPacket ping = new CompletePingCheckPacket();
             ping.PingID.PingID = incomingPing.PingID.PingID;
@@ -1274,10 +1368,10 @@
             // TODO: We can use OldestUnacked to correct transmission errors
 
             SendPacket((Packet)ping, simulator);
-		}
+        }
 
-		private void RegionHandshakeHandler(Packet packet, Simulator simulator)
-		{
+        private void RegionHandshakeHandler(Packet packet, Simulator simulator)
+        {
             // Send a RegionHandshakeReply
             RegionHandshakeReplyPacket reply = new RegionHandshakeReplyPacket();
             reply.AgentData.AgentID = AgentID;
@@ -1318,10 +1412,10 @@
             simulator.Region.WaterHeight = handshake.RegionInfo.WaterHeight;
 
             Client.Log(&quot;Received a region handshake for &quot; + simulator.Region.Name, Helpers.LogLevel.Info);
-		}
+        }
 
-		private void ParcelOverlayHandler(Packet packet, Simulator simulator)
-		{
+        private void ParcelOverlayHandler(Packet packet, Simulator simulator)
+        {
             ParcelOverlayPacket overlay = (ParcelOverlayPacket)packet;
 
             if (overlay.ParcelData.SequenceID &gt;= 0 &amp;&amp; overlay.ParcelData.SequenceID &lt;= 3)
@@ -1338,21 +1432,21 @@
             }
             else
             {
-                Client.Log(&quot;Parcel overlay with sequence ID of &quot; + overlay.ParcelData.SequenceID + 
+                Client.Log(&quot;Parcel overlay with sequence ID of &quot; + overlay.ParcelData.SequenceID +
                     &quot; received from &quot; + simulator.Region.Name, Helpers.LogLevel.Warning);
             }
-		}
+        }
 
-		private void EnableSimulatorHandler(Packet packet, Simulator simulator)
-		{
-			// TODO: Actually connect to the simulator
+        private void EnableSimulatorHandler(Packet packet, Simulator simulator)
+        {
+            // TODO: Actually connect to the simulator
 
-			// TODO: Sending ConfirmEnableSimulator completely screws things up. :-?
+            // TODO: Sending ConfirmEnableSimulator completely screws things up. :-?
 
-			// Respond to the simulator connection request
-			//Packet replyPacket = Packets.Network.ConfirmEnableSimulator(Protocol, AgentID, SessionID);
-			//SendPacket(replyPacket, circuit);
-		}
+            // Respond to the simulator connection request
+            //Packet replyPacket = Packets.Network.ConfirmEnableSimulator(Protocol, AgentID, SessionID);
+            //SendPacket(replyPacket, circuit);
+        }
 
         private void KickUserHandler(Packet packet, Simulator simulator)
         {
@@ -1366,5 +1460,129 @@
                 OnDisconnected(DisconnectType.ServerInitiated, message);
             }
         }
-	}
+    }
+
+    /// &lt;summary&gt;
+    /// 
+    /// &lt;/summary&gt;
+    public class AgentThrottle
+    {
+        /// &lt;summary&gt;Maximum bytes per second for resending unacknowledged packets&lt;/summary&gt;
+        public float Resend;
+        /// &lt;summary&gt;Maximum bytes per second for LayerData terrain&lt;/summary&gt;
+        public float Land;
+        /// &lt;summary&gt;Maximum bytes per second for LayerData wind data&lt;/summary&gt;
+        public float Wind;
+        /// &lt;summary&gt;Maximum bytes per second for LayerData clouds&lt;/summary&gt;
+        public float Cloud;
+        /// &lt;summary&gt;Unknown, includes object data&lt;/summary&gt;
+        public float Task;
+        /// &lt;summary&gt;Maximum bytes per second for textures&lt;/summary&gt;
+        public float Texture;
+        /// &lt;summary&gt;Maximum bytes per second for downloaded assets&lt;/summary&gt;
+        public float Asset;
+
+        /// &lt;summary&gt;Maximum bytes per second the entire connection, divided up
+        /// between invidiual streams using default multipliers&lt;/summary&gt;
+        public float Total
+        {
+            get { return Resend + Land + Wind + Cloud + Task + Texture + Asset; }
+            set
+            {
+                // These sane initial values were pulled from the Second Life client
+                Resend = (value * 0.1f);
+                Land = (float)(value * 0.52f / 3f);
+                Wind = (float)(value * 0.05f);
+                Cloud = (float)(value * 0.05f);
+                Task = (float)(value * 0.704f / 3f);
+                Texture = (float)(value * 0.704f / 3f);
+                Asset = (float)(value * 0.484f / 3f);
+            }
+        }
+
+        private SecondLife Client;
+
+        /// &lt;summary&gt;
+        /// Default constructor, uses a default high total of 1500 KBps (1536000)
+        /// &lt;/summary&gt;
+        public AgentThrottle(SecondLife client)
+        {
+            Client = client;
+            Total = 1536000.0f;
+        }
+
+        /// &lt;summary&gt;
+        /// Sets the total KBps throttle
+        /// &lt;param name=&quot;total&quot;&gt;The total kilobytes per second for the connection.
+        /// This will be divided up between the various stream types using the 
+        /// default multipliers&lt;/param&gt;
+        /// &lt;/summary&gt;
+        public AgentThrottle(SecondLife client, float total)
+        {
+            Client = client;
+            // Note that the client itself never seems to go below 75k, even if you tell it to
+            Total = total;
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;pos&quot;&gt;&lt;/param&gt;
+        public AgentThrottle(byte[] data, int pos)
+        {
+            int i;
+            if (!BitConverter.IsLittleEndian)
+                for (i = 0; i &lt; 7; i++)
+                    Array.Reverse(data, pos + i * 4, 4);
+
+            Resend = BitConverter.ToSingle(data, pos); pos += 4;
+            Land = BitConverter.ToSingle(data, pos); pos += 4;
+            Wind = BitConverter.ToSingle(data, pos); pos += 4;
+            Cloud = BitConverter.ToSingle(data, pos); pos += 4;
+            Task = BitConverter.ToSingle(data, pos); pos += 4;
+            Texture = BitConverter.ToSingle(data, pos); pos += 4;
+            Asset = BitConverter.ToSingle(data, pos);
+        }
+
+        /// &lt;summary&gt;
+        /// Send an AgentThrottle packet to the server using the current values
+        /// &lt;/summary&gt;
+        public void Set()
+        {
+            AgentThrottlePacket throttle = new AgentThrottlePacket();
+            throttle.AgentData.AgentID = Client.Network.AgentID;
+            throttle.AgentData.SessionID = Client.Network.SessionID;
+            throttle.AgentData.CircuitCode = Client.Network.CurrentSim.CircuitCode;
+            throttle.Throttle.GenCounter = 0;
+            throttle.Throttle.Throttles = this.ToBytes();
+
+            Client.Network.SendPacket(throttle);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public byte[] ToBytes()
+        {
+            byte[] data = new byte[7 * 4];
+            int i = 0;
+
+            BitConverter.GetBytes(Resend).CopyTo(data, i); i += 4;
+            BitConverter.GetBytes(Land).CopyTo(data, i); i += 4;
+            BitConverter.GetBytes(Wind).CopyTo(data, i); i += 4;
+            BitConverter.GetBytes(Cloud).CopyTo(data, i); i += 4;
+            BitConverter.GetBytes(Task).CopyTo(data, i); i += 4;
+            BitConverter.GetBytes(Texture).CopyTo(data, i); i += 4;
+            BitConverter.GetBytes(Asset).CopyTo(data, i); i += 4;
+
+            if (!BitConverter.IsLittleEndian)
+                for (i = 0; i &lt; 7; i++)
+                    Array.Reverse(data, i * 4, 4);
+
+            return data;
+        }
+    }
+
 }

Modified: branches/aditi/libsecondlife-cs/ObjectManager.cs
===================================================================
--- branches/aditi/libsecondlife-cs/ObjectManager.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/ObjectManager.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -26,50 +26,12 @@
 
 using System;
 using System.Collections.Generic;
+using System.Text;
 using libsecondlife.Packets;
 
 namespace libsecondlife
 {
     /// &lt;summary&gt;
-    /// 
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;prim&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;timeDilation&quot;&gt;&lt;/param&gt;
-    public delegate void NewPrimCallback(Simulator simulator, PrimObject prim, ulong regionHandle, ushort timeDilation);
-    /// &lt;summary&gt;
-    /// 
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;avatar&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;timeDilation&quot;&gt;&lt;/param&gt;
-    public delegate void NewAvatarCallback(Simulator simulator, Avatar avatar, ulong regionHandle, ushort timeDilation);
-    /// &lt;summary&gt;
-    /// 
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;prim&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;timeDilation&quot;&gt;&lt;/param&gt;
-    public delegate void PrimMovedCallback(Simulator simulator, PrimUpdate prim, ulong regionHandle, ushort timeDilation);
-    /// &lt;summary&gt;
-    /// 
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;avatar&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;timeDilation&quot;&gt;&lt;/param&gt;
-    public delegate void AvatarMovedCallback(Simulator simulator, AvatarUpdate avatar, ulong regionHandle, ushort timeDilation);
-    /// &lt;summary&gt;
-    /// 
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;objectID&quot;&gt;&lt;/param&gt;
-    public delegate void KillObjectCallback(Simulator simulator, uint objectID);
-
-    /// &lt;summary&gt;
     /// Contains all of the variables sent in an object update packet for a 
     /// prim object. Used to track position and movement of prims.
     /// &lt;/summary&gt;
@@ -89,6 +51,8 @@
         public LLQuaternion Rotation;
         /// &lt;summary&gt;&lt;/summary&gt;
         public LLVector3 RotationVelocity;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public TextureEntry Textures;
     }
 
     /// &lt;summary&gt;
@@ -113,35 +77,300 @@
         public LLQuaternion Rotation;
         /// &lt;summary&gt;&lt;/summary&gt;
         public LLVector3 RotationVelocity;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public TextureEntry Textures;
     }
 
-	/// &lt;summary&gt;
-	/// Handles all network traffic related to prims and avatar positions and 
+    /// &lt;summary&gt;
+    /// Handles all network traffic related to prims and avatar positions and 
     /// movement.
-	/// &lt;/summary&gt;
-	public class ObjectManager
+    /// &lt;/summary&gt;
+    public class ObjectManager
     {
         /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;prim&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;timeDilation&quot;&gt;&lt;/param&gt;
+        public delegate void NewPrimCallback(Simulator simulator, PrimObject prim, ulong regionHandle,
+            ushort timeDilation);
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;prim&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;timeDilation&quot;&gt;&lt;/param&gt;
+        public delegate void NewAttachmentCallback(Simulator simulator, PrimObject prim, ulong regionHandle,
+            ushort timeDilation);
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;avatar&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;timeDilation&quot;&gt;&lt;/param&gt;
+        public delegate void NewAvatarCallback(Simulator simulator, Avatar avatar, ulong regionHandle,
+            ushort timeDilation);
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;prim&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;timeDilation&quot;&gt;&lt;/param&gt;
+        public delegate void NewFoliageCallback(Simulator simulator, PrimObject foliage, ulong regionHandle,
+            ushort timeDilation);
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;prim&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;timeDilation&quot;&gt;&lt;/param&gt;
+        public delegate void PrimMovedCallback(Simulator simulator, PrimUpdate prim, ulong regionHandle,
+            ushort timeDilation);
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;avatar&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;timeDilation&quot;&gt;&lt;/param&gt;
+        public delegate void AvatarMovedCallback(Simulator simulator, AvatarUpdate avatar, ulong regionHandle,
+            ushort timeDilation);
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;objectID&quot;&gt;&lt;/param&gt;
+        public delegate void KillObjectCallback(Simulator simulator, uint objectID);
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        public enum PCode
+        {
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Prim = 9,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Avatar = 47,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Grass = 95,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            NewTree = 111,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            ParticleSystem = 143,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Tree = 255
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        public enum AttachmentPoint
+        {
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Chest = 1,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Skull,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftShoulder,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightShoulder,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftHand,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightHand,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftFoot,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightFoot,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Spine,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Pelvis,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Mouth,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Chin,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftEar,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightEar,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftEyeball,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightEyeball,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Nose,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightUpperArm,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightForarm,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftUpperArm,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftForearm,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightHip,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightUpperLeg,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightLowerLeg,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftHip,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftUpperLeg,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftLowerLeg,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Stomach,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            LeftPec,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            RightPec
+        }
+
+        /// &lt;summary&gt;
+        /// Bitflag field for ObjectUpdateCompressed data blocks, describing 
+        /// which options are present for each object
+        /// &lt;/summary&gt;
+        [Flags]
+        public enum CompressedFlags
+        {
+            /// &lt;summary&gt;Hasn't been spotted in the wild yet&lt;/summary&gt;
+            Unknown1 = 0x01,
+            /// &lt;summary&gt;This may be incorrect&lt;/summary&gt;
+            Tree = 0x02,
+            /// &lt;summary&gt;Whether the object has floating text ala llSetText&lt;/summary&gt;
+            HasText = 0x04,
+            /// &lt;summary&gt;Whether the object has an active particle system&lt;/summary&gt;
+            HasParticles = 0x08,
+            /// &lt;summary&gt;Whether the object has sound attached to it&lt;/summary&gt;
+            HasSound = 0x10,
+            /// &lt;summary&gt;Whether the object is attached to a root object or not&lt;/summary&gt;
+            HasParent = 0x20,
+            /// &lt;summary&gt;Semi-common flag, currently unknown&lt;/summary&gt;
+            Unknown2 = 0x40,
+            /// &lt;summary&gt;Whether the object has an angular velocity&lt;/summary&gt;
+            HasAngularVelocity = 0x80,
+            /// &lt;summary&gt;Whether the object is an attachment or not&lt;/summary&gt;
+            Attachment = 0x100
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        public enum Tree
+        {
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Pine1 = 0,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Oak,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            TropicalBush1,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Palm1,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Dogwood,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            TropicalBush2,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Palm2,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Cypress1,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Cypress2,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Pine2,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Plumeria,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            WinterPine1,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            WinterAspen,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            WinterPine2,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Eucalyptus,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Fern,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Eelgrass,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            SeaSword,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Kelp1,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            BeachGrass1,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Kelp2
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        public enum Grass
+        {
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Grass0 = 0,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Grass1,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Grass2,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Grass3,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Grass4,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            undergrowth_1
+        }
+
+        /// &lt;summary&gt;
         /// This event will be raised for every ObjectUpdate block that 
-        /// contains a new prim.
+        /// contains a prim that isn't attached to an avatar.
+        /// &lt;/summary&gt;
         /// &lt;remarks&gt;Depending on the circumstances a client could 
         /// receive two or more of these events for the same object, if you 
         /// or the object left the current sim and returned for example. Client
         /// applications are responsible for tracking and storing objects.
         /// &lt;/remarks&gt;
-        /// &lt;/summary&gt;
         public event NewPrimCallback OnNewPrim;
         /// &lt;summary&gt;
         /// This event will be raised for every ObjectUpdate block that 
+        /// contains an avatar attachment.
+        /// &lt;/summary&gt;
+        /// &lt;remarks&gt;Depending on the circumstances a client could 
+        /// receive two or more of these events for the same object, if you 
+        /// or the object left the current sim and returned for example. Client
+        /// applications are responsible for tracking and storing objects.
+        /// &lt;/remarks&gt;
+        public event NewAttachmentCallback OnNewAttachment;
+        /// &lt;summary&gt;
+        /// This event will be raised for every ObjectUpdate block that 
         /// contains a new avatar.
+        /// &lt;/summary&gt;
         /// &lt;remarks&gt;Depending on the circumstances a client 
         /// could receive two or more of these events for the same avatar, if 
         /// you or the other avatar left the current sim and returned for 
         /// example. Client applications are responsible for tracking and 
-        /// storing objects.&lt;/remarks&gt;
-        /// &lt;/summary&gt;
+        /// storing objects.
+        /// &lt;/remarks&gt;
         public event NewAvatarCallback OnNewAvatar;
         /// &lt;summary&gt;
+        /// This event will be raised for every ObjectUpdate block that 
+        /// contains a new tree or grass patch.
+        /// &lt;/summary&gt;
+        /// &lt;remarks&gt;Depending on the circumstances a client could 
+        /// receive two or more of these events for the same object, if you 
+        /// or the object left the current sim and returned for example. Client
+        /// applications are responsible for tracking and storing objects.
+        /// &lt;/remarks&gt;
+        public event NewFoliageCallback OnNewFoliage;
+        /// &lt;summary&gt;
         /// This event will be raised when a prim movement packet is received, 
         /// containing the updated position, rotation, and movement-related 
         /// vectors.
@@ -158,24 +387,37 @@
         /// simulator.
         /// &lt;/summary&gt;
         public event KillObjectCallback OnObjectKilled;
+        /// &lt;summary&gt;
+        /// If true, when a cached object check is received from the server 
+        /// the full object info will automatically be requested.
+        /// &lt;/summary&gt;
+        public bool RequestAllObjects = false;
 
         private SecondLife Client;
 
         /// &lt;summary&gt;
-        /// 
+        /// Instantiates a new ObjectManager class. This class should only be accessed
+        /// through SecondLife.Objects, client applications should never create their own
         /// &lt;/summary&gt;
-        /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;client&quot;&gt;A reference to the client&lt;/param&gt;
         public ObjectManager(SecondLife client)
         {
             Client = client;
 
-            Client.Network.RegisterCallback(PacketType.ObjectUpdate, new PacketCallback(UpdateHandler));
-            Client.Network.RegisterCallback(PacketType.ImprovedTerseObjectUpdate, new PacketCallback(TerseUpdateHandler));
-            Client.Network.RegisterCallback(PacketType.ObjectUpdateCompressed, new PacketCallback(CompressedUpdateHandler));
-            Client.Network.RegisterCallback(PacketType.ObjectUpdateCached, new PacketCallback(CachedUpdateHandler));
-            Client.Network.RegisterCallback(PacketType.KillObject, new PacketCallback(KillObjectHandler));
+            Client.Network.RegisterCallback(PacketType.ObjectUpdate, new NetworkManager.PacketCallback(UpdateHandler));
+            Client.Network.RegisterCallback(PacketType.ImprovedTerseObjectUpdate, new NetworkManager.PacketCallback(TerseUpdateHandler));
+            Client.Network.RegisterCallback(PacketType.ObjectUpdateCompressed, new NetworkManager.PacketCallback(CompressedUpdateHandler));
+            Client.Network.RegisterCallback(PacketType.ObjectUpdateCached, new NetworkManager.PacketCallback(CachedUpdateHandler));
+            Client.Network.RegisterCallback(PacketType.KillObject, new NetworkManager.PacketCallback(KillObjectHandler));
         }
 
+        /// &lt;summary&gt;
+        /// Request object information from the sim, primarily used for stale 
+        /// or missing cache entries
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;The simulator containing the object you're 
+        /// looking for&lt;/param&gt;
+        /// &lt;param name=&quot;localID&quot;&gt;The local ID of the object&lt;/param&gt;
         public void RequestObject(Simulator simulator, uint localID)
         {
             RequestMultipleObjectsPacket request = new RequestMultipleObjectsPacket();
@@ -189,6 +431,13 @@
             Client.Network.SendPacket(request, simulator);
         }
 
+        /// &lt;summary&gt;
+        /// Request object information for multiple objects all contained in
+        /// the same sim, primarily used for stale or missing cache entries
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;The simulator containing the object you're 
+        /// looking for&lt;/param&gt;
+        /// &lt;param name=&quot;localIDs&quot;&gt;A list of local IDs of the objects&lt;/param&gt;
         public void RequestObjects(Simulator simulator, List&lt;uint&gt; localIDs)
         {
             int i = 0;
@@ -210,8 +459,283 @@
             Client.Network.SendPacket(request, simulator);
         }
 
+        /// &lt;summary&gt;
+        /// Create, or &quot;rez&quot; a new prim object in a simulator
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;The target simulator&lt;/param&gt;
+        /// &lt;param name=&quot;prim&quot;&gt;The prim object to rez&lt;/param&gt;
+        /// &lt;param name=&quot;nearPosition&quot;&gt;An approximation of the position to rez
+        /// the prim at&lt;/param&gt;
+        /// &lt;remarks&gt;Due to the way client prim rezzing is done on the server,
+        /// the requested position for an object is only close to where the prim
+        /// actually ends up. If you desire exact placement you'll need to 
+        /// follow up by moving the object after it has been created.&lt;/remarks&gt;
+        public void AddPrim(Simulator simulator, PrimObject prim, LLVector3 position)
+        {
+            ObjectAddPacket packet = new ObjectAddPacket();
+
+            packet.AgentData.AgentID = Client.Network.AgentID;
+            packet.AgentData.SessionID = Client.Network.SessionID;
+            packet.AgentData.GroupID = prim.GroupID;
+
+            packet.ObjectData.State = (byte)prim.State;
+            packet.ObjectData.AddFlags = (uint)ObjectFlags.CreateSelected;
+            packet.ObjectData.PCode = (byte)PCode.Prim;
+
+            packet.ObjectData.Material = (byte)prim.Material;
+            packet.ObjectData.Scale = prim.Scale;
+            packet.ObjectData.Rotation = prim.Rotation;
+
+            packet.ObjectData.PathBegin = PrimObject.PathBeginByte(prim.PathBegin);
+            packet.ObjectData.PathCurve = (byte)prim.PathCurve;
+            packet.ObjectData.PathEnd = PrimObject.PathEndByte(prim.PathEnd);
+            packet.ObjectData.PathRadiusOffset = PrimObject.PathRadiusOffsetByte(prim.PathRadiusOffset);
+            packet.ObjectData.PathRevolutions = PrimObject.PathRevolutionsByte(prim.PathRevolutions);
+            packet.ObjectData.PathScaleX = PrimObject.PathScaleByte(prim.PathScaleX);
+            packet.ObjectData.PathScaleY = PrimObject.PathScaleByte(prim.PathScaleY);
+            packet.ObjectData.PathShearX = PrimObject.PathShearByte(prim.PathShearX);
+            packet.ObjectData.PathShearY = PrimObject.PathShearByte(prim.PathShearY);
+            packet.ObjectData.PathSkew = PrimObject.PathSkewByte(prim.PathSkew);
+            packet.ObjectData.PathTaperX = PrimObject.PathTaperByte(prim.PathTaperX);
+            packet.ObjectData.PathTaperY = PrimObject.PathTaperByte(prim.PathTaperY);
+            packet.ObjectData.PathTwist = (sbyte)prim.PathTwist;
+            packet.ObjectData.PathTwistBegin = (sbyte)prim.PathTwistBegin;
+
+            packet.ObjectData.ProfileCurve = (byte)prim.ProfileCurve;
+            packet.ObjectData.ProfileBegin = PrimObject.ProfileBeginByte(prim.ProfileBegin);
+            packet.ObjectData.ProfileEnd = PrimObject.ProfileEndByte(prim.ProfileEnd);
+            packet.ObjectData.ProfileHollow = (byte)prim.ProfileHollow;
+
+            packet.ObjectData.RayStart = position;
+            packet.ObjectData.RayEnd = position;
+            packet.ObjectData.RayEndIsIntersection = 0;
+            packet.ObjectData.RayTargetID = LLUUID.Zero;
+            packet.ObjectData.BypassRaycast = 1;
+
+            // TODO: This is no longer a field in ObjectAdd. Detect if there actually is 
+            // texture information for this prim and send an ObjectUpdate
+            //packet.ObjectData.TextureEntry = prim.Textures.GetBytes();
+
+            Client.Network.SendPacket(packet, simulator);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;scale&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;rotation&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;treeType&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;groupOwner&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;newTree&quot;&gt;&lt;/param&gt;
+        public void AddTree(Simulator simulator, LLVector3 scale, LLQuaternion rotation, LLVector3 position, 
+            Tree treeType, LLUUID groupOwner, bool newTree)
+        {
+            ObjectAddPacket add = new ObjectAddPacket();
+
+            add.AgentData.AgentID = Client.Network.AgentID;
+            add.AgentData.SessionID = Client.Network.SessionID;
+            add.AgentData.GroupID = groupOwner;
+            add.ObjectData.BypassRaycast = 1;
+            add.ObjectData.Material = 3;
+            add.ObjectData.PathCurve = 16;
+            add.ObjectData.PCode = newTree ? (byte)PCode.NewTree : (byte)PCode.Tree;
+            add.ObjectData.RayEnd = position;
+            add.ObjectData.RayStart = position;
+            add.ObjectData.RayTargetID = LLUUID.Zero;
+            add.ObjectData.Rotation = rotation;
+            add.ObjectData.Scale = scale;
+            add.ObjectData.State = (byte)treeType;
+            add.ObjectData.TextureEntry = new byte[0];
+
+            Client.Network.SendPacket(add, simulator);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;scale&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;rotation&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;grassType&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;groupOwner&quot;&gt;&lt;/param&gt;
+        public void AddGrass(Simulator simulator, LLVector3 scale, LLQuaternion rotation, LLVector3 position,
+            Grass grassType, LLUUID groupOwner)
+        {
+            ObjectAddPacket add = new ObjectAddPacket();
+
+            add.AgentData.AgentID = Client.Network.AgentID;
+            add.AgentData.SessionID = Client.Network.SessionID;
+            add.AgentData.GroupID = groupOwner;
+            add.ObjectData.BypassRaycast = 1;
+            add.ObjectData.Material = 3;
+            add.ObjectData.PathCurve = 16;
+            add.ObjectData.PCode = (byte)PCode.Grass;
+            add.ObjectData.RayEnd = position;
+            add.ObjectData.RayStart = position;
+            add.ObjectData.RayTargetID = LLUUID.Zero;
+            add.ObjectData.Rotation = rotation;
+            add.ObjectData.Scale = scale;
+            add.ObjectData.State = (byte)grassType;
+            add.ObjectData.TextureEntry = new byte[0];
+
+            Client.Network.SendPacket(add, simulator);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;localIDs&quot;&gt;&lt;/param&gt;
+        public void LinkPrims(Simulator simulator, List&lt;uint&gt; localIDs)
+        {
+            ObjectLinkPacket packet = new ObjectLinkPacket();
+
+            packet.AgentData.AgentID = Client.Network.AgentID;
+            packet.AgentData.SessionID = Client.Network.SessionID;
+
+            packet.ObjectData = new ObjectLinkPacket.ObjectDataBlock[localIDs.Count];
+
+            int i = 0;
+            foreach (uint localID in localIDs)
+            {
+                packet.ObjectData[i] = new ObjectLinkPacket.ObjectDataBlock();
+                packet.ObjectData[i].ObjectLocalID = localID;
+
+                i++;
+            }
+
+            Client.Network.SendPacket(packet, simulator);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;localID&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;rotation&quot;&gt;&lt;/param&gt;
+        public void SetRotation(Simulator simulator, uint localID, LLQuaternion rotation)
+        {
+            ObjectRotationPacket objRotPacket = new ObjectRotationPacket();
+            objRotPacket.AgentData.AgentID = Client.Network.AgentID;
+            objRotPacket.AgentData.SessionID = Client.Network.SessionID;
+
+            objRotPacket.ObjectData = new ObjectRotationPacket.ObjectDataBlock[1];
+
+            objRotPacket.ObjectData[0] = new ObjectRotationPacket.ObjectDataBlock();
+            objRotPacket.ObjectData[0].ObjectLocalID = localID;
+            objRotPacket.ObjectData[0].Rotation = rotation;
+            Client.Network.SendPacket(objRotPacket, simulator);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;localID&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;attachPoint&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;rotation&quot;&gt;&lt;/param&gt;
+        public void AttachObject(Simulator simulator, uint localID, AttachmentPoint attachPoint, LLQuaternion rotation)
+        {
+            ObjectAttachPacket attach = new ObjectAttachPacket();
+            attach.AgentData.AgentID = Client.Network.AgentID;
+            attach.AgentData.SessionID = Client.Network.SessionID;
+            attach.AgentData.AttachmentPoint = (byte)attachPoint;
+
+            attach.ObjectData = new ObjectAttachPacket.ObjectDataBlock[1];
+            attach.ObjectData[0] = new ObjectAttachPacket.ObjectDataBlock();
+            attach.ObjectData[0].ObjectLocalID = localID;
+            attach.ObjectData[0].Rotation = rotation;
+
+            Client.Network.SendPacket(attach, simulator);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;localIDs&quot;&gt;&lt;/param&gt;
+        public void DetachObjects(Simulator simulator, List&lt;uint&gt; localIDs)
+        {
+            ObjectDetachPacket detach = new ObjectDetachPacket();
+            detach.AgentData.AgentID = Client.Network.AgentID;
+            detach.AgentData.SessionID = Client.Network.SessionID;
+            detach.ObjectData = new ObjectDetachPacket.ObjectDataBlock[localIDs.Count];
+
+            int i = 0;
+            foreach (uint localid in localIDs)
+            {
+                detach.ObjectData[i] = new ObjectDetachPacket.ObjectDataBlock();
+                detach.ObjectData[i].ObjectLocalID = localid;
+                i++;
+            }
+
+            Client.Network.SendPacket(detach, simulator);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;localID&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
+        public void SetPosition(Simulator simulator, uint localID, LLVector3 position)
+        {
+            ObjectPositionPacket objPosPacket = new ObjectPositionPacket();
+            objPosPacket.AgentData.AgentID = Client.Self.ID;
+            objPosPacket.AgentData.SessionID = Client.Network.SessionID;
+
+            objPosPacket.ObjectData = new ObjectPositionPacket.ObjectDataBlock[1];
+
+            objPosPacket.ObjectData[0] = new ObjectPositionPacket.ObjectDataBlock();
+            objPosPacket.ObjectData[0].ObjectLocalID = localID;
+            objPosPacket.ObjectData[0].Position = position;
+
+            Client.Network.SendPacket(objPosPacket, simulator);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;localIDs&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;who&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;permissions&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;set&quot;&gt;&lt;/param&gt;
+        public void SetPermissions(Simulator simulator, List&lt;uint&gt; localIDs, Helpers.PermissionWho who, 
+            Helpers.PermissionType permissions, bool set)
+        {
+            ObjectPermissionsPacket packet = new ObjectPermissionsPacket();
+
+            packet.AgentData.AgentID = Client.Network.AgentID;
+            packet.AgentData.SessionID = Client.Network.SessionID;
+
+            packet.HeaderData.Override = false;
+
+            packet.ObjectData = new ObjectPermissionsPacket.ObjectDataBlock[localIDs.Count];
+
+            int i = 0;
+            foreach (uint localID in localIDs)
+            {
+                packet.ObjectData[i] = new ObjectPermissionsPacket.ObjectDataBlock();
+                packet.ObjectData[i].ObjectLocalID = localID;
+                packet.ObjectData[i].Field = (byte)who;
+                packet.ObjectData[i].Mask = (uint)permissions;
+                packet.ObjectData[i].Set = Convert.ToByte(set);
+
+                i++;
+            }
+
+            Client.Network.SendPacket(packet, simulator);
+        }
+
         private void ParseAvName(string name, ref string firstName, ref string lastName, ref string groupName)
         {
+            // FIXME: This needs to be reworked completely. It fails on anything containing unicode
+            // (which would break FieldToString as well), or name strings that don't contain the 
+            // most common attributes which is all we handle right now.
             string[] lines = name.Split('\n');
 
             foreach (string line in lines)
@@ -237,116 +761,143 @@
 
         private void UpdateHandler(Packet packet, Simulator simulator)
         {
-            ObjectUpdatePacket update = (ObjectUpdatePacket)packet;
+            if (OnNewPrim != null || OnNewAttachment != null || OnNewAvatar != null || OnNewFoliage != null)
+            {
+                ObjectUpdatePacket update = (ObjectUpdatePacket)packet;
 
-            foreach (ObjectUpdatePacket.ObjectDataBlock block in update.ObjectData)
-            {
-                if (block.ObjectData.Length == 60)
+                foreach (ObjectUpdatePacket.ObjectDataBlock block in update.ObjectData)
                 {
-                    // New prim spotted
-                    PrimObject prim = new PrimObject(Client);
+                    byte pcode = block.PCode;
+                    switch (pcode)
+                    {
+                        case (byte)PCode.Grass:
+                        case (byte)PCode.Tree:
+                        case (byte)PCode.Prim:
+                            string name = Helpers.FieldToString(block.NameValue);
 
-                    prim.Position = new LLVector3(block.ObjectData, 0);
-                    prim.Rotation = new LLQuaternion(block.ObjectData, 36, true);
+                            // New prim spotted
+                            PrimObject prim = new PrimObject(Client);
 
-                    // TODO: Parse the rest of the ObjectData byte array fields
+                            prim.Name = name;
 
-                    prim.LocalID = block.ID;
-                    prim.State = block.State;
-                    prim.ID = block.FullID;
-                    prim.ParentID = block.ParentID;
-                    //block.OwnerID Sound-related
-                    prim.Material = block.Material;
-                    prim.PathCurve = block.PathCurve;
-                    prim.ProfileCurve = block.ProfileCurve;
-                    prim.PathBegin = PrimObject.PathBeginFloat(block.PathBegin);
-                    prim.PathEnd = PrimObject.PathEndFloat(block.PathEnd);
-                    prim.PathScaleX = PrimObject.PathScaleFloat(block.PathScaleX);
-                    prim.PathScaleY = PrimObject.PathScaleFloat(block.PathScaleY);
-                    prim.PathShearX = PrimObject.PathShearFloat(block.PathShearX);
-                    prim.PathShearY = PrimObject.PathShearFloat(block.PathShearY);
-                    prim.PathTwist = block.PathTwist; //PrimObject.PathTwistFloat(block.PathTwist);
-                    prim.PathTwistBegin = block.PathTwistBegin; //PrimObject.PathTwistFloat(block.PathTwistBegin);
-                    prim.PathRadiusOffset = PrimObject.PathRadiusOffsetFloat(block.PathRadiusOffset);
-                    prim.PathTaperX = PrimObject.PathTaperFloat((byte)block.PathTaperX);
-                    prim.PathTaperY = PrimObject.PathTaperFloat((byte)block.PathTaperY);
-                    prim.PathRevolutions = PrimObject.PathRevolutionsFloat(block.PathRevolutions);
-                    prim.PathSkew = PrimObject.PathSkewFloat((byte)block.PathSkew);
-                    prim.ProfileBegin = PrimObject.ProfileBeginFloat(block.ProfileBegin);
-                    prim.ProfileEnd = PrimObject.ProfileEndFloat(block.ProfileEnd);
-                    prim.ProfileHollow = block.ProfileHollow;
-                    prim.Name = Helpers.FieldToString(block.NameValue);
-                    //block.Data ?
-                    //block.Text Hovering text
-                    //block.TextColor LLColor4U of the hovering text
-                    //block.MediaURL Quicktime stream
-                    prim.Textures = new TextureEntry(Client, block.TextureEntry, 0);
-                    //block.TextureAnim ?
-                    //block.JointType ?
-                    //block.JointPivot ?
-                    //block.JointAxisOrAnchor ?
-                    //block.PCode ?
-                    //block.PSBlock Particle system related
-                    //block.ExtraParams ?
-                    prim.Scale = block.Scale;
-                    //block.Flags ?
-                    //block.UpdateFlags ?
-                    //block.ClickAction ?
-                    //block.Gain Sound-related
-                    //block.Sound Sound-related
-                    //block.Radius Sound-related
+                            prim.Position = new LLVector3(block.ObjectData, 0);
+                            prim.Rotation = new LLQuaternion(block.ObjectData, 36, true);
+                            // TODO: Parse the rest of the ObjectData byte array fields
 
-                    if (OnNewPrim != null)
-                    {
-                        OnNewPrim(simulator, prim, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
-                    }
-                }
-                else if (block.ObjectData.Length == 76)
-                {
-                    // New avatar spotted
-                    Avatar avatar = new Avatar();
-                    string FirstName = &quot;&quot;;
-                    string LastName = &quot;&quot;;
-                    string GroupName = &quot;&quot;;
+                            prim.LocalID = block.ID;
+                            prim.State = block.State;
+                            prim.ID = block.FullID;
+                            prim.ParentID = block.ParentID;
+                            //block.OwnerID Sound-related
+                            prim.Material = block.Material;
+                            prim.PathCurve = block.PathCurve;
+                            prim.ProfileCurve = block.ProfileCurve;
+                            prim.PathBegin = PrimObject.PathBeginFloat(block.PathBegin);
+                            prim.PathEnd = PrimObject.PathEndFloat(block.PathEnd);
+                            prim.PathScaleX = PrimObject.PathScaleFloat(block.PathScaleX);
+                            prim.PathScaleY = PrimObject.PathScaleFloat(block.PathScaleY);
+                            prim.PathShearX = PrimObject.PathShearFloat(block.PathShearX);
+                            prim.PathShearY = PrimObject.PathShearFloat(block.PathShearY);
+                            prim.PathTwist = block.PathTwist;
+                            prim.PathTwistBegin = block.PathTwistBegin;
+                            prim.PathRadiusOffset = PrimObject.PathRadiusOffsetFloat(block.PathRadiusOffset);
+                            prim.PathTaperX = PrimObject.PathTaperFloat(block.PathTaperX);
+                            prim.PathTaperY = PrimObject.PathTaperFloat(block.PathTaperY);
+                            prim.PathRevolutions = PrimObject.PathRevolutionsFloat(block.PathRevolutions);
+                            prim.PathSkew = PrimObject.PathSkewFloat(block.PathSkew);
+                            prim.ProfileBegin = PrimObject.ProfileBeginFloat(block.ProfileBegin);
+                            prim.ProfileEnd = PrimObject.ProfileEndFloat(block.ProfileEnd);
+                            prim.ProfileHollow = block.ProfileHollow;
 
-                    //avatar.CollisionPlane = new LLQuaternion(block.ObjectData, 0);
-                    avatar.Position = new LLVector3(block.ObjectData, 16);
-                    avatar.Rotation = new LLQuaternion(block.ObjectData, 52, true);
+                            //block.Data ?
+                            prim.Text = ASCIIEncoding.ASCII.GetString(block.Text);
+                            //block.TextColor LLColor4U of the hovering text
+                            //block.MediaURL Quicktime stream
+                            prim.Textures = new TextureEntry(block.TextureEntry, 0, block.TextureEntry.Length);
+                            prim.TextureAnim = new TextureAnimation(block.TextureAnim, 0);
+                            //block.JointType ?
+                            //block.JointPivot ?
+                            //block.JointAxisOrAnchor ?
+                            prim.ParticleSys = new ParticleSystem(block.PSBlock, 0);
+                            prim.SetExtraParamsFromBytes(block.ExtraParams, 0);
+                            prim.Scale = block.Scale;
+                            //block.Flags ?
+                            prim.Flags = (ObjectFlags)block.UpdateFlags;
+                            //block.ClickAction ?
+                            //block.Gain Sound-related
+                            //block.Sound Sound-related
+                            //block.Radius Sound-related
 
-                    // TODO: Parse the rest of the ObjectData byte array fields
+                            if (prim.Name.StartsWith(&quot;AttachItemID&quot;))
+                            {
+                                if (OnNewAttachment != null)
+                                {
+                                    OnNewAttachment(simulator, prim, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
+                                }
+                            }
+                            else if (block.PCode == (byte)PCode.Tree || block.PCode == (byte)PCode.Grass)
+                            {
+                                if (OnNewFoliage != null)
+                                {
+                                    OnNewFoliage(simulator, prim, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
+                                }
+                            }
+                            else if (OnNewPrim != null)
+                            {
+                                OnNewPrim(simulator, prim, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
+                            }
 
-                    ParseAvName(Helpers.FieldToString(block.NameValue), ref FirstName, ref LastName, ref GroupName);
+                            break;
+                        case (byte)PCode.Avatar:
+                            if (OnNewAvatar != null)
+                            {
+                                Avatar avatar = new Avatar();
 
-                    avatar.ID = block.FullID;
-                    avatar.LocalID = block.ID;
-                    avatar.Name = FirstName + &quot; &quot; + LastName;
-                    avatar.GroupName = GroupName;
-                    avatar.Online = true;
-                    avatar.CurrentRegion = simulator.Region;
+                                string FirstName = &quot;&quot;;
+                                string LastName = &quot;&quot;;
+                                string GroupName = &quot;&quot;;
 
-                    if (FirstName == Client.Self.FirstName &amp;&amp; LastName == Client.Self.LastName)
-                    {
-                        // Update our avatar
-                        Client.Self.LocalID = avatar.LocalID;
-                        Client.Self.Position = avatar.Position;
-                        Client.Self.Rotation = avatar.Rotation;
-                    }
-                    else
-                    {
-                        Client.Avatars.AddAvatar(avatar);
+                                //avatar.CollisionPlane = new LLQuaternion(block.ObjectData, 0);
+                                avatar.Position = new LLVector3(block.ObjectData, 16);
+                                avatar.Rotation = new LLQuaternion(block.ObjectData, 52, true);
 
-                        if (OnNewAvatar != null)
-                        {
-                            OnNewAvatar(simulator, avatar, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
-                        }
+                                // TODO: Parse the rest of the ObjectData byte array fields
+
+                                ParseAvName(Helpers.FieldToString(block.NameValue), ref FirstName, ref LastName, ref GroupName);
+
+                                avatar.ID = block.FullID;
+                                avatar.LocalID = block.ID;
+                                avatar.Name = FirstName + &quot; &quot; + LastName;
+                                avatar.GroupName = GroupName;
+                                avatar.Online = true;
+                                avatar.CurrentRegion = simulator.Region;
+
+                                avatar.Textures = new TextureEntry(block.TextureEntry, 0, block.TextureEntry.Length);
+
+                                if (FirstName == Client.Self.FirstName &amp;&amp; LastName == Client.Self.LastName)
+                                {
+                                    // Update our avatar
+                                    Client.Self.LocalID = avatar.LocalID;
+                                    Client.Self.Position = avatar.Position;
+                                    Client.Self.Rotation = avatar.Rotation;
+                                }
+                                else
+                                {
+                                    if (OnNewAvatar != null)
+                                    {
+                                        OnNewAvatar(simulator, avatar, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
+                                    }
+                                }
+                            }
+                            break;
+                        case (byte)PCode.ParticleSystem:
+                            // FIXME: Handle ParticleSystem
+                            Client.DebugLog(&quot;Got an ObjectUpdate block with a ParticleSystem PCode&quot;);
+                            break;
+                        default:
+                            break;
                     }
                 }
-                else
-                {
-                    // Unknown
-                    Client.Log(&quot;Unhandled ObjectData.ObjectData length:\n&quot; + block.ObjectData.Length, 
-                        Helpers.LogLevel.Warning);
-                }
             }
         }
 
@@ -368,7 +919,7 @@
                 int i = 0;
                 bool avatar;
 
-                localid = (uint)(block.Data[i++] + (block.Data[i++] &lt;&lt; 8) + 
+                localid = (uint)(block.Data[i++] + (block.Data[i++] &lt;&lt; 8) +
                     (block.Data[i++] &lt;&lt; 16) + (block.Data[i++] &lt;&lt; 24));
 
                 byte state = block.Data[i++];
@@ -377,9 +928,15 @@
 
                 if (avatar)
                 {
+                    if (OnAvatarMoved == null) return;
+
                     CollisionPlane = new LLVector4(block.Data, i);
                     i += 16;
                 }
+                else
+                {
+                    if (OnPrimMoved == null) return;
+                }
 
                 // Position
                 Position = new LLVector3(block.Data, i);
@@ -436,6 +993,7 @@
                     avupdate.Acceleration = Acceleration;
                     avupdate.Rotation = Rotation;
                     avupdate.RotationVelocity = RotationVelocity;
+                    avupdate.Textures = new TextureEntry(block.TextureEntry, 4, block.TextureEntry.Length - 4);
 
                     if (OnAvatarMoved != null)
                     {
@@ -444,6 +1002,11 @@
                 }
                 else
                 {
+                    // TODO: Is there an easy way to distinguish prims from trees in this packet,
+                    // or would the client have to do it's own lookup to determine whether it's a
+                    // prim or a tree? If the latter, we should rename this update to something 
+                    // less prim specific
+
                     PrimUpdate primupdate = new PrimUpdate();
                     primupdate.LocalID = localid;
                     primupdate.State = state;
@@ -452,6 +1015,7 @@
                     primupdate.Acceleration = Acceleration;
                     primupdate.Rotation = Rotation;
                     primupdate.RotationVelocity = RotationVelocity;
+                    primupdate.Textures = new TextureEntry(block.TextureEntry, 4, block.TextureEntry.Length - 4);
 
                     if (OnPrimMoved != null)
                     {
@@ -463,145 +1027,253 @@
 
         private void CompressedUpdateHandler(Packet packet, Simulator simulator)
         {
-            ObjectUpdateCompressedPacket update = (ObjectUpdateCompressedPacket)packet;
-            PrimObject prim;
-
-            foreach (ObjectUpdateCompressedPacket.ObjectDataBlock block in update.ObjectData)
+            if (OnNewPrim != null || OnNewAvatar != null || OnNewAttachment != null || OnNewFoliage != null)
             {
-                int i = 0;
-                prim = new PrimObject(Client);
+                ObjectUpdateCompressedPacket update = (ObjectUpdateCompressedPacket)packet;
+                PrimObject prim;
 
-                prim.ID = new LLUUID(block.Data, 0);
-                i += 16;
-                prim.LocalID = (uint)(block.Data[i++] + (block.Data[i++] &lt;&lt; 8) +
-                    (block.Data[i++] &lt;&lt; 16) + (block.Data[i++] &lt;&lt; 24));
+                foreach (ObjectUpdateCompressedPacket.ObjectDataBlock block in update.ObjectData)
+                {
+                    int i = 0;
+                    prim = new PrimObject(Client);
 
-                i++; //PCode
-                prim.State = (uint)block.Data[i++];
-                i += 4; //CRC
-                prim.Material = (uint)block.Data[i++];
-                i++; //ClickAction
+                    prim.Flags = (ObjectFlags)block.UpdateFlags;
 
-                prim.Scale = new LLVector3(block.Data, i);
-                i += 12;
-                prim.Position = new LLVector3(block.Data, i);
-                i += 12;
-                prim.Rotation = new LLQuaternion(block.Data, i, true);
-                i += 12;
+                    try
+                    {
+                        prim.ID = new LLUUID(block.Data, 0);
+                        i += 16;
+                        prim.LocalID = (uint)(block.Data[i++] + (block.Data[i++] &lt;&lt; 8) +
+                            (block.Data[i++] &lt;&lt; 16) + (block.Data[i++] &lt;&lt; 24));
 
-                uint flags = (uint)(block.Data[i++] + (block.Data[i++] &lt;&lt; 8) +
-                    (block.Data[i++] &lt;&lt; 16) + (block.Data[i++] &lt;&lt; 24));
+                        byte pcode = block.Data[i++];
+                        if (pcode == (byte)PCode.Prim)
+                        {
+                            #region Prim
+                            prim.State = (uint)block.Data[i++];
+                            i += 4; // CRC
+                            prim.Material = (uint)block.Data[i++];
+                            i++; // TODO: ClickAction
 
-                if ((flags &amp; 0x02) != 0)
-                {
-                    //Unknown 2 bytes
-                    i += 2;
+                            prim.Scale = new LLVector3(block.Data, i);
+                            i += 12;
+                            prim.Position = new LLVector3(block.Data, i);
+                            i += 12;
+                            prim.Rotation = new LLQuaternion(block.Data, i, true);
+                            i += 12;
 
-                    if (OnNewPrim != null)
-                    {
-                        OnNewPrim(simulator, prim, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
-                    }
-                    continue;
-                }
+                            int flagsValue = (int)block.Data[i++] + (int)(block.Data[i++] &lt;&lt; 8) +
+                                (int)(block.Data[i++] &lt;&lt; 16) + (int)(block.Data[i++] &lt;&lt; 24);
+                            CompressedFlags flags = (CompressedFlags)flagsValue;
 
-                if ((flags &amp; 0x20) != 0)
-                {
-                    prim.ParentID = (uint)(block.Data[i++] + (block.Data[i++] &lt;&lt; 8) +
-                    (block.Data[i++] &lt;&lt; 16) + (block.Data[i++] &lt;&lt; 24));
-                }
-                else
-                {
-                    prim.ParentID = 0;
-                }
+                            if ((flags &amp; CompressedFlags.Tree) != 0)
+                            {
+                                // FIXME: I don't think this is even Tree data, as it would have
+                                // a different PCode. Figure out what this flag is and how to 
+                                // decode it
+                                byte Unknown1 = block.Data[i++];
+                                byte Unknown2 = block.Data[i++];
 
-                //Unknown field
-                if ((flags &amp; 0x80) != 0)
-                {
-                    i += 12;
-                }
+                                Client.DebugLog(&quot;Compressed object with Tree flag set: &quot; + Environment.NewLine +
+                                    &quot;Unknown byte 1: &quot; + Unknown1 + Environment.NewLine + &quot;Unknown byte 2: &quot; + Unknown2);
+                            }
 
-                // TODO: This seems kind of odd, isn't there a flag to identify
-                // whether this block is text (or 24 unknown bytes)?
-                byte unknownByte = block.Data[i];
-                if (unknownByte == 1)
-                {
-                    //Unknown
-                    i += 23;
-                }
-                else
-                {
-                    string text = &quot;&quot;;
-                    while (block.Data[i] != 0)
-                    {
-                        text += (char)block.Data[i];
-                        i++;
-                    }
-                    prim.Text = text;
-                    i++;
-                }
+                            if ((flags &amp; CompressedFlags.HasParent) != 0)
+                            {
+                                prim.ParentID = (uint)(block.Data[i++] + (block.Data[i++] &lt;&lt; 8) +
+                                (block.Data[i++] &lt;&lt; 16) + (block.Data[i++] &lt;&lt; 24));
+                            }
+                            else
+                            {
+                                prim.ParentID = 0;
+                            }
 
-                //Unknown field, possibly text color.
-                if ((flags &amp; 0x04) != 0)
-                {
-                    i += 5;
-                }
+                            if ((flags &amp; CompressedFlags.HasAngularVelocity) != 0)
+                            {
+                                // TODO: Use this
+                                LLVector3 Omega = new LLVector3(block.Data, i);
+                                i += 12;
+                            }
 
-                //Indicates that this is an attachment?
-                if ((flags &amp; 0x100) != 0)
-                {
-                    //A string
-                    //Example: &quot;AttachItemID STRING RW SV fa9a5ab8-1bad-b449-9873-cf5b803e664e&quot;
-                    while (block.Data[i] != 0)
-                    {
-                        i++;
-                    }
-                    i++;
-                }
+                            if ((flags &amp; CompressedFlags.HasText) != 0)
+                            {
+                                string text = &quot;&quot;;
+                                while (block.Data[i] != 0)
+                                {
+                                    text += (char)block.Data[i];
+                                    i++;
+                                }
+                                i++;
 
-                prim.PathCurve = (uint)block.Data[i++];
-                prim.PathBegin = PrimObject.PathBeginFloat(block.Data[i++]);
-                prim.PathEnd = PrimObject.PathEndFloat(block.Data[i++]);
-                prim.PathScaleX = PrimObject.PathScaleFloat(block.Data[i++]);
-                prim.PathScaleY = PrimObject.PathScaleFloat(block.Data[i++]);
-                prim.PathShearX = PrimObject.PathShearFloat(block.Data[i++]);
-                prim.PathShearY = PrimObject.PathShearFloat(block.Data[i++]);
-                prim.PathTwist = (int)block.Data[i++];
-                prim.PathTwistBegin = (int)block.Data[i++];
-                prim.PathRadiusOffset = PrimObject.PathRadiusOffsetFloat((sbyte)block.Data[i++]);
-                prim.PathTaperX = PrimObject.PathTaperFloat(block.Data[i++]);
-                prim.PathTaperY = PrimObject.PathTaperFloat(block.Data[i++]);
-                prim.PathRevolutions = PrimObject.PathRevolutionsFloat(block.Data[i++]);
-                prim.PathSkew = PrimObject.PathSkewFloat(block.Data[i++]);
-               
-                prim.ProfileCurve = (uint)block.Data[i++];
-                prim.ProfileBegin = PrimObject.ProfileBeginFloat(block.Data[i++]);
-                prim.ProfileEnd = PrimObject.ProfileEndFloat(block.Data[i++]);
-                prim.ProfileHollow = (uint)block.Data[i++];
+                                prim.Text = text;
 
-                //Unknown field
-                i += 4;
+                                // TODO: Text color
+                                i += 4;
+                            }
+                            else
+                            {
+                                prim.Text = &quot;&quot;;
+                            }
 
-                prim.Textures = new TextureEntry(Client, block.Data, i);
+                            if ((flags &amp; CompressedFlags.HasParticles) != 0)
+                            {
+                                prim.ParticleSys = new ParticleSystem(block.Data, i);
+                                i += 86;
+                            }
 
-                if (OnNewPrim != null)
-                {
-                    OnNewPrim(simulator, prim, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
+                            i += prim.SetExtraParamsFromBytes(block.Data, i);
+
+                            //Sound data
+                            if ((flags &amp; CompressedFlags.HasSound) != 0)
+                            {
+                                //TODO: use this data
+                                LLUUID SoundUUID = new LLUUID(block.Data, i);
+                                i += 16;
+                                LLUUID OwnerUUID = new LLUUID(block.Data, i);
+                                i += 16;
+
+                                if (!BitConverter.IsLittleEndian)
+                                {
+                                    Array.Reverse(block.Data, i, 4);
+                                    Array.Reverse(block.Data, i + 5, 4);
+                                }
+
+                                float SoundGain = BitConverter.ToSingle(block.Data, i);
+                                i += 4;
+                                byte SoundFlags = block.Data[i++];
+                                float SoundRadius = BitConverter.ToSingle(block.Data, i);
+                                i += 4;
+                            }
+
+                            // Indicates that this is an attachment
+                            if ((flags &amp; CompressedFlags.Attachment) != 0)
+                            {
+                                // Get the attachment string
+                                // Example: &quot;AttachItemID STRING RW SV fa9a5ab8-1bad-b449-9873-cf5b803e664e&quot;
+                                string text = &quot;&quot;;
+                                while (block.Data[i] != 0)
+                                {
+                                    text += (char)block.Data[i];
+                                    i++;
+                                }
+                                i++;
+
+                                prim.Name = text;
+                            }
+                            else
+                            {
+                                prim.Name = &quot;&quot;;
+                            }
+
+                            if ((flags &amp; CompressedFlags.Unknown1) != 0)
+                            {
+                                // TODO: Is this even a valid flag?
+                                Client.DebugLog(&quot;Compressed object with Unknown1 flag set: &quot; + Environment.NewLine +
+                                    &quot;Flags: &quot; + flags.ToString() + Environment.NewLine +
+                                    Helpers.FieldToString(block.Data));
+                            }
+
+                            if ((flags &amp; CompressedFlags.Unknown2) != 0)
+                            {
+                                // FIXME: Implement CompressedFlags.Unknown2
+                                //Client.DebugLog(&quot;Compressed object with Unknown2 flag set: &quot; + Environment.NewLine +
+                                //    &quot;Flags: &quot; + flags.ToString() + Environment.NewLine +
+                                //    Helpers.FieldToString(block.Data));
+                            }
+
+                            prim.PathCurve = (uint)block.Data[i++];
+                            prim.PathBegin = PrimObject.PathBeginFloat(block.Data[i++]);
+                            prim.PathEnd = PrimObject.PathEndFloat(block.Data[i++]);
+                            prim.PathScaleX = PrimObject.PathScaleFloat(block.Data[i++]);
+                            prim.PathScaleY = PrimObject.PathScaleFloat(block.Data[i++]);
+                            prim.PathShearX = PrimObject.PathShearFloat(block.Data[i++]);
+                            prim.PathShearY = PrimObject.PathShearFloat(block.Data[i++]);
+                            prim.PathTwist = (int)block.Data[i++];
+                            prim.PathTwistBegin = (int)block.Data[i++];
+                            prim.PathRadiusOffset = PrimObject.PathRadiusOffsetFloat((sbyte)block.Data[i++]);
+                            prim.PathTaperX = PrimObject.PathTaperFloat((sbyte)block.Data[i++]);
+                            prim.PathTaperY = PrimObject.PathTaperFloat((sbyte)block.Data[i++]);
+                            prim.PathRevolutions = PrimObject.PathRevolutionsFloat(block.Data[i++]);
+                            prim.PathSkew = PrimObject.PathSkewFloat((sbyte)block.Data[i++]);
+
+                            prim.ProfileCurve = (uint)block.Data[i++];
+                            prim.ProfileBegin = PrimObject.ProfileBeginFloat(block.Data[i++]);
+                            prim.ProfileEnd = PrimObject.ProfileEndFloat(block.Data[i++]);
+                            prim.ProfileHollow = (uint)block.Data[i++];
+
+                            int textureEntryLength = (int)(block.Data[i++] + (block.Data[i++] &lt;&lt; 8) +
+                                (block.Data[i++] &lt;&lt; 16) + (block.Data[i++] &lt;&lt; 24));
+
+                            prim.Textures = new TextureEntry(block.Data, i, textureEntryLength);
+
+                            i += textureEntryLength;
+
+                            // Assume everything else is texture animation data
+                            if (i &lt; block.Data.Length)
+                            {
+                                int textureAnimLength = (int)(block.Data[i++] + (block.Data[i++] &lt;&lt; 8) +
+                                    (block.Data[i++] &lt;&lt; 16) + (block.Data[i++] &lt;&lt; 24));
+
+                                prim.TextureAnim = new TextureAnimation(block.Data, i);
+                            }
+
+                            // Fire the appropriate callback
+                            if ((flags &amp; CompressedFlags.Attachment) != 0)
+                            {
+                                if (OnNewAttachment != null)
+                                {
+                                    OnNewAttachment(simulator, prim, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
+                                }
+                            }
+                            else if ((flags &amp; CompressedFlags.Tree) != 0)
+                            {
+                                if (OnNewFoliage != null)
+                                {
+                                    OnNewFoliage(simulator, prim, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
+                                }
+                            }
+                            else if (OnNewPrim != null)
+                            {
+                                OnNewPrim(simulator, prim, update.RegionData.RegionHandle, update.RegionData.TimeDilation);
+                            }
+                            #endregion Prim
+                        }
+                        else if (pcode == (byte)PCode.Grass || pcode == (byte)PCode.Tree || pcode == (byte)PCode.NewTree)
+                        {
+                            // FIXME: Implement this
+                            //Client.DebugLog(&quot;######### Got an ObjectUpdateCompressed for grass/tree, implement this! #########&quot;);
+                        }
+                        else
+                        {
+                            Client.Log(&quot;######### Got an ObjectUpdateCompressed for PCode=&quot; + pcode.ToString() + 
+                                &quot;, implement this! #########&quot;, Helpers.LogLevel.Debug);
+                        }
+                    }
+                    catch (System.IndexOutOfRangeException e)
+                    {
+                        Client.Log(&quot;Had a problem decoding an ObjectUpdateCompressed packet: &quot; +
+                            e.ToString(), Helpers.LogLevel.Warning);
+                        Client.Log(block.ToString(), Helpers.LogLevel.Warning);
+                    }
                 }
             }
         }
 
         private void CachedUpdateHandler(Packet packet, Simulator simulator)
         {
-            List&lt;uint&gt; ids = new List&lt;uint&gt;();
-            ObjectUpdateCachedPacket update = (ObjectUpdateCachedPacket)packet;
+            if (RequestAllObjects)
+            {
+                List&lt;uint&gt; ids = new List&lt;uint&gt;();
+                ObjectUpdateCachedPacket update = (ObjectUpdateCachedPacket)packet;
 
-            // Assume clients aren't caching objects for now, so request updates for all of these objects
-            foreach (ObjectUpdateCachedPacket.ObjectDataBlock block in update.ObjectData)
-            {
-                ids.Add(block.ID);
+                // Assume clients aren't caching objects for now, so request updates for all of these objects
+                foreach (ObjectUpdateCachedPacket.ObjectDataBlock block in update.ObjectData)
+                {
+                    ids.Add(block.ID);
+                }
+
+                RequestObjects(simulator, ids);
             }
-
-            RequestObjects(simulator, ids);
         }
 
         private void KillObjectHandler(Packet packet, Simulator simulator)

Modified: branches/aditi/libsecondlife-cs/Parcel.cs
===================================================================
--- branches/aditi/libsecondlife-cs/Parcel.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/Parcel.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -67,8 +67,8 @@
         /// &lt;/summary&gt;
         public DirectoryParcel()
         {
-            GlobalPosition = new LLVector3();
-            SimPosition = new LLVector3();
+            GlobalPosition = LLVector3.Zero;
+            SimPosition = LLVector3.Zero;
         }
     }
 
@@ -175,16 +175,16 @@
 
         private void init()
         {
-            OwnerID = new LLUUID();
-            AABBMin = new LLVector3();
-            AABBMax = new LLVector3();
+            OwnerID = LLUUID.Zero;
+            AABBMin = LLVector3.Zero;
+            AABBMax = LLVector3.Zero;
             Bitmap = new byte[512];
-            MediaID = new LLUUID();
-            GroupID = new LLUUID();
-            AuthBuyerID = new LLUUID();
-            SnapshotID = new LLUUID();
-            UserLocation = new LLVector3();
-            UserLookAt = new LLVector3();
+            MediaID = LLUUID.Zero;
+            GroupID = LLUUID.Zero;
+            AuthBuyerID = LLUUID.Zero;
+            SnapshotID = LLUUID.Zero;
+            UserLocation = LLVector3.Zero;
+            UserLookAt = LLVector3.Zero;
         }
 
         /// &lt;summary&gt;
@@ -215,7 +215,7 @@
             request.AgentData.AgentID = client.Network.AgentID;
             request.AgentData.SessionID = client.Network.SessionID;
             request.Data.LocalID = LocalID;
-            request.Data.ParcelID = new LLUUID();
+            request.Data.ParcelID = LLUUID.Zero;
 
             client.Network.SendPacket((Packet)request, Sim);
         }
@@ -372,10 +372,10 @@
             DirLandTimeout = false;
 
             // Setup the callbacks
-            Client.Network.RegisterCallback(PacketType.DirLandReply, new PacketCallback(DirLandReplyHandler));
-            Client.Network.RegisterCallback(PacketType.ParcelInfoReply, new PacketCallback(ParcelInfoReplyHandler));
-            Client.Network.RegisterCallback(PacketType.ParcelProperties, new PacketCallback(ParcelPropertiesHandler));
-            Client.Network.RegisterCallback(PacketType.ParcelDwellReply, new PacketCallback(ParcelDwellReplyHandler));
+            Client.Network.RegisterCallback(PacketType.DirLandReply, new NetworkManager.PacketCallback(DirLandReplyHandler));
+            Client.Network.RegisterCallback(PacketType.ParcelInfoReply, new NetworkManager.PacketCallback(ParcelInfoReplyHandler));
+            Client.Network.RegisterCallback(PacketType.ParcelProperties, new NetworkManager.PacketCallback(ParcelPropertiesHandler));
+            Client.Network.RegisterCallback(PacketType.ParcelDwellReply, new NetworkManager.PacketCallback(ParcelDwellReplyHandler));
 
             ParcelInfoParcel = null;
         }
@@ -528,7 +528,7 @@
                             tPacket.ParcelData.East = (x * 4.0f) + 4.0f;
                             tPacket.ParcelData.North = (y * 4.0f) + 4.0f;
 
-                            simulator.SendPacket((Packet)tPacket, true);
+                            Client.Network.SendPacket(tPacket, simulator);
 
                             hasTriggered = true;
 

Copied: branches/aditi/libsecondlife-cs/ParticleSystem.cs (from rev 649, trunk/libsecondlife-cs/ParticleSystem.cs)

Modified: branches/aditi/libsecondlife-cs/Prims.cs
===================================================================
--- branches/aditi/libsecondlife-cs/Prims.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/Prims.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -25,6 +25,7 @@
  */
 
 using System;
+using System.Xml;
 
 namespace libsecondlife
 {
@@ -44,7 +45,7 @@
         /// &lt;summary&gt;&lt;/summary&gt;
 		public float PathSkew = 0;
         /// &lt;summary&gt;&lt;/summary&gt;
-		public LLVector3 Position = new LLVector3();
+        public LLVector3 Position = LLVector3.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
 		public uint ProfileCurve = 0;
         /// &lt;summary&gt;&lt;/summary&gt;
@@ -52,19 +53,19 @@
         /// &lt;summary&gt;&lt;/summary&gt;
 		public float PathScaleY = 0;
         /// &lt;summary&gt;&lt;/summary&gt;
-		public LLUUID ID = new LLUUID();
+        public LLUUID ID = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
 		public uint LocalID = 0;
         /// &lt;summary&gt;&lt;/summary&gt;
         public uint ParentID = 0;
         /// &lt;summary&gt;&lt;/summary&gt;
-		public LLUUID GroupID = new LLUUID();
+        public LLUUID GroupID = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
 		public uint Material = 0;
         /// &lt;summary&gt;&lt;/summary&gt;
 		public string Name = &quot;&quot;;
         /// &lt;summary&gt;&lt;/summary&gt;
-		public string Description;
+		public string Description = &quot;&quot;;
         /// &lt;summary&gt;&lt;/summary&gt;
 		public float PathShearX = 0;
         /// &lt;summary&gt;&lt;/summary&gt;
@@ -80,21 +81,33 @@
         /// &lt;summary&gt;&lt;/summary&gt;
 		public uint PathCurve = 0;
         /// &lt;summary&gt;&lt;/summary&gt;
-		public LLVector3 Scale = new LLVector3();
+        public LLVector3 Scale = LLVector3.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
 		public int PathTwist = 0;
         /// &lt;summary&gt;&lt;/summary&gt;
+        public uint ProfileHollow = 0;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public float PathRevolutions = 0;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public LLQuaternion Rotation = LLQuaternion.Identity;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public uint State;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public string Text;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public ObjectManager.PCode PCode;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public ObjectFlags Flags;
+        /// &lt;summary&gt;&lt;/summary&gt;
         public TextureEntry Textures;
         /// &lt;summary&gt;&lt;/summary&gt;
-		public uint ProfileHollow = 0;
+        public TextureAnimation TextureAnim;
         /// &lt;summary&gt;&lt;/summary&gt;
-		public float PathRevolutions = 0;
+        public PrimFlexibleData Flexible;
         /// &lt;summary&gt;&lt;/summary&gt;
-		public LLQuaternion Rotation = new LLQuaternion();
+        public PrimLightData Light;
         /// &lt;summary&gt;&lt;/summary&gt;
-		public uint State;
-        /// &lt;summary&gt;&lt;/summary&gt;
-        public string Text;
+        public ParticleSystem ParticleSys;
 
         private SecondLife Client;
 
@@ -104,7 +117,15 @@
         public PrimObject(SecondLife client)
         {
             Client = client;
-            Textures = new TextureEntry(Client);
+            PCode = ObjectManager.PCode.Prim;
+            Flexible = new PrimFlexibleData();
+            Light = new PrimLightData();
+            ParticleSys = new ParticleSystem();
+            Textures = new TextureEntry();
+            TextureAnim = new TextureAnimation();
+            Flexible = new PrimFlexibleData();
+            Light = new PrimLightData();
+            ParticleSys = new ParticleSystem();
         }
 		
         /// &lt;summary&gt;
@@ -114,7 +135,8 @@
 		public PrimObject(SecondLife client, LLUUID texture)
 		{
             Client = client;
-            Textures = new TextureEntry(Client);
+            PCode = ObjectManager.PCode.Prim;
+            Textures = new TextureEntry();
             Textures.DefaultTexture.TextureID = texture;
 		}
 
@@ -126,7 +148,8 @@
 		public static byte PathScaleByte(float pathScale)
 		{
 			// Y = 100 + 100X
-			return (byte)(100 + Convert.ToInt16(100.0F * pathScale));
+            int scale = (int)Math.Round(100.0f * pathScale);
+			return (byte)(100 + scale);
 		}
 
         /// &lt;summary&gt;
@@ -137,43 +160,20 @@
         public static float PathScaleFloat(byte pathScale)
         {
             // Y = -1 + 0.01X
-            return (float)pathScale * 0.01F - 1.0F;
+            return (float)Math.Round((double)pathScale * 0.01d - 1.0d, 6);
         }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
-        /// &lt;param name=&quot;pathTwist&quot;&gt;&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-		public static byte PathTwistByte(float pathTwist)
-		{
-			// Y = 256 + ceil (X / 1.8)
-			ushort temp = Convert.ToUInt16(256 + Math.Ceiling(pathTwist / 1.8F));
-			return (byte)(temp % 256);
-		}
-
-        /*/// &lt;summary&gt;
-        /// 
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;pathTwist&quot;&gt;&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-        public static float PathTwistFloat(sbyte pathTwist)
-        {
-            // Y = 0.5556X
-            return (float)pathTwist * 0.5556F;
-        }*/
-
-        /// &lt;summary&gt;
-        /// 
-        /// &lt;/summary&gt;
         /// &lt;param name=&quot;pathShear&quot;&gt;&lt;/param&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
 		public static byte PathShearByte(float pathShear)
 		{
 			// Y = 256 + 100X
-			ushort temp = Convert.ToUInt16(100.0F * pathShear);
-			temp += 256;
-			return (byte)(temp % 256);
+            int shear = (int)Math.Round(100.0f * pathShear);
+			shear += 256;
+			return (byte)(shear % 256);
 		}
 
         /// &lt;summary&gt;
@@ -183,15 +183,19 @@
         /// &lt;returns&gt;&lt;/returns&gt;
         public static float PathShearFloat(byte pathShear)
         {
-            // Y = (X - 256) / 100
+            if (pathShear == 0) return 0.0f;
+
             if (pathShear &gt; 150)
             {
-                return ((float)pathShear - 256.0F) / 100.0F;
+                // Negative value
+                return ((float)pathShear - 256.0f) / 100.0f;
             }
             else
             {
-                return (float)pathShear / 100.0F;
-            }        }
+                // Positive value
+                return (float)pathShear / 100.0f;
+            }
+        }
 
         /// &lt;summary&gt;
         /// 
@@ -201,7 +205,7 @@
 		public static byte ProfileBeginByte(float profileBegin)
 		{
 			// Y = ceil (200X)
-			return (byte)Convert.ToInt16(200.0F * profileBegin);
+			return (byte)Math.Round(200.0f * profileBegin);
 		}
 
         /// &lt;summary&gt;
@@ -212,7 +216,7 @@
         public static float ProfileBeginFloat(byte profileBegin)
         {
             // Y = 0.005X
-            return (float)profileBegin * 0.005F;
+            return (float)Math.Round((double)profileBegin * 0.005d, 6);
         }
 
         /// &lt;summary&gt;
@@ -222,8 +226,9 @@
         /// &lt;returns&gt;&lt;/returns&gt;
 		public static byte ProfileEndByte(float profileEnd)
 		{
-			// Y = 200 - ceil (200X)
-			return (byte)(200 - (200.0F * profileEnd));
+			// Y = 200 - 200X
+            int end = (int)Math.Round(200.0d * (double)profileEnd);
+			return (byte)(200 - end);
 		}
 
         /// &lt;summary&gt;
@@ -234,7 +239,7 @@
         public static float ProfileEndFloat(byte profileEnd)
         {
             // Y = 1 - 0.005X
-            return 1.0F - (float)profileEnd * 0.005F;
+            return (float)Math.Round(1.0d - ((double)profileEnd * 0.005d), 6);
         }
 
         /// &lt;summary&gt;
@@ -245,7 +250,7 @@
 		public static byte PathBeginByte(float pathBegin)
 		{
 			// Y = 100X
-			return (byte)Convert.ToInt16(100.0F * pathBegin);
+			return (byte)Convert.ToInt16(100.0f * pathBegin);
 		}
 
         /// &lt;summary&gt;
@@ -256,7 +261,7 @@
         public static float PathBeginFloat(byte pathBegin)
         {
             // Y = X / 100
-            return (float)pathBegin / 100.0F;
+            return (float)pathBegin / 100.0f;
         }
 
         /// &lt;summary&gt;
@@ -267,7 +272,8 @@
 		public static byte PathEndByte(float pathEnd)
 		{
 			// Y = 100 - 100X
-			return (byte)(100 - Convert.ToInt16(100.0F * pathEnd));
+            int end = (int)Math.Round(100.0f * pathEnd);
+            return (byte)(100 - end);
 		}
 
         /// &lt;summary&gt;
@@ -278,7 +284,7 @@
         public static float PathEndFloat(byte pathEnd)
         {
             // Y = 1 - X / 100
-            return 1.0F - (float)pathEnd / 100;
+            return 1.0f - (float)pathEnd / 100.0f;
         }
 
         /// &lt;summary&gt;
@@ -286,10 +292,10 @@
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;pathRadiusOffset&quot;&gt;&lt;/param&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
-		public static byte PathRadiusOffsetByte(float pathRadiusOffset)
+		public static sbyte PathRadiusOffsetByte(float pathRadiusOffset)
 		{
 			// Y = 256 + 100X
-			return PathShearByte(pathRadiusOffset);
+			return (sbyte)PathShearByte(pathRadiusOffset);
 		}
 
         /// &lt;summary&gt;
@@ -300,7 +306,7 @@
         public static float PathRadiusOffsetFloat(sbyte pathRadiusOffset)
         {
             // Y = X / 100
-            return (float)pathRadiusOffset / 100.0F;
+            return (float)pathRadiusOffset / 100.0f;
         }
 
         /// &lt;summary&gt;
@@ -310,8 +316,9 @@
         /// &lt;returns&gt;&lt;/returns&gt;
 		public static byte PathRevolutionsByte(float pathRevolutions)
 		{
-			// Y = ceil (66X) - 66
-			return (byte)(Convert.ToInt16(Math.Ceiling(66.0F * pathRevolutions)) - 66);
+			// Y = 66.5X - 66
+            int revolutions = (int)Math.Round(66.5d * (double)pathRevolutions);
+			return (byte)(revolutions - 66);
 		}
 
         /// &lt;summary&gt;
@@ -322,7 +329,7 @@
         public static float PathRevolutionsFloat(byte pathRevolutions)
         {
             // Y = 1 + 0.015X
-            return 1.0F + (float)pathRevolutions * 0.015F;
+            return (float)Math.Round(1.0d + (double)pathRevolutions * 0.015d, 6);
         }
 
         /// &lt;summary&gt;
@@ -330,7 +337,7 @@
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;pathSkew&quot;&gt;&lt;/param&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
-		public static byte PathSkewByte(float pathSkew)
+		public static sbyte PathSkewByte(float pathSkew)
 		{
             return PathTaperByte(pathSkew);
 		}
@@ -340,7 +347,7 @@
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;pathSkew&quot;&gt;&lt;/param&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
-        public static float PathSkewFloat(byte pathSkew)
+        public static float PathSkewFloat(sbyte pathSkew)
         {
             return PathTaperFloat(pathSkew);
         }
@@ -350,27 +357,369 @@
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;pathTaper&quot;&gt;&lt;/param&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
-		public static byte PathTaperByte(float pathTaper)
-		{
-			// Y = 256 + 100X
-			return PathShearByte(pathTaper);
-		}
+        public static sbyte PathTaperByte(float pathTaper)
+        {
+            // Y = 256 + 100X
+            return (sbyte)PathShearByte(pathTaper);
+        }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;pathTaper&quot;&gt;&lt;/param&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
-        public static float PathTaperFloat(byte pathTaper)
+        public static float PathTaperFloat(sbyte pathTaper)
         {
-            if (pathTaper &gt; 100)
+            return (float)pathTaper / 100.0f;
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;pos&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public int SetExtraParamsFromBytes(byte[] data, int pos)
+        {
+            int i = pos;
+            int totalLength = 1;
+
+            if (data.Length == 0)
+                return 0;
+
+            byte extraParamCount = data[i++];
+
+            for (int k = 0; k &lt; extraParamCount; k++)
             {
-                return (float)(256 - pathTaper) * 0.01F;
+                ExtraParamType type = (ExtraParamType)(data[i++] + (data[i++] &lt;&lt; 8));
+                uint paramLength = (uint)(data[i++] + (data[i++] &lt;&lt; 8) +
+                              (data[i++] &lt;&lt; 16) + (data[i++] &lt;&lt; 24));
+                if (type == ExtraParamType.Flexible)
+                {
+                    Flexible = new PrimFlexibleData(data, i);
+                }
+                else if (type == ExtraParamType.Light)
+                {
+                    Light = new PrimLightData(data, i);
+                }
+                i += (int)paramLength;
+                totalLength += (int)paramLength + 6;
             }
-            else
+
+            return totalLength;
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public string GetXml()
+        {
+            string xml = &quot;&lt;Prim&gt;&quot;;
+            xml += &quot;&lt;PathTwistBegin value=\&quot;&quot; + PathTwistBegin + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathEnd value=\&quot;&quot; + PathEnd + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;ProfileBegin value=\&quot;&quot; + ProfileBegin + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathRadiusOffset value=\&quot;&quot; + PathRadiusOffset + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathSkew value=\&quot;&quot; + PathSkew + &quot;\&quot; /&gt;&quot;;
+            xml += Position.GetXml(&quot;Position&quot;);
+            xml += &quot;&lt;ProfileCurve value=\&quot;&quot; + ProfileCurve + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathScaleX value=\&quot;&quot; + PathScaleX + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathScaleY value=\&quot;&quot; + PathScaleY + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;ID value=\&quot;&quot; + ID.ToString() + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;LocalID value=\&quot;&quot; + LocalID + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;ParentID value=\&quot;&quot; + ParentID + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;GroupID value=\&quot;&quot; + GroupID.ToString() + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Material value=\&quot;&quot; + Material + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Name value=\&quot;&quot; + Name + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Description value=\&quot;&quot; + Description + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathShearX value=\&quot;&quot; + PathShearX + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathShearY value=\&quot;&quot; + PathShearY + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathTaperX value=\&quot;&quot; + PathTaperX + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathTaperY value=\&quot;&quot; + PathTaperY + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;ProfileEnd value=\&quot;&quot; + ProfileEnd + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathBegin value=\&quot;&quot; + PathBegin + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathCurve value=\&quot;&quot; + PathCurve + &quot;\&quot; /&gt;&quot;;
+            xml += Scale.GetXml(&quot;Scale&quot;);
+            xml += &quot;&lt;PathTwist value=\&quot;&quot; + PathTwist + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;ProfileHollow value=\&quot;&quot; + ProfileHollow + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PathRevolutions value=\&quot;&quot; + PathRevolutions + &quot;\&quot; /&gt;&quot;;
+            xml += Rotation.GetXml(&quot;Rotation&quot;);
+            xml += &quot;&lt;State value=\&quot;&quot; + State + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Text value=\&quot;&quot; + Text + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;PCode value=\&quot;&quot; + PCode + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Flags value=\&quot;&quot; + Flags + &quot;\&quot; /&gt;&quot;;
+            xml += Textures.GetXml(&quot;Textures&quot;);
+            xml += TextureAnim.GetXml(&quot;TextureAnim&quot;);
+            xml += Flexible.GetXml(&quot;Flexible&quot;);
+            xml += Light.GetXml(&quot;Light&quot;);
+            xml += ParticleSys.GetXml(&quot;ParticleSys&quot;);
+            xml += &quot;&lt;/Prim&gt;&quot;;
+
+            return xml;
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public static PrimObject FromXml(SecondLife client, XmlNode node)
+        {
+            PrimObject prim = new PrimObject(client);
+
+            foreach (XmlNode childNode in node.ChildNodes)
             {
-                return (float)pathTaper * 0.01F;
+                ;
             }
+
+            return prim;
         }
+
+        public override string ToString()
+        {
+            string output = &quot;&quot;;
+
+            output += (Name.Length != 0) ? Name : &quot;Unnamed&quot;;
+            output += &quot;: &quot; + ((Description.Length != 0) ? Description : &quot;No description&quot;) + Environment.NewLine;
+            output += &quot;ID: &quot; + ID + &quot;, &quot;;
+            output += &quot;GroupID: &quot; + GroupID + &quot;, &quot;;
+            output += &quot;ParentID: &quot; + ParentID + &quot;, &quot;;
+            output += &quot;LocalID: &quot; + LocalID + &quot;, &quot;;
+            output += &quot;Flags: &quot; + Flags + &quot;, &quot;;
+            output += &quot;State: &quot; + State + &quot;, &quot;;
+            output += &quot;PCode: &quot; + PCode + &quot;, &quot;;
+            output += &quot;Material: &quot; + Material + &quot;, &quot;;
+
+            return output;
+        }
 	}
+
+    /// &lt;summary&gt;
+    /// 
+    /// &lt;/summary&gt;
+    [Flags]
+    public enum ObjectFlags
+    {
+        None = 0,
+        Physics = 1 &lt;&lt; 0,
+        CreateSelected = 1 &lt;&lt; 1,
+        Script = 1 &lt;&lt; 6,
+        Touch = 1 &lt;&lt; 7,
+        Money = 1 &lt;&lt; 9,
+        Phantom = 1 &lt;&lt; 10,
+        Temp = 1 &lt;&lt; 30
+    }
+
+    /// &lt;summary&gt;
+    /// 
+    /// &lt;/summary&gt;
+    public enum ExtraParamType : ushort
+    {
+        Flexible = 0x10,
+        Light = 0x20
+    }
+
+    /// &lt;summary&gt;
+    /// 
+    /// &lt;/summary&gt;
+    public class PrimFlexibleData
+    {
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public int Softness;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public float Gravity;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public float Drag;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public float Wind;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public float Tension;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public LLVector3 Force = LLVector3.Zero;
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        public PrimFlexibleData()
+        {
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;pos&quot;&gt;&lt;/param&gt;
+        public PrimFlexibleData(byte[] data, int pos)
+        {
+            FromBytes(data, pos);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public byte[] GetBytes()
+        {
+            byte[] data = new byte[16];
+            int i = 0;
+
+            data[i] = (byte)((Softness &amp; 2) &lt;&lt; 6);
+            data[i + 1] = (byte)((Softness &amp; 1) &lt;&lt; 7);
+
+            data[i++] |= (byte)((byte)(Tension * 10.0f) &amp; 0x7F);
+            data[i++] |= (byte)((byte)(Drag * 10.0f) &amp; 0x7F);
+            data[i++] = (byte)((Gravity + 10.0f) * 10.0f);
+            data[i++] = (byte)(Wind * 10.0f);
+
+            Force.GetBytes().CopyTo(data, i);
+
+            return data;
+        }
+
+        private void FromBytes(byte[] data, int pos)
+        {
+            int i = pos;
+
+            Softness = ((data[i] &amp; 0x80) &gt;&gt; 6) | ((data[i + 1] &amp; 0x80) &gt;&gt; 7);
+
+            Tension = (data[i++] &amp; 0x7F) / 10.0f;
+            Drag = (data[i++] &amp; 0x7F) / 10.0f;
+            Gravity = (data[i++] / 10.0f) - 10.0f;
+            Wind = data[i++] / 10.0f;
+            Force = new LLVector3(data, i);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public string GetXml(string name)
+        {
+            string xml = &quot;&lt;&quot; + name + &quot;&gt;&quot;;
+            xml += &quot;&lt;Softness value=\&quot;&quot; + Softness + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Tension value=\&quot;&quot; + Tension + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Drag value=\&quot;&quot; + Drag + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Gravity value=\&quot;&quot; + Gravity + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Wind value=\&quot;&quot; + Wind + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;/&quot; + name + &quot;&gt;&quot;;
+
+            return xml;
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public static PrimFlexibleData FromXml(XmlNode node)
+        {
+            return null;
+        }
+    }
+
+    /// &lt;summary&gt;
+    /// 
+    /// &lt;/summary&gt;
+    public class PrimLightData
+    {
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public byte R, G, B;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public float Intensity;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public float Radius;
+        /// &lt;summary&gt;&lt;/summary&gt;
+        public float Falloff;
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        public PrimLightData()
+        {
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;pos&quot;&gt;&lt;/param&gt;
+        public PrimLightData(byte[] data, int pos)
+        {
+            FromBytes(data, pos);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public byte[] GetBytes()
+        {
+            byte[] data = new byte[16];
+            int i = 0;
+
+            data[i++] = R;
+            data[i++] = G;
+            data[i++] = B;
+            data[i++] = (byte)(Intensity * 255.0f);
+
+            BitConverter.GetBytes(Radius).CopyTo(data, i);
+            BitConverter.GetBytes(Falloff).CopyTo(data, i + 8);
+
+            if (!BitConverter.IsLittleEndian)
+            {
+                Array.Reverse(data, i, 4);
+                Array.Reverse(data, i + 8, 4);
+            }
+
+            return data;
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public string GetXml(string name)
+        {
+            string xml = &quot;&lt;&quot; + name + &quot;&gt;&quot;;
+            xml += &quot;&lt;Color X=\&quot;&quot; + R + &quot;\&quot; Y=\&quot;&quot; + G + &quot;\&quot; Z=\&quot;&quot; + B + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Intensity value=\&quot;&quot; + Intensity + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Radius value=\&quot;&quot; + Radius + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Falloff value=\&quot;&quot; + Falloff + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;/&quot; + name + &quot;&gt;&quot;;
+
+            return xml;
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public static PrimLightData FromXml(XmlNode node)
+        {
+            return null;
+        }
+
+        private void FromBytes(byte[] data, int pos)
+        {
+            int i = pos;
+
+            R = data[i++];
+            G = data[i++];
+            B = data[i++];
+            Intensity = data[i++] / 255.0f;
+
+            if (!BitConverter.IsLittleEndian)
+            {
+                Array.Reverse(data, i, 4);
+                Array.Reverse(data, i + 8, 4);
+            }
+
+            Radius = BitConverter.ToSingle(data, i);
+            Falloff = BitConverter.ToSingle(data, i + 8);
+        }
+    }
 }

Modified: branches/aditi/libsecondlife-cs/README.txt
===================================================================
--- branches/aditi/libsecondlife-cs/README.txt	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/README.txt	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,3 +1,32 @@
+libsecondlife - A Second Life networking library
+------------------------------------------------
+
+
+Copyright (c) 2006, Second Life Reverse Engineering Team
+All rights reserved.
+
+- Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions are met:
+
+- Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+- Neither the name of the Second Life Reverse Engineering Team nor the names 
+  of its contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+POSSIBILITY OF SUCH DAMAGE.
+
+
 Building libsecondlife
 ----------------------
 
@@ -15,3 +44,4 @@
 If you have any questions, stop by #libsl on EFNet in IRC
 
 <A HREF="http://www.libsecondlife.org/">http://www.libsecondlife.org/</A>
+

Modified: branches/aditi/libsecondlife-cs/Region.cs
===================================================================
--- branches/aditi/libsecondlife-cs/Region.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/Region.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -53,11 +53,11 @@
         public Dictionary&lt;int, Parcel&gt; Parcels;
 
         /// &lt;summary&gt;&lt;/summary&gt;
-        public LLUUID ID;
+        public LLUUID ID = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
         public ulong Handle;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public string Name;
+        public string Name = &quot;&quot;;
         /// &lt;summary&gt;&lt;/summary&gt;
         public byte[] ParcelOverlay;
         /// &lt;summary&gt;&lt;/summary&gt;
@@ -88,28 +88,45 @@
         /// &lt;summary&gt;&lt;/summary&gt;
         public float WaterHeight;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public LLUUID SimOwner;
+        public LLUUID SimOwner = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public LLUUID TerrainBase0;
+        public LLUUID TerrainBase0 = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public LLUUID TerrainBase1;
+        public LLUUID TerrainBase1 = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public LLUUID TerrainBase2;
+        public LLUUID TerrainBase2 = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public LLUUID TerrainBase3;
+        public LLUUID TerrainBase3 = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public LLUUID TerrainDetail0;
+        public LLUUID TerrainDetail0 = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public LLUUID TerrainDetail1;
+        public LLUUID TerrainDetail1 = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public LLUUID TerrainDetail2;
+        public LLUUID TerrainDetail2 = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public LLUUID TerrainDetail3;
+        public LLUUID TerrainDetail3 = LLUUID.Zero;
         /// &lt;summary&gt;&lt;/summary&gt;
         public bool IsEstateManager;
         /// &lt;summary&gt;&lt;/summary&gt;
         public EstateTools Estate;
 
+        /// &lt;summary&gt;&lt;/summary&gt;
+        private GridRegion _GridRegionData = null;
+        public GridRegion GridRegionData
+        {
+            get
+            {
+                if (_GridRegionData == null)
+                {
+                    if ((Name != null) &amp;&amp; (!Name.Equals(&quot;&quot;)))
+                    {
+                        _GridRegionData = Client.Grid.GetGridRegion(Client.Network.CurrentSim.Region.Name);
+                    }
+                }
+                return _GridRegionData;
+            }
+        }
+
         private SecondLife Client;
 
         /// &lt;summary&gt;
@@ -120,21 +137,10 @@
         {
             Estate = new EstateTools(client);
             Client = client;
-            ID = new LLUUID();
             ParcelOverlay = new byte[4096];
             ParcelMarked = new int[64, 64];
 
             Parcels = new Dictionary&lt;int, Parcel&gt;();
-
-            SimOwner = new LLUUID();
-            TerrainBase0 = new LLUUID();
-            TerrainBase1 = new LLUUID();
-            TerrainBase2 = new LLUUID();
-            TerrainBase3 = new LLUUID();
-            TerrainDetail0 = new LLUUID();
-            TerrainDetail1 = new LLUUID();
-            TerrainDetail2 = new LLUUID();
-            TerrainDetail3 = new LLUUID();
         }
 
         /// &lt;summary&gt;
@@ -230,25 +236,6 @@
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
-        /// &lt;param name=&quot;prim&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;avatarPosition&quot;&gt;&lt;/param&gt;
-        public void RezObject(PrimObject prim, LLVector3 position, LLVector3 avatarPosition)
-        {
-            // FIXME:
-            //byte[] textureEntry = new byte[40];
-            //Array.Copy(prim.Texture.Data, textureEntry, 16);
-            //textureEntry[35] = 0xe0; // No clue
-
-            //Packet objectAdd = libsecondlife.Packets.Object.ObjectAdd(Client.Protocol, Client.Network.AgentID,
-            //        LLUUID.GenerateUUID(), avatarPosition,
-            //        position, prim, textureEntry);
-            //Client.Network.SendPacket(objectAdd);
-        }
-
-        /// &lt;summary&gt;
-        /// 
-        /// &lt;/summary&gt;
         public void FillParcels()
         {
             // Begins filling parcels
@@ -294,64 +281,5 @@
         {
             return ID.GetHashCode();
         }
-
-        /// &lt;summary&gt;
-        /// 
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;o&quot;&gt;&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-        public override bool Equals(object o)
-        {
-            if (!(o is Region))
-            {
-                return false;
-            }
-
-            Region region = (Region)o;
-
-            return (region.ID == ID);
-        }
-
-        /// &lt;summary&gt;
-        /// 
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;lhs&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;rhs&quot;&gt;&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-        public static bool operator ==(Region lhs, Region rhs)
-        {
-            try
-            {
-                return (lhs.ID == rhs.ID);
-            }
-            catch (NullReferenceException)
-            {
-                bool lhsnull = false;
-                bool rhsnull = false;
-
-                if (lhs == null || lhs.ID == null || lhs.ID.Data == null || lhs.ID.Data.Length == 0)
-                {
-                    lhsnull = true;
-                }
-
-                if (rhs == null || rhs.ID == null || rhs.ID.Data == null || rhs.ID.Data.Length == 0)
-                {
-                    rhsnull = true;
-                }
-
-                return (lhsnull == rhsnull);
-            }
-        }
-
-        /// &lt;summary&gt;
-        /// 
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;lhs&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;rhs&quot;&gt;&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-        public static bool operator !=(Region lhs, Region rhs)
-        {
-            return !(lhs == rhs);
-        }
     }
 }

Modified: branches/aditi/libsecondlife-cs/SecondLife.cs
===================================================================
--- branches/aditi/libsecondlife-cs/SecondLife.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/SecondLife.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -27,6 +27,7 @@
 using System;
 using System.Collections.Generic;
 using libsecondlife.Packets;
+using libsecondlife.AssetSystem;
 
 namespace libsecondlife
 {
@@ -61,13 +62,41 @@
         public ObjectManager Objects;
         /// &lt;summary&gt;Group Subsystem&lt;/summary&gt;
         public GroupManager Groups;
-        /// &lt;summary&gt;&lt;/summary&gt;
-        public LogCallback OnLogMessage;
-        /// &lt;summary&gt;Debug flag&lt;/summary&gt;
-        public bool Debug;
+        /// &lt;summary&gt;Throttling Subsystem&lt;/summary&gt;
+        public AgentThrottle Throttle;
 
+        private ImageManager _ImageManager;
+        /// &lt;summary&gt;Image Subsystem&lt;/summary&gt;
+        public ImageManager Images
+        {
+            get
+            {
+                if (_ImageManager == null)
+                {
+                    _ImageManager = new ImageManager(this);
+                    return _ImageManager;
+                }
+                else
+                {
+                    return _ImageManager;
+                }
+            }
+
+            set
+            {
+                _ImageManager = value;
+            }
+        }
+
+        /// &lt;summary&gt;Triggered whenever a message is logged.
+        /// If this is left null, log messages will go to 
+        /// the console&lt;/summary&gt;
+        public event LogCallback OnLogMessage;
+        /// &lt;summary&gt;Whether to log debug messages&lt;/summary&gt;
+        public bool Debug = true;
+
         /// &lt;summary&gt;
-        /// Constructor.
+        /// Default constructor
         /// &lt;/summary&gt;
         public SecondLife()
         {
@@ -78,13 +107,13 @@
             Grid = new GridManager(this);
             Objects = new ObjectManager(this);
             Groups = new GroupManager(this);
-            Debug = true;
+            Throttle = new AgentThrottle(this);
         }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
-        /// &lt;returns&gt;Client Avatar's Full Name&lt;/returns&gt;
+        /// &lt;returns&gt;Client avatar's full name&lt;/returns&gt;
         public override string ToString()
         {
             return Self.FirstName + &quot; &quot; + Self.LastName;
@@ -102,12 +131,14 @@
         /// Send a log message to the debugging output system
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;message&quot;&gt;The log message&lt;/param&gt;
-        /// &lt;param name=&quot;level&quot;&gt;From the LogLevel enum, either Info, Warning, or Error&lt;/param&gt;
+        /// &lt;param name=&quot;level&quot;&gt;The severity of the log entry&lt;/param&gt;
         public void Log(string message, Helpers.LogLevel level)
         {
+            if (level == Helpers.LogLevel.Debug &amp;&amp; !Debug) return;
+
             if (OnLogMessage != null)
             {
-                ;
+                OnLogMessage(message, level);
             }
             else
             {
@@ -128,7 +159,7 @@
             {
                 if (OnLogMessage != null)
                 {
-                    ;
+                    OnLogMessage(message, Helpers.LogLevel.Debug);
                 }
                 else
                 {
@@ -137,384 +168,4 @@
             }
         }
     }
-
-    /// &lt;summary&gt;
-    /// Static helper functions and global variables
-    /// &lt;/summary&gt;
-    public class Helpers
-    {
-        /// &lt;summary&gt;The version of libsecondlife (not the SL protocol itself)&lt;/summary&gt;
-        public readonly static string VERSION = &quot;libsecondlife 0.0.9&quot;;
-        /// &lt;summary&gt;This header flag signals that ACKs are appended to the packet&lt;/summary&gt;
-        public const byte MSG_APPENDED_ACKS = 0x10;
-        /// &lt;summary&gt;This header flag signals that this packet has been sent before&lt;/summary&gt;
-        public const byte MSG_RESENT = 0x20;
-        /// &lt;summary&gt;This header flags signals that an ACK is expected for this packet&lt;/summary&gt;
-        public const byte MSG_RELIABLE = 0x40;
-        /// &lt;summary&gt;This header flag signals that the message is compressed using zerocoding&lt;/summary&gt;
-        public const byte MSG_ZEROCODED = 0x80;
-
-        /// &lt;summary&gt;
-        /// Passed to SecondLife.Log() to identify the severity of a log entry
-        /// &lt;/summary&gt;
-        public enum LogLevel
-        {
-            /// &lt;summary&gt;Non-noisy useful information, may be helpful in 
-            /// debugging a problem&lt;/summary&gt;
-            Info,
-            /// &lt;summary&gt;A non-critical error occurred. A warning will not 
-            /// prevent the rest of libsecondlife from operating as usual, 
-            /// although it may be indicative of an underlying issue&lt;/summary&gt;
-            Warning,
-            /// &lt;summary&gt;A critical error has occurred. Generally this will 
-            /// be followed by the network layer shutting down, although the 
-            /// stability of libsecondlife after an error is uncertain&lt;/summary&gt;
-            Error
-        };
-
-        /// &lt;summary&gt;
-        /// Packs to 32-bit unsigned integers in to a 64-bit unsigned integer
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;a&quot;&gt;The left-hand (or X) value&lt;/param&gt;
-        /// &lt;param name=&quot;b&quot;&gt;The right-hand (or Y) value&lt;/param&gt;
-        /// &lt;returns&gt;A 64-bit integer containing the two 32-bit input values&lt;/returns&gt;
-        public static ulong UIntsToLong(uint a, uint b)
-        {
-            return (ulong)(((ulong)a &lt;&lt; 32) + (ulong)b);
-        }
-
-        /// &lt;summary&gt;
-        /// Unpacks two 32-bit unsigned integers from a 64-bit unsigned integer
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;a&quot;&gt;The 64-bit input integer&lt;/param&gt;
-        /// &lt;param name=&quot;b&quot;&gt;The left-hand (or X) output value&lt;/param&gt;
-        /// &lt;param name=&quot;c&quot;&gt;The right-hand (or Y) output value&lt;/param&gt;
-        public static void LongToUInts(ulong a, out uint b, out uint c)
-        {
-            b = (uint)(a &gt;&gt; 32);
-            c = (uint)(a &amp; 0x00000000FFFFFFFF);
-        }
-
-        /// &lt;summary&gt;
-        /// Convert a variable length field (byte array) to a string.
-        /// &lt;/summary&gt;
-        /// &lt;remarks&gt;If the byte array has unprintable characters in it, a 
-        /// hex dump will be put in the string instead&lt;/remarks&gt;
-        /// &lt;param name=&quot;bytes&quot;&gt;The byte array to convert to a string&lt;/param&gt;
-        /// &lt;returns&gt;A UTF8 string, minus the null terminator&lt;/returns&gt;
-        public static string FieldToString(byte[] bytes)
-        {
-            return FieldToString(bytes, &quot;&quot;);
-        }
-
-        /// &lt;summary&gt;
-        /// Convert a variable length field (byte array) to a string, with a
-        /// field name prepended to each line of the output.
-        /// &lt;/summary&gt;
-        /// &lt;remarks&gt;If the byte array has unprintable characters in it, a 
-        /// hex dump will be put in the string instead&lt;/remarks&gt;
-        /// &lt;param name=&quot;bytes&quot;&gt;The byte array to convert to a string&lt;/param&gt;
-        /// &lt;param name=&quot;fieldName&quot;&gt;A field name to prepend to each line of output&lt;/param&gt;
-        /// &lt;returns&gt;A UTF8 string, minus the null terminator&lt;/returns&gt;
-        public static string FieldToString(byte[] bytes, string fieldName)
-        {
-            string output = &quot;&quot;;
-            bool printable = true;
-
-            for (int i = 0; i &lt; bytes.Length; ++i)
-            {
-                // Check if there are any unprintable characters in the array
-                if ((bytes[i] &lt; 0x20 || bytes[i] &gt; 0x7E) &amp;&amp; bytes[i] != 0x09
-                    &amp;&amp; bytes[i] != 0x0D &amp;&amp; bytes[i] != 0x0A &amp;&amp; bytes[i] != 0x00)
-                {
-                    printable = false;
-                    break;
-                }
-            }
-
-            if (printable)
-            {
-                if (fieldName.Length &gt; 0)
-                {
-                    output += fieldName + &quot;: &quot;;
-                }
-
-                output += System.Text.Encoding.UTF8.GetString(bytes).Replace(&quot;\0&quot;, &quot;&quot;);
-            }
-            else
-            {
-                for (int i = 0; i &lt; bytes.Length; i += 16)
-                {
-                    if (i != 0) { output += &quot;\n&quot;; }
-                    if (fieldName != &quot;&quot;) { output += fieldName + &quot;: &quot;; }
-
-                    for (int j = 0; j &lt; 16; j++)
-                    {
-                        if ((i + j) &lt; bytes.Length)
-                        {
-                            string s = String.Format(&quot;{0:X} &quot;, bytes[i + j]);
-                            if (s.Length == 2)
-                            {
-                                s = &quot;0&quot; + s;
-                            }
-
-                            output += s;
-                        }
-                        else
-                        {
-                            output += &quot;   &quot;;
-                        }
-                    }
-
-                    for (int j = 0; j &lt; 16 &amp;&amp; (i + j) &lt; bytes.Length; j++)
-                    {
-                        if (bytes[i + j] &gt;= 0x20 &amp;&amp; bytes[i + j] &lt; 0x7E)
-                        {
-                            output += (char)bytes[i + j];
-                        }
-                        else
-                        {
-                            output += &quot;.&quot;;
-                        }
-                    }
-                }
-            }
-
-            return output;
-        }
-
-        /// &lt;summary&gt;
-        /// Convert a UTF8 string to a byte array
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;str&quot;&gt;The string to convert to a byte array&lt;/param&gt;
-        /// &lt;returns&gt;A null-terminated byte array&lt;/returns&gt;
-        public static byte[] StringToField(string str)
-        {
-            if (!str.EndsWith(&quot;\0&quot;)) { str += &quot;\0&quot;; }
-            return System.Text.UTF8Encoding.UTF8.GetBytes(str);
-        }
-
-        public static uint GetUnixTime()
-        {
-            TimeSpan ts = (DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0));
-            return (uint)ts.TotalSeconds;
-        }
-
-        /// &lt;summary&gt;
-        /// Decode a zerocoded byte array, used to decompress packets marked
-        /// with the zerocoded flag
-        /// &lt;/summary&gt;
-        /// &lt;remarks&gt;Any time a zero is encountered, the next byte is a count 
-        /// of how many zeroes to expand. One zero is encoded with 0x00 0x01, 
-        /// two zeroes is 0x00 0x02, three zeroes is 0x00 0x03, etc. The 
-        /// first four bytes are copied directly to the output buffer.
-        /// &lt;/remarks&gt;
-        /// &lt;param name=&quot;src&quot;&gt;The byte array to decode&lt;/param&gt;
-        /// &lt;param name=&quot;srclen&quot;&gt;The length of the byte array to decode&lt;/param&gt;
-        /// &lt;param name=&quot;dest&quot;&gt;The output byte array to decode to&lt;/param&gt;
-        /// &lt;returns&gt;The length of the output buffer&lt;/returns&gt;
-        public static int ZeroDecode(byte[] src, int srclen, byte[] dest)
-        {
-            uint zerolen = 0;
-
-            Array.Copy(src, 0, dest, 0, 4);
-            zerolen += 4;
-
-            //int bodylen;
-            //if ((src[0] &amp; MSG_APPENDED_ACKS) == 0)
-            //{
-            //    bodylen = srclen;
-            //}
-            //else
-            //{
-            //    bodylen = srclen - src[srclen - 1] * 4 - 1;
-            //}
-            int bodylen = srclen;
-
-            uint i;
-            for (i = zerolen; i &lt; bodylen; i++)
-            {
-                if (src[i] == 0x00)
-                {
-                    for (byte j = 0; j &lt; src[i + 1]; j++)
-                    {
-                        dest[zerolen++] = 0x00;
-                    }
-
-                    i++;
-                }
-                else
-                {
-                    dest[zerolen++] = src[i];
-                }
-            }
-
-            // HACK: Fix truncated zerocoded messages
-            for (uint j = zerolen; j &lt; zerolen + 16; j++)
-            {
-                dest[j] = 0;
-            }
-            zerolen += 16;
-
-            // copy appended ACKs
-            for (; i &lt; srclen; i++)
-            {
-                dest[zerolen++] = src[i];
-            }
-
-            return (int)zerolen;
-        }
-
-        /// &lt;summary&gt;
-        /// Decode enough of a byte array to get the packet ID.  Data before and
-        /// after the packet ID is undefined.
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;src&quot;&gt;The byte array to decode&lt;/param&gt;
-        /// &lt;param name=&quot;dest&quot;&gt;The output byte array to encode to&lt;/param&gt;
-        public static void ZeroDecodeCommand(byte[] src, byte[] dest)
-        {
-            for (int srcPos = 4, destPos = 4; destPos &lt; 8; ++srcPos)
-            {
-                if (src[srcPos] == 0x00)
-                {
-                    for (byte j = 0; j &lt; src[srcPos + 1]; ++j)
-                    {
-                        dest[destPos++] = 0x00;
-                    }
-
-                    ++srcPos;
-                }
-                else
-                {
-                    dest[destPos++] = src[srcPos];
-                }
-            }
-        }
-
-        /// &lt;summary&gt;
-        /// Encode a byte array with zerocoding. Used to compress packets marked
-        /// with the zerocoded flag. Any zeroes in the array are compressed down
-        /// to a single zero byte followed by a count of how many zeroes to expand
-        /// out. A single zero becomes 0x00 0x01, two zeroes becomes 0x00 0x02,
-        /// three zeroes becomes 0x00 0x03, etc. The first four bytes are copied
-        /// directly to the output buffer.
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;src&quot;&gt;The byte array to encode&lt;/param&gt;
-        /// &lt;param name=&quot;srclen&quot;&gt;The length of the byte array to encode&lt;/param&gt;
-        /// &lt;param name=&quot;dest&quot;&gt;The output byte array to encode to&lt;/param&gt;
-        /// &lt;returns&gt;The length of the output buffer&lt;/returns&gt;
-        public static int ZeroEncode(byte[] src, int srclen, byte[] dest)
-        {
-            uint zerolen = 0;
-            byte zerocount = 0;
-
-            Array.Copy(src, 0, dest, 0, 4);
-            zerolen += 4;
-
-            int bodylen;
-            if ((src[0] &amp; MSG_APPENDED_ACKS) == 0)
-            {
-                bodylen = srclen;
-            }
-            else
-            {
-                bodylen = srclen - src[srclen - 1] * 4 - 1;
-            }
-
-            uint i;
-            for (i = zerolen; i &lt; bodylen; i++)
-            {
-                if (src[i] == 0x00)
-                {
-                    zerocount++;
-
-                    if (zerocount == 0)
-                    {
-                        dest[zerolen++] = 0x00;
-                        dest[zerolen++] = 0xff;
-                        zerocount++;
-                    }
-                }
-                else
-                {
-                    if (zerocount != 0)
-                    {
-                        dest[zerolen++] = 0x00;
-                        dest[zerolen++] = (byte)zerocount;
-                        zerocount = 0;
-                    }
-
-                    dest[zerolen++] = src[i];
-                }
-            }
-
-            if (zerocount != 0)
-            {
-                dest[zerolen++] = 0x00;
-                dest[zerolen++] = (byte)zerocount;
-            }
-
-            // copy appended ACKs
-            for (; i &lt; srclen; i++)
-            {
-                dest[zerolen++] = src[i];
-            }
-
-            return (int)zerolen;
-        }
-
-        /// &lt;summary&gt;
-        /// Calculates the CRC (cyclic redundancy check) needed to upload inventory.
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;creationDate&quot;&gt;Creation date&lt;/param&gt;
-        /// &lt;param name=&quot;saleType&quot;&gt;Sale type&lt;/param&gt;
-        /// &lt;param name=&quot;invType&quot;&gt;Inventory type&lt;/param&gt;
-        /// &lt;param name=&quot;type&quot;&gt;Type&lt;/param&gt;
-        /// &lt;param name=&quot;assetID&quot;&gt;Asset ID&lt;/param&gt;
-        /// &lt;param name=&quot;groupID&quot;&gt;Group ID&lt;/param&gt;
-        /// &lt;param name=&quot;salePrice&quot;&gt;Sale price&lt;/param&gt;
-        /// &lt;param name=&quot;ownerID&quot;&gt;Owner ID&lt;/param&gt;
-        /// &lt;param name=&quot;creatorID&quot;&gt;Creator ID&lt;/param&gt;
-        /// &lt;param name=&quot;itemID&quot;&gt;Item ID&lt;/param&gt;
-        /// &lt;param name=&quot;folderID&quot;&gt;Folder ID&lt;/param&gt;
-        /// &lt;param name=&quot;everyoneMask&quot;&gt;Everyone mask (permissions)&lt;/param&gt;
-        /// &lt;param name=&quot;flags&quot;&gt;Flags&lt;/param&gt;
-        /// &lt;param name=&quot;nextOwnerMask&quot;&gt;Next owner mask (permissions)&lt;/param&gt;
-        /// &lt;param name=&quot;groupMask&quot;&gt;Group mask (permissions)&lt;/param&gt;
-        /// &lt;param name=&quot;ownerMask&quot;&gt;Owner mask (permisions)&lt;/param&gt;
-        /// &lt;returns&gt;The calculated CRC&lt;/returns&gt;
-        public static uint InventoryCRC(int creationDate, byte saleType, sbyte invType, sbyte type,
-            LLUUID assetID, LLUUID groupID, int salePrice, LLUUID ownerID, LLUUID creatorID,
-            LLUUID itemID, LLUUID folderID, uint everyoneMask, uint flags, uint nextOwnerMask,
-            uint groupMask, uint ownerMask)
-        {
-            uint CRC = 0;
-
-            // IDs
-            CRC += assetID.CRC(); // AssetID
-            CRC += folderID.CRC(); // FolderID
-            CRC += itemID.CRC(); // ItemID
-
-            // Permission stuff
-            CRC += creatorID.CRC(); // CreatorID
-            CRC += ownerID.CRC(); // OwnerID
-            CRC += groupID.CRC(); // GroupID
-
-            // CRC += another 4 words which always seem to be zero -- unclear if this is a LLUUID or what
-            CRC += ownerMask;
-            CRC += nextOwnerMask;
-            CRC += everyoneMask;
-            CRC += groupMask;
-
-            // The rest of the CRC fields
-            CRC += flags; // Flags
-            CRC += (uint)invType; // InvType
-            CRC += (uint)type; // Type 
-            CRC += (uint)creationDate; // CreationDate
-            CRC += (uint)salePrice;    // SalePrice
-            CRC += (uint)((uint)saleType * 0x07073096); // SaleType
-
-            return CRC;
-        }
-    }
 }

Modified: branches/aditi/libsecondlife-cs/Textures.cs
===================================================================
--- branches/aditi/libsecondlife-cs/Textures.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/Textures.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -27,30 +27,80 @@
 using System;
 using System.Collections.Generic;
 using System.Text;
+using System.IO;
 
 namespace libsecondlife
 {
     /// &lt;summary&gt;
     /// 
     /// &lt;/summary&gt;
+    public enum Bumpiness
+    {
+        None = 0,
+        Brightness = 1,
+        Darkness = 2,
+        Woodgrain = 3,
+        Bark = 4,
+        Bricks = 5,
+        Checker = 6,
+        Concrete = 7,
+        Crustytile = 8,
+        Cutstone = 9,
+        Discs = 10,
+        Gravel = 11,
+        Petridish = 12,
+        Siding = 13,
+        Stonetile = 14,
+        Stucco = 15,
+        Suction = 16,
+        Weave = 17
+    }
+
+    /// &lt;summary&gt;
+    /// 
+    /// &lt;/summary&gt;
+    public enum Shininess
+    {
+        None = 0,
+        Low = 0x40,
+        Medium = 0x80,
+        High = 0xC0
+    }
+
+    /// &lt;summary&gt;
+    /// 
+    /// &lt;/summary&gt;
+    public enum Mapping
+    {
+        Default = 0,
+        Planar = 2
+    }
+
+    /// &lt;summary&gt;
+    /// 
+    /// &lt;/summary&gt;
     public class TextureEntry
     {
         /// &lt;summary&gt;&lt;/summary&gt;
         public TextureEntryFace DefaultTexture;
         /// &lt;summary&gt;&lt;/summary&gt;
-        public TextureEntryAnimation Animation;
+        public Dictionary&lt;uint, TextureEntryFace&gt; FaceTextures;
 
-        private SecondLife Client;
-        private Dictionary&lt;uint, TextureEntryFace&gt; Textures;
-
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
-        public TextureEntry(SecondLife client)
+        public TextureEntry()
         {
-            Client = client;
-            Textures = new Dictionary&lt;uint, TextureEntryFace&gt;();
+            FaceTextures = new Dictionary&lt;uint, TextureEntryFace&gt;();
+            //DefaultTexture = new TextureEntryFace(null);
+            DefaultTexture = null;
+        }
+
+        public TextureEntry(LLUUID textureID)
+        {
+            FaceTextures = new Dictionary&lt;uint, TextureEntryFace&gt;();
             DefaultTexture = new TextureEntryFace(null);
+            DefaultTexture.TextureID = textureID;
         }
 
         /// &lt;summary&gt;
@@ -58,16 +108,15 @@
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;pos&quot;&gt;&lt;/param&gt;
-        public TextureEntry(SecondLife client, byte[] data, int pos)
+        public TextureEntry(byte[] data, int pos, int length)
         {
-            Client = client;
-            FromBytes(data, pos);
+            FromBytes(data, pos, length);
         }
 
         public TextureEntryFace GetFace(uint index)
         {
-            if (Textures.ContainsKey(index))
-                return Textures[index];
+            if (FaceTextures.ContainsKey(index))
+                return FaceTextures[index];
             else
                 return DefaultTexture;
         }
@@ -79,22 +128,234 @@
         /// &lt;returns&gt;&lt;/returns&gt;
         public TextureEntryFace SetFace(uint index)
         {
-            if (!Textures.ContainsKey(index))
-                Textures[index] = new TextureEntryFace(this.DefaultTexture);
+            if (!FaceTextures.ContainsKey(index))
+                FaceTextures[index] = new TextureEntryFace(this.DefaultTexture);
 
-            return Textures[index];
+            return FaceTextures[index];
         }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
-        public byte[] ToBytes()
+        public byte[] GetBytes()
         {
-            byte[] bytes = new byte[0];
+            if (DefaultTexture == null)
+            {
+                return new byte[0];
+            }
+
+            MemoryStream memStream = new MemoryStream();
+            BinaryWriter binWriter = new BinaryWriter(memStream);
+
+            Dictionary&lt;LLUUID, uint&gt; TextureIDs = new Dictionary&lt;LLUUID,uint&gt;();
+            Dictionary&lt;uint, uint&gt; RGBAs = new Dictionary&lt;uint, uint&gt;();
+            Dictionary&lt;short, uint&gt; RepeatUs = new Dictionary&lt;short, uint&gt;();
+            Dictionary&lt;short, uint&gt; RepeatVs = new Dictionary&lt;short, uint&gt;();
+            Dictionary&lt;short, uint&gt; OffsetUs = new Dictionary&lt;short, uint&gt;();
+            Dictionary&lt;short, uint&gt; OffsetVs = new Dictionary&lt;short, uint&gt;();
+            Dictionary&lt;short, uint&gt; Rotations = new Dictionary&lt;short, uint&gt;();
+            Dictionary&lt;byte, uint&gt; Flag1s = new Dictionary&lt;byte, uint&gt;();
+            Dictionary&lt;byte, uint&gt; Flag2s = new Dictionary&lt;byte, uint&gt;();
+            foreach (KeyValuePair&lt;uint,TextureEntryFace&gt; face in FaceTextures)
+            {
+                if (face.Value.TextureID != DefaultTexture.TextureID)
+                {
+                    if (TextureIDs.ContainsKey(face.Value.TextureID))
+                        TextureIDs[face.Value.TextureID] |= (uint)(1 &lt;&lt; (int)face.Key);
+                    else
+                        TextureIDs[face.Value.TextureID] = (uint)(1 &lt;&lt; (int)face.Key);
+                }
+
+                if (face.Value.RGBA != DefaultTexture.RGBA)
+                {
+                    if (RGBAs.ContainsKey(face.Value.RGBA))
+                        RGBAs[face.Value.RGBA] |= (uint)(1 &lt;&lt; (int)face.Key);
+                    else
+                        RGBAs[face.Value.RGBA] = (uint)(1 &lt;&lt; (int)face.Key);
+                }
+
+                short value;
+                short defaultValue;
+
+                value = RepeatShort(face.Value.RepeatU);
+                defaultValue = RepeatShort(DefaultTexture.RepeatU);
+                if (value != defaultValue)
+                {
+                    if (RepeatUs.ContainsKey(value))
+                        RepeatUs[value] |= (uint)(1 &lt;&lt; (int)face.Key);
+                    else
+                        RepeatUs[value] = (uint)(1 &lt;&lt; (int)face.Key);
+                }
+
+                value = RepeatShort(face.Value.RepeatV);
+                defaultValue = RepeatShort(DefaultTexture.RepeatV);
+                if (value != defaultValue)
+                {
+                    if (RepeatVs.ContainsKey(value))
+                        RepeatVs[value] |= (uint)(1 &lt;&lt; (int)face.Key);
+                    else
+                        RepeatVs[value] = (uint)(1 &lt;&lt; (int)face.Key);
+                }
+
+                value = OffsetShort(face.Value.OffsetU);
+                defaultValue = OffsetShort(DefaultTexture.OffsetU);
+                if (value != defaultValue)
+                {
+                    if (OffsetUs.ContainsKey(value))
+                        OffsetUs[value] |= (uint)(1 &lt;&lt; (int)face.Key);
+                    else
+                        OffsetUs[value] = (uint)(1 &lt;&lt; (int)face.Key);
+                }
+
+                value = OffsetShort(face.Value.OffsetV);
+                defaultValue = OffsetShort(DefaultTexture.OffsetV);
+                if (value != defaultValue)
+                {
+                    if (OffsetVs.ContainsKey(value))
+                        OffsetVs[value] |= (uint)(1 &lt;&lt; (int)face.Key);
+                    else
+                        OffsetVs[value] = (uint)(1 &lt;&lt; (int)face.Key);
+                }
+
+                value = RotationShort(face.Value.Rotation);
+                defaultValue = RotationShort(DefaultTexture.Rotation);
+                if (value != defaultValue)
+                {
+                    if (Rotations.ContainsKey(value))
+                        Rotations[value] |= (uint)(1 &lt;&lt; (int)face.Key);
+                    else
+                        Rotations[value] = (uint)(1 &lt;&lt; (int)face.Key);
+                }
+
+                if (face.Value.Flags1 != DefaultTexture.Flags1)
+                {
+                    if (Flag1s.ContainsKey(face.Value.Flags1))
+                        Flag1s[face.Value.Flags1] |= (uint)(1 &lt;&lt; (int)face.Key);
+                    else
+                        Flag1s[face.Value.Flags1] = (uint)(1 &lt;&lt; (int)face.Key);
+                }
+
+                if (face.Value.Flags2 != DefaultTexture.Flags2)
+                {
+                    if (Flag2s.ContainsKey(face.Value.Flags2))
+                        Flag2s[face.Value.Flags2] |= (uint)(1 &lt;&lt; (int)face.Key);
+                    else
+                        Flag2s[face.Value.Flags2] = (uint)(1 &lt;&lt; (int)face.Key);
+                }
+            }
+
+            binWriter.Write(DefaultTexture.TextureID.Data);
+            foreach (KeyValuePair&lt;LLUUID, uint&gt; kv in TextureIDs)
+            {
+                binWriter.Write(GetFaceBitfieldBytes(kv.Value));
+                binWriter.Write(kv.Key.Data);
+            }
+
+            binWriter.Write((byte)0);
+            binWriter.Write(DefaultTexture.RGBA);
+            foreach (KeyValuePair&lt;uint, uint&gt; kv in RGBAs)
+            {
+                binWriter.Write(GetFaceBitfieldBytes(kv.Value));
+                binWriter.Write(kv.Key);
+            }
+
+            binWriter.Write((byte)0);
+            binWriter.Write(RepeatShort(DefaultTexture.RepeatU));
+            foreach (KeyValuePair&lt;short, uint&gt; kv in RepeatUs)
+            {
+                binWriter.Write(GetFaceBitfieldBytes(kv.Value));
+                binWriter.Write(kv.Key);
+            }
+
+            binWriter.Write((byte)0);
+            binWriter.Write(RepeatShort(DefaultTexture.RepeatV));
+            foreach (KeyValuePair&lt;short, uint&gt; kv in RepeatVs)
+            {
+                binWriter.Write(GetFaceBitfieldBytes(kv.Value));
+                binWriter.Write(kv.Key);
+            }
+
+            binWriter.Write((byte)0);
+            binWriter.Write(OffsetShort(DefaultTexture.OffsetU));
+            foreach (KeyValuePair&lt;short, uint&gt; kv in OffsetUs)
+            {
+                binWriter.Write(GetFaceBitfieldBytes(kv.Value));
+                binWriter.Write(kv.Key);
+            }
+
+            binWriter.Write((byte)0);
+            binWriter.Write(OffsetShort(DefaultTexture.OffsetV));
+            foreach (KeyValuePair&lt;short, uint&gt; kv in OffsetVs)
+            {
+                binWriter.Write(GetFaceBitfieldBytes(kv.Value));
+                binWriter.Write(kv.Key);
+            }
+
+            binWriter.Write((byte)0);
+            binWriter.Write(RotationShort(DefaultTexture.Rotation));
+            foreach (KeyValuePair&lt;short, uint&gt; kv in Rotations)
+            {
+                binWriter.Write(GetFaceBitfieldBytes(kv.Value));
+                binWriter.Write(kv.Key);
+            }
+
+            binWriter.Write((byte)0);
+            binWriter.Write(DefaultTexture.Flags1);
+            foreach (KeyValuePair&lt;byte, uint&gt; kv in Flag1s)
+            {
+                binWriter.Write(GetFaceBitfieldBytes(kv.Value));
+                binWriter.Write(kv.Key);
+            }
+
+            binWriter.Write((byte)0);
+            binWriter.Write(DefaultTexture.Flags2);
+            foreach (KeyValuePair&lt;byte, uint&gt; kv in Flag2s)
+            {
+                binWriter.Write(GetFaceBitfieldBytes(kv.Value));
+                binWriter.Write(kv.Key);
+            }
+
+            return memStream.GetBuffer();
+        }
+
+        private byte[] GetFaceBitfieldBytes(uint bitfield)
+        {
+            int byteLength = 0;
+            uint tmpBitfield = bitfield;
+            while (tmpBitfield != 0)
+            {
+                tmpBitfield &gt;&gt;= 7;
+                byteLength++;
+            }
+
+            if (byteLength == 0)
+                return new byte[1] { 0 };
+
+            byte[] bytes = new byte[byteLength];
+            for (int i = 0; i &lt; byteLength; i++)
+            {
+                bytes[i] = (byte)((bitfield &gt;&gt; (7 * (byteLength - i - 1))) &amp; 0x7F);
+                if (i &lt; byteLength - 1)
+                    bytes[i] |= 0x80;
+            }
             return bytes;
         }
 
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public string GetXml(string name)
+        {
+            string xml = &quot;&lt;TextureEntry&gt;&quot;;
+            // FIXME: Write GetXml for TextureEntry
+            xml += &quot;&lt;/TextureEntry&gt;&quot;;
+
+            return xml;
+        }
+
         private bool ReadFaceBitfield(byte[] data, ref int pos, ref uint faceBits, ref uint bitfieldSize)
         {
             faceBits = 0;
@@ -124,6 +385,27 @@
             return (float)(QV * QF);
         }
 
+        private short QuantizeSigned(float f, float upper)
+        {
+            float QF = 32767.0F / upper;
+            return (short)(f * QF);
+        }
+
+        private short RepeatShort(float value)
+        {
+            return QuantizeSigned(value - 1.0F, 101.0F);
+        }
+
+        private short OffsetShort(float value)
+        {
+            return QuantizeSigned(value, 1.0F);
+        }
+
+        private short RotationShort(float value)
+        {
+            return QuantizeSigned(value, 359.995F);
+        }
+
         private float RepeatFloat(byte[] data, int pos)
         {
             return DequantizeSigned(data, pos, 101.0F) + 1.0F;
@@ -139,174 +421,135 @@
             return DequantizeSigned(data, pos, 359.995F);
         }
 
-        private void FromBytes(byte[] data, int pos)
+        private void FromBytes(byte[] data, int pos, int length)
         {
-	    if(data.Length==0) return;  // No TextureEntry to process
-            Textures = new Dictionary&lt;uint, TextureEntryFace&gt;();
+            FaceTextures = new Dictionary&lt;uint, TextureEntryFace&gt;();
             DefaultTexture = new TextureEntryFace(null);
 
-            // Sanity check for the minimum length
-            if (data.Length &lt; 40)
-            {
-                Client.Log(&quot;Skipping a TextureEntry, too short (&quot; + data.Length + &quot; bytes)&quot;, 
-                    Helpers.LogLevel.Warning);
-                return;
-            }
+            if (length &lt;= 0) 
+                return;  // No TextureEntry to process
 
-            bool hasAnimationData = false;
             uint BitfieldSize = 0;
             uint faceBits = 0;
             int i = pos;
 
-            try
+            //Read TextureID ---------------------------------------
+            DefaultTexture.TextureID = new LLUUID(data, i);
+            i += 16;
+
+            while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
             {
-                //Read TextureID ---------------------------------------
-                DefaultTexture.TextureID = new LLUUID(data, i);
+                LLUUID tmpUUID = new LLUUID(data, i);
                 i += 16;
 
-                while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
-                {
-                    LLUUID tmpUUID = new LLUUID(data, i);
-                    i += 16;
+                for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
+                    if ((faceBits &amp; bit) != 0)
+                        SetFace(face).TextureID = tmpUUID;
+            }
+            //Read RGBA --------------------------------------------
+            DefaultTexture.RGBA = (uint)(data[i] + (data[i + 1] &lt;&lt; 8) + (data[i + 2] &lt;&lt; 16) + (data[i + 3] &lt;&lt; 24));
+            i += 4;
 
-                    for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
-                        if ((faceBits &amp; bit) != 0)
-                            SetFace(face).TextureID = tmpUUID;
-                }
-                //Read RGBA --------------------------------------------
-                DefaultTexture.RGBA = (uint)(data[i] + (data[i + 1] &lt;&lt; 8) + (data[i + 2] &lt;&lt; 16) + (data[i + 3] &lt;&lt; 24));
+            while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
+            {
+                uint tmpUint = (uint)(data[i] + (data[i + 1] &lt;&lt; 8) + (data[i + 2] &lt;&lt; 16) + (data[i + 3] &lt;&lt; 24));
                 i += 4;
 
-                while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
-                {
-                    uint tmpUint = (uint)(data[i] + (data[i + 1] &lt;&lt; 8) + (data[i + 2] &lt;&lt; 16) + (data[i + 3] &lt;&lt; 24));
-                    i += 4;
+                for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
+                    if ((faceBits &amp; bit) != 0)
+                        SetFace(face).RGBA = tmpUint;
+            }
+            //Read RepeatU -----------------------------------------
+            DefaultTexture.RepeatU = RepeatFloat(data, i);
+            i += 2;
 
-                    for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
-                        if ((faceBits &amp; bit) != 0)
-                            SetFace(face).RGBA = tmpUint;
-                }
-                //Read RepeatU -----------------------------------------
-                DefaultTexture.RepeatU = RepeatFloat(data, i);
+            while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
+            {
+                float tmpFloat = RepeatFloat(data, i);
                 i += 2;
 
-                while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
-                {
-                    float tmpFloat = RepeatFloat(data, i);
-                    i += 2;
+                for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
+                    if ((faceBits &amp; bit) != 0)
+                        SetFace(face).RepeatU = tmpFloat;
+            }
+            //Read RepeatV -----------------------------------------
+            DefaultTexture.RepeatV = RepeatFloat(data, i);
+            i += 2;
 
-                    for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
-                        if ((faceBits &amp; bit) != 0)
-                            SetFace(face).RepeatU = tmpFloat;
-                }
-                //Read RepeatV -----------------------------------------
-                DefaultTexture.RepeatV = RepeatFloat(data, i);
+            while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
+            {
+                float tmpFloat = RepeatFloat(data, i);
                 i += 2;
 
-                while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
-                {
-                    float tmpFloat = RepeatFloat(data, i);
-                    i += 2;
+                for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
+                    if ((faceBits &amp; bit) != 0)
+                        SetFace(face).RepeatV = tmpFloat;
+            }
+            //Read OffsetU -----------------------------------------
+            DefaultTexture.OffsetU = OffsetFloat(data, i);
+            i += 2;
 
-                    for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
-                        if ((faceBits &amp; bit) != 0)
-                            SetFace(face).RepeatV = tmpFloat;
-                }
-                //Read OffsetU -----------------------------------------
-                DefaultTexture.OffsetU = OffsetFloat(data, i);
+            while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
+            {
+                float tmpFloat = OffsetFloat(data, i);
                 i += 2;
 
-                while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
-                {
-                    float tmpFloat = OffsetFloat(data, i);
-                    i += 2;
+                for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
+                    if ((faceBits &amp; bit) != 0)
+                        SetFace(face).OffsetU = tmpFloat;
+            }
+            //Read OffsetV -----------------------------------------
+            DefaultTexture.OffsetV = OffsetFloat(data, i);
+            i += 2;
 
-                    for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
-                        if ((faceBits &amp; bit) != 0)
-                            SetFace(face).OffsetU = tmpFloat;
-                }
-                //Read OffsetV -----------------------------------------
-                DefaultTexture.OffsetV = OffsetFloat(data, i);
+            while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
+            {
+                float tmpFloat = OffsetFloat(data, i);
                 i += 2;
 
-                while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
-                {
-                    float tmpFloat = OffsetFloat(data, i);
-                    i += 2;
+                for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
+                    if ((faceBits &amp; bit) != 0)
+                        SetFace(face).OffsetV = tmpFloat;
+            }
+            //Read Rotation ----------------------------------------
+            DefaultTexture.Rotation = RotationFloat(data, i);
+            i += 2;
 
-                    for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
-                        if ((faceBits &amp; bit) != 0)
-                            SetFace(face).OffsetV = tmpFloat;
-                }
-                //Read Rotation ----------------------------------------
-                DefaultTexture.Rotation = RotationFloat(data, i);
+            while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
+            {
+                float tmpFloat = RotationFloat(data, i);
                 i += 2;
 
-                while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
-                {
-                    float tmpFloat = RotationFloat(data, i);
-                    i += 2;
+                for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
+                    if ((faceBits &amp; bit) != 0)
+                        SetFace(face).Rotation = tmpFloat;
+            }
+            //Read Flags1 ------------------------------------------
+            DefaultTexture.Flags1 = data[i];
+            i++;
 
-                    for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
-                        if ((faceBits &amp; bit) != 0)
-                            SetFace(face).Rotation = tmpFloat;
-                }
-                //Read Flags1 ------------------------------------------
-                DefaultTexture.Flags1 = data[i];
+            while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
+            {
+                byte tmpByte = data[i];
                 i++;
 
-                while (ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
-                {
-                    byte tmpByte = data[i];
-                    i++;
+                for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
+                    if ((faceBits &amp; bit) != 0)
+                        SetFace(face).Flags1 = tmpByte;
+            }
+            //Read Flags2 ------------------------------------------
+            DefaultTexture.Flags2 = data[i];
+            i++;
 
-                    for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
-                        if ((faceBits &amp; bit) != 0)
-                            SetFace(face).Flags1 = tmpByte;
-                }
-                //Read Flags2 ------------------------------------------
-                DefaultTexture.Flags2 = data[i];
+            while (i - pos &lt; length &amp;&amp; ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
+            {
+                byte tmpByte = data[i];
                 i++;
 
-                while (true)
-                {
-                    if (data.Length &gt; i + 4)
-                    {
-                        //Not sure what this uint is, might just be there to indicate the beginning of animation data.
-                        uint unknownUint = (uint)(data[i] + (data[i + 1] &lt;&lt; 8) + (data[i + 2] &lt;&lt; 16) + (data[i + 3] &lt;&lt; 24));
-                        if (unknownUint == 0x10)
-                        {
-                            i += 4;
-                            hasAnimationData = true;
-                            break;
-                        }
-                    }
-
-                    if (!ReadFaceBitfield(data, ref i, ref faceBits, ref BitfieldSize))
-                        break;
-
-                    byte tmpByte = data[i];
-                    i++;
-
-                    for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
-                        if ((faceBits &amp; bit) != 0)
-                            SetFace(face).Flags2 = tmpByte;
-                }
-                //Read Animation Data ----------------------------------
-                if (hasAnimationData)
-                {
-                    Animation = new TextureEntryAnimation(data, i);
-                }
-                else
-                {
-                    Animation = null;
-                }
+                for (uint face = 0, bit = 1; face &lt; BitfieldSize; face++, bit &lt;&lt;= 1)
+                    if ((faceBits &amp; bit) != 0)
+                        SetFace(face).Flags2 = tmpByte;
             }
-            catch (Exception e)
-            {
-                Client.Log(&quot;Had a problem decoding a TextureEntry: &quot; + e.ToString(),
-                    Helpers.LogLevel.Warning);
-            }
         }
     }
 
@@ -532,7 +775,7 @@
     /// &lt;summary&gt;
     /// 
     /// &lt;/summary&gt;
-    public class TextureEntryAnimation
+    public class TextureAnimation
     {
         /// &lt;summary&gt;&lt;/summary&gt;
         public uint Flags;
@@ -550,11 +793,18 @@
         public float Rate;
 
         /// &lt;summary&gt;
+        /// Default constructor
+        /// &lt;/summary&gt;
+        public TextureAnimation()
+        {
+        }
+
+        /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;pos&quot;&gt;&lt;/param&gt;
-        public TextureEntryAnimation(byte[] data, int pos)
+        public TextureAnimation(byte[] data, int pos)
         {
             FromBytes(data, pos);
         }
@@ -563,16 +813,40 @@
         /// 
         /// &lt;/summary&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
-        public byte[] ToBytes()
+        public byte[] GetBytes()
         {
             byte[] bytes = new byte[0];
+            // FIXME: Finish TextureAnimation GetBytes() function
             return bytes;
         }
 
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public string GetXml(string name)
+        {
+            string xml = &quot;&lt;TextureAnimation&gt;&quot;;
+            xml += &quot;&lt;Flags value=\&quot;&quot; + Flags + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Face value=\&quot;&quot; + Face + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;SizeX value=\&quot;&quot; + SizeX + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;SizeY value=\&quot;&quot; + SizeY + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Start value=\&quot;&quot; + Start + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Length value=\&quot;&quot; + Length + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;Rate value=\&quot;&quot; + Rate + &quot;\&quot; /&gt;&quot;;
+            xml += &quot;&lt;/TextureAnimation&gt;&quot;;
+
+            return xml;
+        }
+
         private void FromBytes(byte[] data, int pos)
         {
             int i = pos;
 
+            if (data.Length == 0)
+                return;
+
             Flags = (uint)data[i++];
             Face = (uint)data[i++];
             SizeX = (uint)data[i++];

Modified: branches/aditi/libsecondlife-cs/Types.cs
===================================================================
--- branches/aditi/libsecondlife-cs/Types.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/Types.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -161,10 +161,18 @@
         /// &lt;returns&gt;&lt;/returns&gt;
 		public static bool operator==(LLUUID lhs, LLUUID rhs)
 		{
-			if(object.ReferenceEquals(lhs, rhs))  return true;
-			if(object.ReferenceEquals(lhs, null)) return false;
-			if(object.ReferenceEquals(rhs, null)) return false;
+            // If both are null, or both are same instance, return true
+            if (System.Object.ReferenceEquals(lhs, rhs))
+            {
+                return true;
+            }
 
+            // If one is null, but not both, return false.
+            if (((object)lhs == null) || ((object)rhs == null))
+            {
+                return false;
+            }
+
 			for (int i = 0; i &lt; 16; ++i)
 			{
 				if (lhs.Data[i] != rhs.Data[i]) return false;
@@ -239,16 +247,19 @@
 			for (int i = 0; i &lt; 16; ++i)
 			{
 				uuid += Data[i].ToString(&quot;x2&quot;);
-
 			}
 			uuid = uuid.Insert(20,&quot;-&quot;);
 			uuid = uuid.Insert(16,&quot;-&quot;);
 			uuid = uuid.Insert(12,&quot;-&quot;);
 			uuid = uuid.Insert(8,&quot;-&quot;);
 			
-
 			return uuid;
 		}
+
+        /// &lt;summary&gt;
+        /// An LLUUID with a value of all zeroes
+        /// &lt;/summary&gt;
+        public readonly static LLUUID Zero = new LLUUID();
 	}
 
     /// &lt;summary&gt;
@@ -336,6 +347,16 @@
 		}
 
         /// &lt;summary&gt;
+        /// Convert to a single xml node
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;name&quot;&gt;The desired name of the xml node&lt;/param&gt;
+        /// &lt;returns&gt;A line of xml data containing the values for this data type&lt;/returns&gt;
+        public string GetXml(string name)
+        {
+            return &quot;&lt;&quot; + name + &quot; x=\&quot;&quot; + X + &quot;\&quot; y=\&quot;&quot; + Y + &quot;\&quot; z=\&quot;&quot; + Z + &quot;\&quot; /&gt;&quot;;
+        }
+
+        /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
@@ -379,10 +400,18 @@
         /// &lt;returns&gt;&lt;/returns&gt;
 		public static bool operator==(LLVector3 lhs, LLVector3 rhs)
 		{
-			if(object.ReferenceEquals(lhs, rhs))  return true;
-			if(object.ReferenceEquals(lhs, null)) return false;
-			if(object.ReferenceEquals(rhs, null)) return false;
+            // If both are null, or both are same instance, return true
+            if (System.Object.ReferenceEquals(lhs, rhs))
+            {
+                return true;
+            }
 
+            // If one is null, but not both, return false.
+            if (((object)lhs == null) || ((object)rhs == null))
+            {
+                return false;
+            }
+
 			return (lhs.X == rhs.X &amp;&amp; lhs.Y == rhs.Y &amp;&amp; lhs.Z == rhs.Z);
 		}
 
@@ -397,6 +426,11 @@
 			return !(lhs == rhs);
 		}
 
+        public static LLVector3 operator +(LLVector3 lhs, LLVector3 rhs)
+        {
+            return new LLVector3(lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z);
+        }
+
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
@@ -407,6 +441,21 @@
         {
             return new LLVector3(lhs.X - rhs.X,lhs.Y - rhs.Y, lhs.Z - rhs.Z);
         }
+
+        public static LLVector3 operator *(LLVector3 vec, LLQuaternion quat)
+        {
+            LLQuaternion vq = new LLQuaternion(vec.X, vec.Y, vec.Z, 0);
+            LLQuaternion nq = new LLQuaternion(-quat.X, -quat.Y, -quat.Z, quat.W);
+
+            LLQuaternion result = (quat * vq) * nq;
+
+            return new LLVector3(result.X, result.Y, result.Z);
+        }
+
+        /// &lt;summary&gt;
+        /// An LLVector3 with a value of 0,0,0
+        /// &lt;/summary&gt;
+        public readonly static LLVector3 Zero = new LLVector3();
 	}
 
     /// &lt;summary&gt;
@@ -489,6 +538,11 @@
 		{
 			return X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString();
 		}
+
+        /// &lt;summary&gt;
+        /// An LLVector3d with a value of 0,0,0
+        /// &lt;/summary&gt;
+        public readonly static LLVector3d Zero = new LLVector3d();
 	}
 
     /// &lt;summary&gt;
@@ -564,6 +618,11 @@
 		{
 			return X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString() + &quot; &quot; + S.ToString();
 		}
+
+        /// &lt;summary&gt;
+        /// An LLVector4 with a value of 0,0,0,0
+        /// &lt;/summary&gt;
+        public readonly static LLVector4 Zero = new LLVector4();
 	}
 
     /// &lt;summary&gt;
@@ -633,6 +692,22 @@
         }
 
         /// &lt;summary&gt;
+        /// Build a quaternion from normalized float values
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;x&quot;&gt;X value from -1.0 to 1.0&lt;/param&gt;
+        /// &lt;param name=&quot;y&quot;&gt;Y value from -1.0 to 1.0&lt;/param&gt;
+        /// &lt;param name=&quot;z&quot;&gt;Z value from -1.0 to 1.0&lt;/param&gt;
+        public LLQuaternion(float x, float y, float z)
+        {
+            X = x;
+            Y = y;
+            Z = z;
+
+            float xyzsum = 1 - X * X - Y * Y - Z * Z;
+            W = (xyzsum &gt; 0) ? (float)Math.Sqrt(xyzsum) : 0;
+        }
+
+        /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;
@@ -653,20 +728,6 @@
         /// &lt;returns&gt;&lt;/returns&gt;
 		public byte[] GetBytes()
 		{
-            //byte[] byteArray = new byte[16];
-
-            //Array.Copy(BitConverter.GetBytes(X), 0, byteArray, 0, 4);
-            //Array.Copy(BitConverter.GetBytes(Y), 0, byteArray, 4, 4);
-            //Array.Copy(BitConverter.GetBytes(Z), 0, byteArray, 8, 4);
-            //Array.Copy(BitConverter.GetBytes(W), 0, byteArray, 12, 4);
-
-            //if(!BitConverter.IsLittleEndian) {
-            //    Array.Reverse(byteArray, 0, 4);
-            //    Array.Reverse(byteArray, 4, 4);
-            //    Array.Reverse(byteArray, 8, 4);
-            //    Array.Reverse(byteArray, 12, 4);
-            //}
-
             byte[] bytes = new byte[12];
             float norm;
 
@@ -696,12 +757,75 @@
 		}
 
         /// &lt;summary&gt;
+        /// Convert to a single xml node
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;name&quot;&gt;The desired name of the xml node&lt;/param&gt;
+        /// &lt;returns&gt;A line of xml data containing the values for this data type&lt;/returns&gt;
+        public string GetXml(string name)
+        {
+            return &quot;&lt;&quot; + name + &quot; x=\&quot;&quot; + X + &quot;\&quot; y=\&quot;&quot; + Y + &quot;\&quot; z=\&quot;&quot; + Z + &quot;\&quot; w=\&quot;&quot; + W + &quot;\&quot; /&gt;&quot;;
+        }
+
+        public override int GetHashCode()
+        {
+            float sum = X + Y + Z + W;
+            return sum.GetHashCode();
+        }
+
+        public override bool Equals(object o)
+        {
+            if (!(o is LLQuaternion)) return false;
+
+            LLQuaternion quaternion = (LLQuaternion)o;
+
+            return X == quaternion.X &amp;&amp; Y == quaternion.Y &amp;&amp; Z == quaternion.Z &amp;&amp; W == quaternion.W;
+        }
+
+        public static bool operator ==(LLQuaternion lhs, LLQuaternion rhs)
+        {
+            // If both are null, or both are same instance, return true
+            if (System.Object.ReferenceEquals(lhs, rhs))
+            {
+                return true;
+            }
+
+            // If one is null, but not both, return false.
+            if (((object)lhs == null) || ((object)rhs == null))
+            {
+                return false;
+            }
+
+            // Return true if the fields match:
+            return lhs.X == rhs.X &amp;&amp; lhs.Y == rhs.Y &amp;&amp; lhs.Z == rhs.Z &amp;&amp; lhs.W == rhs.W;
+        }
+
+        public static bool operator !=(LLQuaternion lhs, LLQuaternion rhs)
+        {
+            return !(lhs == rhs);
+        }
+
+        public static LLQuaternion operator *(LLQuaternion lhs, LLQuaternion rhs)
+        {
+            LLQuaternion ret = new LLQuaternion();
+            ret.W = lhs.W * rhs.W - lhs.X * rhs.X - lhs.Y * rhs.Y - lhs.Z * rhs.Z;
+            ret.X = lhs.W * rhs.X + lhs.X * rhs.W + lhs.Y * rhs.Z - lhs.Z * rhs.Y;
+            ret.Y = lhs.W * rhs.Y + lhs.Y * rhs.W + lhs.Z * rhs.X - lhs.X * rhs.Z;
+            ret.Z = lhs.W * rhs.Z + lhs.Z * rhs.W + lhs.X * rhs.Y - lhs.Y * rhs.X;
+            return ret;
+        }
+
+        /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
         /// &lt;returns&gt;&lt;/returns&gt;
 		public override string ToString()
 		{
-			return X.ToString() + &quot; &quot; + Y.ToString() + &quot; &quot; + Z.ToString() + &quot; &quot; + W.ToString();
+			return &quot;&lt;&quot; + X.ToString() + &quot;, &quot; + Y.ToString() + &quot;, &quot; + Z.ToString() + &quot;, &quot; + W.ToString() + &quot;&gt;&quot;;
 		}
+
+        /// &lt;summary&gt;
+        /// An LLQuaternion with a value of 0,0,0,1
+        /// &lt;/summary&gt;
+        public readonly static LLQuaternion Identity = new LLQuaternion();
 	}
 }

Modified: branches/aditi/libsecondlife-cs/XmlRpcCS/XmlRpcDeserializer.cs
===================================================================
--- branches/aditi/libsecondlife-cs/XmlRpcCS/XmlRpcDeserializer.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/XmlRpcCS/XmlRpcDeserializer.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -92,7 +92,7 @@
                             _value = _text;
                             break;
                         case DOUBLE:
-                            _value = Double.Parse(_text);
+                            _value = Double.Parse(_text, CultureInfo.InvariantCulture);
                             break;
                         case INT:
                         case ALT_INT:


Property changes on: branches/aditi/libsecondlife-cs/examples/AnimationSample
___________________________________________________________________
Name: svn:ignore
   + 
obj


Modified: branches/aditi/libsecondlife-cs/examples/AnimationSample/AnimationSample.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/AnimationSample/AnimationSample.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/AnimationSample/AnimationSample.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -50,13 +50,8 @@
 
         private void btnLogin_Click(object sender, EventArgs e)
         {
-            //Login information
-            Dictionary&lt;string, object&gt; loginParams = NetworkManager.DefaultLoginValues(txtFirst.Text, txtLast.Text, txtPassword.Text, &quot;00:00:00:00:00:00&quot;,
-                &quot;last&quot;, 1, 12, 12, 12, &quot;Win&quot;, &quot;0&quot;, &quot;animationsample&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">jessemalthus at gmail.com</A>&quot;);
-            Hashtable loginReply = new Hashtable();
-
             // Login
-            if (!client.Network.Login(loginParams))
+            if (!client.Network.Login(txtFirst.Text, txtLast.Text, txtPassword.Text, &quot;animationsample&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">jessemalthus at gmail.com</A>&quot;))
             {
                 // Login failed
                 MessageBox.Show(&quot;We're sorry, but login failed. Error: \n &quot; + client.Network.LoginError);

Copied: branches/aditi/libsecondlife-cs/examples/BodyPartMorphGenerator (from rev 649, trunk/libsecondlife-cs/examples/BodyPartMorphGenerator)


Property changes on: branches/aditi/libsecondlife-cs/examples/BodyPartMorphGenerator
___________________________________________________________________
Name: svn:ignore
   + obj



Property changes on: branches/aditi/libsecondlife-cs/examples/IA_ImageTool
___________________________________________________________________
Name: svn:ignore
   + 
obj
*.user


Modified: branches/aditi/libsecondlife-cs/examples/IA_ImageTool/IA_ImageTool.csproj
===================================================================
--- branches/aditi/libsecondlife-cs/examples/IA_ImageTool/IA_ImageTool.csproj	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/IA_ImageTool/IA_ImageTool.csproj	2006-11-29 00:53:56 UTC (rev 650)
@@ -15,7 +15,7 @@
     &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
     &lt;DebugType&gt;full&lt;/DebugType&gt;
     &lt;Optimize&gt;false&lt;/Optimize&gt;
-    &lt;OutputPath&gt;..\..\bin\&lt;/OutputPath&gt;
+    &lt;OutputPath&gt;..\..\..\bin\&lt;/OutputPath&gt;
     &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
     &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
     &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
@@ -39,6 +39,10 @@
     &lt;Compile Include=&quot;Properties\AssemblyInfo.cs&quot; /&gt;
   &lt;/ItemGroup&gt;
   &lt;ItemGroup&gt;
+    &lt;ProjectReference Include=&quot;..\..\..\libjaspernet\libjaspernet.csproj&quot;&gt;
+      &lt;Project&gt;{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}&lt;/Project&gt;
+      &lt;Name&gt;libjaspernet&lt;/Name&gt;
+    &lt;/ProjectReference&gt;
     &lt;ProjectReference Include=&quot;..\IA_SimpleInventory\IA_SimpleInventory.csproj&quot;&gt;
       &lt;Project&gt;{E464B963-46E3-4E1A-A36F-9C640C880E68}&lt;/Project&gt;
       &lt;Name&gt;IA_SimpleInventory&lt;/Name&gt;

Modified: branches/aditi/libsecondlife-cs/examples/IA_ImageTool/ImageTool.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/IA_ImageTool/ImageTool.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/IA_ImageTool/ImageTool.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -15,9 +15,10 @@
     /// &lt;/summary&gt;
     class ImageTool : SimpleInventory
     {
-        private LLUUID _ImageID;
+        private List&lt;LLUUID&gt; _ImageIDs = new List&lt;LLUUID&gt;();
         private string _FileName;
         private bool _Put;
+        private double _Rate;
 
         /// &lt;summary&gt;
         /// Used to upload/download images.
@@ -25,8 +26,9 @@
         [STAThread]
         static new void Main(string[] args)
         {
-            if (KakaduWrap.Check4Tools() == false)
+            if ( (File.Exists(&quot;libjasper.dll&quot;) == false) )
             {
+                Console.WriteLine(&quot;You need a copy of libjasper.dll, it can be found in SVN in the main trunk inside libjaspernet&quot;);
                 return;
             }
 
@@ -37,23 +39,49 @@
             }
 
 
-            LLUUID id = null;
+            List&lt;LLUUID&gt; uuidList = new List&lt;LLUUID&gt;();
             string filename = &quot;&quot;;
             bool put = false;
+            double rate = 0;
+
             if (args[3].ToLower().Equals(&quot;put&quot;))
             {
                 put = true;
-                filename = args[4];
+                if (args.Length == 6)
+                {
+                    double.TryParse(args[4], out rate);
+                    filename = args[5];
+                }
+                else
+                {
+                    filename = args[4];
+                }
             }
-            else
+            else if (args[3].ToLower().Equals(&quot;getfile&quot;))
             {
+                if (args.Length &lt; 5)
+                {
+                    ImageTool.Usage();
+                    return;
+                }
+
+                foreach( string id in File.ReadAllLines(args[4]) )
+                {
+                    uuidList.Add(id);
+                }
+
+
+            } 
+            else 
+            {
                 if (args.Length &lt; 6)
                 {
                     ImageTool.Usage();
                     return;
                 }
 
-                id = new LLUUID(args[4]);
+                uuidList = new List&lt;LLUUID&gt;();
+                uuidList.Add( new LLUUID(args[4]) );
                 if (args.Length == 6)
                 {
                     filename = args[5];
@@ -64,21 +92,28 @@
                 }
             }
 
-            ImageTool it = new ImageTool(id, filename, put);
-            it.Connect(args[0], args[1], args[2]);
-            it.doStuff();
-            it.Disconnect();
+            ImageTool it = new ImageTool(uuidList, filename, put, rate);
 
-            System.Threading.Thread.Sleep(500);
+            // Only download the inventory tree if we're planning on putting/uploading files.
+            it.DownloadInventoryOnConnect = put; 
 
-            Console.WriteLine(&quot;Done logging out.&quot;);
+            if (it.Connect(args[0], args[1], args[2]))
+            {
+                it.doStuff();
+                it.Disconnect();
+
+                System.Threading.Thread.Sleep(500);
+
+                Console.WriteLine(&quot;Done logging out.&quot;);
+            }
         }
 
-        protected ImageTool(LLUUID imageID, string filename, bool put)
+        protected ImageTool(List&lt;LLUUID&gt; imageIDs, string filename, bool put, double rate)
         {
-            _ImageID = imageID;
+            _ImageIDs = imageIDs;
             _FileName = filename;
             _Put = put;
+            _Rate = rate;
         }
 
         protected new void doStuff()
@@ -87,26 +122,65 @@
             {
                 Console.WriteLine(&quot;Reading: &quot; + _FileName);
 
-                byte[] j2cdata = KakaduWrap.ReadJ2CData(_FileName);
+                byte[] j2cdata;
 
+                if (_Rate != 0)
+                {
+                    j2cdata = KakaduWrap.ReadJ2CData(_FileName, _Rate);
+                }
+                else
+                {
+                    j2cdata = KakaduWrap.ReadJ2CData(_FileName);
+                }
+                
+
                 Console.WriteLine(&quot;Connecting to your Texture folder...&quot;);
                 InventoryFolder iFolder = AgentInventory.getFolder(&quot;Textures&quot;);
 
                 Console.WriteLine(&quot;Uploading Texture...&quot;);
-                iFolder.NewImage(_FileName, &quot;ImageTool Upload&quot;, j2cdata);
+                InventoryImage image = iFolder.NewImage(_FileName, &quot;ImageTool Upload&quot;, j2cdata);
+                Console.WriteLine(&quot;Asset id = &quot; + image.AssetID.ToStringHyphenated());
             }
             else
             {
-                Console.WriteLine(&quot;Downloading: &quot; + _ImageID);
+                foreach( LLUUID ImageID in _ImageIDs )
+                {
+                    string FileName;
+                    if (_ImageIDs.Count &gt; 1)
+                    {
+                        FileName = ImageID.ToString();
+                    }
+                    else
+                    {
+                        FileName = _FileName;
+                    }
 
-                ImageManager im = new ImageManager(base.client);
-                byte[] j2cdata = im.RequestImage(_ImageID);
+                    Console.WriteLine(&quot;Downloading: &quot; + ImageID);
 
-                Console.WriteLine(&quot;Writing to: &quot; + _FileName + &quot;.tif&quot;);
-                KakaduWrap.WriteJ2CAsTiff(_FileName + &quot;.tif&quot;, j2cdata);
+                    int start = Environment.TickCount;
+                    byte[] j2cdata;
 
-                Console.WriteLine(&quot;Writing to: &quot; + _FileName + &quot;.bmp&quot;);
-                KakaduWrap.WriteJ2CAsBmp(_FileName + &quot;.bmp&quot;, j2cdata);
+                    try
+                    {
+                        j2cdata = client.Images.RequestImage(ImageID);
+
+                        int end = Environment.TickCount;
+                        Console.WriteLine(&quot;Elapsed download time, in TickCounts: &quot; + (end - start));
+
+                        Console.WriteLine(&quot;Image Data Length :&quot; + j2cdata.Length);
+
+                        Console.WriteLine(&quot;Writing to: &quot; + FileName + &quot;.tif&quot;);
+                        File.WriteAllBytes(FileName + &quot;.tif&quot;, JasperWrapper.jasper_decode_j2c_to_tiff(j2cdata));
+
+                        Console.WriteLine(&quot;Writing to: &quot; + FileName + &quot;.tga&quot;);
+                        File.WriteAllBytes(FileName + &quot;.tga&quot;, JasperWrapper.jasper_decode_j2c_to_tga(j2cdata));
+                    }
+                    catch (Exception e)
+                    {
+                        Console.WriteLine(&quot;ERROR: Can't download image :: &quot; + e.Message);
+                    }
+                }
+
             }
 
             Console.WriteLine(&quot;Done...&quot;);
@@ -116,11 +190,15 @@
         protected static void Usage()
         {
             Console.WriteLine(&quot;Usage: ImageTool [first] [last] [password] [get] [uuid] [(filename)]&quot;);
+            Console.WriteLine(&quot;Usage: ImageTool [first] [last] [password] [getfile] [filename]&quot;);
             Console.WriteLine(&quot;Usage: ImageTool [first] [last] [password] [put] [filename]&quot;);
+            Console.WriteLine(&quot;Usage: ImageTool [first] [last] [password] [put] [bit-rate] [filename]&quot;);
 
             Console.WriteLine();
-            Console.WriteLine(&quot;Example: ImageTool John Doe Password get 0444bf21-f77e-7f63-89e9-b839ec66bc15 cloud.tif&quot;);
-            Console.WriteLine(&quot;Example: ImageTool John Doe Password put Sample (this will output a bmp and a tiff)&quot;);
+            Console.WriteLine(&quot;Example: ImageTool John Doe Password get 0444bf21-f77e-7f63-89e9-b839ec66bc15 cloud (this will output a bmp and a tiff)&quot;);
+            Console.WriteLine(&quot;Example: ImageTool John Doe Password getfile uuids.txt (this will download a list of textures, one per line)&quot;);
+            Console.WriteLine(&quot;Example: ImageTool John Doe Password put Sample.tiff&quot;);
+            Console.WriteLine(&quot;Example: ImageTool John Doe Password put 1.0 BigImage.tiff (this will compress the file with the given bit-rate)&quot;);
         }
     }
-}
\ No newline at end of file
+}

Deleted: branches/aditi/libsecondlife-cs/examples/IA_ImageTool/KakaduWrap.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/IA_ImageTool/KakaduWrap.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/IA_ImageTool/KakaduWrap.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,150 +0,0 @@
-using System;
-using System.IO;
-using System.Diagnostics;
-
-namespace IA_ImageTool
-{
-	/// &lt;summary&gt;
-	/// Summary description for ImageTools.
-	/// &lt;/summary&gt;
-	public class KakaduWrap
-	{
-        private KakaduWrap()
-		{
-		}
-
-		public static bool Check4Tools()
-		{
-			bool status = true;
-			if( File.Exists(&quot;kdu_expand.exe&quot;) == false )
-			{
-				status = false;
-				Console.WriteLine(&quot;You need kdu_expand.exe to save SL images.&quot;);
-			}
-
-			if( File.Exists(&quot;kdu_compress.exe&quot;) == false )
-			{
-				status = false;
-				Console.WriteLine(&quot;You need kdu_compress.exe to load images into SL.&quot;);
-			}
-			
-			return status;
-		}
-
-		public static void WriteJ2CToFile( string j2c_filename, byte[] J2CData )
-		{
-			FileStream fs = System.IO.File.OpenWrite( j2c_filename );
-			fs.Write(J2CData, 0, J2CData.Length);
-			fs.Close();
-		}
-
-
-        public static void Convert2Tiff(string j2c_filename, string tif_filename)
-        {
-            if (File.Exists(&quot;kdu_expand.exe&quot;) == false)
-            {
-                throw new Exception(&quot;You must have kdu_expand.exe&quot;);
-            }
-
-            if (tif_filename.ToLower().EndsWith(&quot;.tif&quot;) == false)
-            {
-                tif_filename += &quot;.tif&quot;;
-            }
-
-            string args = &quot;-i &quot; + j2c_filename + &quot; -o &quot; + tif_filename;
-            Console.WriteLine(args);
-
-            Process p = new Process();
-            p.StartInfo.UseShellExecute = false;
-            p.StartInfo.FileName = &quot;kdu_expand.exe&quot;;
-            p.StartInfo.Arguments = args;
-            p.Start();
-            p.WaitForExit();
-        }
-
-        public static void Convert2Bmp(string j2c_filename, string bmp_filename)
-        {
-            if (File.Exists(&quot;kdu_expand.exe&quot;) == false)
-            {
-                throw new Exception(&quot;You must have kdu_expand.exe&quot;);
-            }
-
-            if (bmp_filename.ToLower().EndsWith(&quot;.bmp&quot;) == false)
-            {
-                bmp_filename += &quot;.bmp&quot;;
-            }
-
-            string args = &quot;-i &quot; + j2c_filename + &quot; -o &quot; + bmp_filename;
-            Console.WriteLine(args);
-
-            Process p = new Process();
-            p.StartInfo.UseShellExecute = false;
-            p.StartInfo.FileName = &quot;kdu_expand.exe&quot;;
-            p.StartInfo.Arguments = args;
-            p.Start();
-            p.WaitForExit();
-        }
-
-        public static void WriteJ2CAsTiff(string tif_filename, byte[] J2CData)
-		{
-			String tempname = tif_filename + &quot;.j2c&quot;;
-			WriteJ2CToFile( tempname, J2CData );
-			Convert2Tiff( tempname, tif_filename );
-			File.Delete( tempname );
-		}
-
-        public static void WriteJ2CAsBmp(string bmp_filename, byte[] J2CData)
-        {
-            String tempname = bmp_filename + &quot;.j2c&quot;;
-            WriteJ2CToFile(tempname, J2CData);
-            Convert2Bmp(tempname, bmp_filename);
-            File.Delete(tempname);
-        }
-
-		/*
-		 * kdu_compress -no_info -no_weights -no_palette -i TestTexture.tif -o TestTexture.J2C
-		 */
-		public static void Convert2J2C( string tif_filename, string j2c_filename )
-		{
-			if( File.Exists(&quot;kdu_compress.exe&quot;) == false )
-			{
-				throw new Exception(&quot;You must have kdu_compress.exe&quot;);
-			}
-
-			if( j2c_filename.ToLower().EndsWith(&quot;.j2c&quot;) == false )
-			{
-				j2c_filename += &quot;.j2c&quot;;
-			}
-
-			Process p = new Process();
-			p.StartInfo.UseShellExecute = false;
-			p.StartInfo.FileName  = &quot;kdu_compress.exe&quot;;
-			p.StartInfo.Arguments = &quot;-no_info -no_weights -no_palette -i &quot; + tif_filename + &quot; -o &quot; + j2c_filename;
-			p.Start();
-			p.WaitForExit();
-		}
-
-		public static byte[] ReadJ2CData( string filename )
-		{
-			if( (filename.ToLower().EndsWith(&quot;.j2c&quot;) == false) &amp;&amp; (filename.ToLower().EndsWith(&quot;.tif&quot;) == true) )
-			{
-				string tempname = filename + &quot;.j2c&quot;;
-				Convert2J2C( filename, tempname );
-				filename = tempname;
-			}
-
-			FileStream fs = File.OpenRead( filename );
-
-			byte[] data = new byte[fs.Length];
-
-			if( fs.Length &gt; int.MaxValue )
-			{
-				throw new Exception(&quot;AssetImage.cs: Bad stuff going to happen because length bigger then Max Integer&quot;);
-			}
-
-			fs.Read(data, 0, (int)fs.Length);
-
-			return data;
-		}
-	}
-}

Copied: branches/aditi/libsecondlife-cs/examples/IA_ImageTool/KakaduWrap.cs (from rev 649, trunk/libsecondlife-cs/examples/IA_ImageTool/KakaduWrap.cs)

Modified: branches/aditi/libsecondlife-cs/examples/IA_InventoryManager/IA_InventoryManager.csproj
===================================================================
--- branches/aditi/libsecondlife-cs/examples/IA_InventoryManager/IA_InventoryManager.csproj	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/IA_InventoryManager/IA_InventoryManager.csproj	2006-11-29 00:53:56 UTC (rev 650)
@@ -15,7 +15,7 @@
     &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
     &lt;DebugType&gt;full&lt;/DebugType&gt;
     &lt;Optimize&gt;false&lt;/Optimize&gt;
-    &lt;OutputPath&gt;..\..\bin\&lt;/OutputPath&gt;
+    &lt;OutputPath&gt;..\..\..\bin\&lt;/OutputPath&gt;
     &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
     &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
     &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;

Modified: branches/aditi/libsecondlife-cs/examples/IA_InventoryManager/iManager.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/IA_InventoryManager/iManager.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/IA_InventoryManager/iManager.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -5,6 +5,7 @@
 using IA_SimpleInventory;
 using libsecondlife;
 using libsecondlife.InventorySystem;
+using libsecondlife.AssetSystem;
 
 namespace IA_InventoryManager
 {
@@ -48,7 +49,7 @@
             System.Threading.Thread.Sleep(1000);
 
             Console.WriteLine(&quot;==================================================================&quot;);
-            Console.WriteLine(&quot;The Inventory Manager program provides a simple shell for working with your Second Life[tm] Avatar's Inventory.&quot;);
+            Console.WriteLine(&quot;The Inventory Manager program provides a simple shell for working with your Second Life[tm] Avatar.&quot;);
             Console.WriteLine();
             Console.WriteLine(&quot;Type HELP for a list of available commands.&quot;);
             Console.WriteLine(&quot;-------------------------------------------&quot;);
@@ -62,12 +63,50 @@
                 Console.Write( curDirectory + &quot;&gt; &quot;);
 
                 string curCmd = Console.ReadLine();
-                string[] curCmdLine = curCmd.Split(cmdSeperators);
+                string[] curCmdLineParts = curCmd.Split(cmdSeperators);
+                List&lt;string&gt; merged = new List&lt;string&gt;();
 
+                bool inQuotedString = false;
+                string temp = &quot;&quot;;
+                foreach (string s in curCmdLineParts)
+                {
+                    if (s.StartsWith(&quot;\&quot;&quot;))
+                    {
+                        temp = s.Remove(0,1);
+                        inQuotedString = true;
+                    }
+                    else if (s.EndsWith(&quot;\&quot;&quot;))
+                    {
+                        temp += &quot; &quot; + s.Remove(s.LastIndexOf('&quot;'));
+                        merged.Add(temp);
+                        temp = &quot;&quot;;
+                        inQuotedString = false;
+                    }
+                    else
+                    {
+                        if (inQuotedString)
+                        {
+                            temp += &quot; &quot; + s;
+                        }
+                        else
+                        {
+                            merged.Add(s);
+                        }
+                    }
+                }
+
+                string[] curCmdLine = new string[merged.Count];
+                int i = 0;
+                foreach( string s in merged )
+                {
+                    curCmdLine[i++] = s;
+                }
+
                 switch (curCmdLine[0].ToLower())
                 {
                     case &quot;quit&quot;:
                     case &quot;exit&quot;:
+                    case &quot;bye&quot;:
                     case &quot;q&quot;:
                         shutdown = true;
                         break;
@@ -93,6 +132,26 @@
                         rmdir(curCmdLine);
                         break;
 
+                    case &quot;getasset&quot;:
+                        getasset(curCmdLine);
+                        break;
+
+                    case &quot;regioninfo&quot;:
+                        regioninfo(curCmdLine);
+                        break;
+
+                    case &quot;teleport&quot;:
+                        teleport(curCmdLine);
+                        break;
+
+                    case &quot;notecard&quot;:
+                        notecard(curCmdLine);
+                        break;
+
+                    case &quot;xml&quot;:
+                        xml(curCmdLine);
+                        break;
+
                     default:
                         Console.WriteLine(&quot;Unknown command '&quot; + curCmdLine[0] + &quot;'.&quot;);
                         Console.WriteLine(&quot;Type HELP for a list of available commands.&quot;);
@@ -107,12 +166,206 @@
         {
             Console.WriteLine(&quot;Currently available commands are: &quot;);
             Console.WriteLine(&quot;LS          - List contents of the current directory.&quot;);
-            Console.WriteLine(&quot;CD [dir]    - Change directory.&quot;);
-            Console.WriteLine(&quot;MKDIR [dir] - Make a new directory.&quot;);
-            Console.WriteLine(&quot;RMDIR [dir] - Remove directory.&quot;);
+            Console.WriteLine(&quot;CD          - Change directory.&quot;);
+            Console.WriteLine(&quot;MKDIR       - Make a new directory.&quot;);
+            Console.WriteLine(&quot;RMDIR       - Remove directory.&quot;);
+            Console.WriteLine(&quot;GETASSET    - Fetch an asset from SL.&quot;);
+            Console.WriteLine(&quot;REGIONINFO  - Display Grid Region Info.&quot;);
+            Console.WriteLine(&quot;TELEPORT    - Teleport to a new sim.&quot;);
+            Console.WriteLine(&quot;NOTECARD    - Create a new notecard.&quot;);
+            Console.WriteLine(&quot;XML         - Display an item as xml&quot;);
             Console.WriteLine(&quot;QUIT        - Exit the Inventory Manager.&quot;);
         }
 
+        private void xml(string[] cmdLine)
+        {
+            if (cmdLine.Length &lt; 2)
+            {
+                Console.WriteLine(&quot;Usage: XML [itemName | uuid] ([outputAsset true/false])&quot;);
+                return;
+            }
+
+            LLUUID uuid = null;
+
+            try
+            {
+                uuid = new LLUUID(cmdLine[1]);
+            }
+            catch (Exception)
+            {
+            }
+
+            InventoryFolder iFolder = AgentInventory.getFolder(curDirectory);
+
+            InventoryBase itemOfInterest = null;
+
+            foreach (InventoryBase ib in iFolder.alContents)
+            {
+                if (ib is InventoryFolder)
+                {
+                    InventoryFolder folder = (InventoryFolder)ib;
+                    if (folder.Name.Equals(cmdLine[1]) || folder.FolderID.Equals(uuid))
+                    {
+                        itemOfInterest = folder;
+                        break;
+                    }
+                }
+                else if (ib is InventoryItem)
+                {
+                    InventoryItem item = (InventoryItem)ib;
+                    if (item.Name.Equals(cmdLine[1]) || item.ItemID.Equals(uuid))
+                    {
+                        itemOfInterest = item;
+                        break;
+                    }
+                }
+            }
+
+            if (itemOfInterest == null)
+            {
+                Console.WriteLine(&quot;Could not find: &quot; + cmdLine[1]);
+                return;
+            }
+
+            if (cmdLine.Length == 3)
+            {
+                Console.WriteLine(itemOfInterest.toXML(bool.Parse(cmdLine[2])));
+            }
+            else
+            {
+                Console.WriteLine(itemOfInterest.toXML(false));
+            }
+
+        }
+
+
+        private void notecard(string[] cmdLine)
+        {
+            string NoteName = &quot;&quot;;
+            for( int i = 1; i &lt; cmdLine.Length; i++ )
+            {
+                NoteName += cmdLine[i] + &quot; &quot;;
+            }
+            NoteName = NoteName.Trim();
+
+            Console.Write(&quot;Description: &quot;);
+            string NoteDesc = Console.ReadLine();
+
+            Console.WriteLine(&quot;Please enter body, press ESC to end&quot;);
+            Console.WriteLine(&quot;----------------------------------&quot;);
+
+            StringBuilder sb = new StringBuilder();
+            ConsoleKeyInfo cki;
+            do
+            {
+                cki = Console.ReadKey(true);
+                sb.Append(cki.Key.ToString());
+            } while (cki.Key != ConsoleKey.Escape);
+
+            InventoryFolder iFolder = AgentInventory.getFolder(curDirectory);
+            iFolder.NewNotecard(cmdLine[1], NoteDesc, sb.ToString());
+
+            Console.WriteLine(&quot;Notecard '&quot; + NoteName + &quot; 'Created&quot;);
+        }
+
+        private void teleport(string[] cmdLine)
+        {
+            if (cmdLine.Length &lt; 5)
+            {
+                Console.WriteLine(&quot;Usage: teleport [sim] [x] [y] [z]&quot;);
+                Console.WriteLine(&quot;Example: teleport hooper 182 40 26&quot;);
+                return;
+            }
+
+            if (cmdLine[1].ToLower() == client.Network.CurrentSim.Region.Name.ToLower())
+            {
+                Console.WriteLine(&quot;TODO: Add the ability to teleport somewhere in the local region. &quot; +
+                    &quot;Exiting for now, please specify a region other than the current one&quot;);
+            }
+            else
+            {
+                if (client.Grid.Regions.Count == 0)
+                {
+                    Console.WriteLine(&quot;Caching estate sims...&quot;);
+                    client.Grid.AddEstateSims();
+                    System.Threading.Thread.Sleep(3000);
+                }
+
+                
+                client.Self.Teleport(cmdLine[1], new LLVector3( float.Parse(cmdLine[2]), float.Parse(cmdLine[3]), float.Parse(cmdLine[4]) ) );
+            }
+        }
+
+        private void regioninfo(string[] cmdLine)
+        {
+            if (cmdLine.Length &lt; 2)
+            {
+                Console.WriteLine(&quot;Usage: regioninfo [name]&quot;);
+                Console.WriteLine(&quot;Example: regioninfo ahern&quot;);
+                return;
+            }
+
+            string regionName = &quot;&quot;;
+            for( int i = 1; i &lt; cmdLine.Length; i++ )
+            {
+                regionName += cmdLine[i] + &quot; &quot;;
+            }
+            regionName = regionName.Trim();
+
+            GridRegion gr = client.Grid.GetGridRegion(regionName);
+            Console.WriteLine(gr);
+        }
+
+        
+
+        private void getasset(string[] cmdLine)
+        {
+            if (cmdLine.Length &lt; 2)
+            {
+                Console.WriteLine(&quot;Usage for arbitrary asset: getasset [type] [UUID]&quot;);
+                Console.WriteLine(&quot;Usage for asset of item (this works for notecards) : getasset [itemname | UUID]&quot;);
+                Console.WriteLine(&quot;Example: getasset 13 c2ca25c1fb242e41650a54901bc2d21c&quot;);
+                Console.WriteLine(&quot;Example: getasset \&quot;New Script\&quot;&quot;);
+                return;
+            }
+
+            if (cmdLine.Length == 3)
+            {
+                // Arbitrary Asset
+                Asset asset = new Asset(cmdLine[2], sbyte.Parse(cmdLine[1]), null);
+
+                if (asset.Type == 13)
+                {
+                    AgentInventory.getAssetManager().GetInventoryAsset(asset);
+                }
+                else
+                {
+                    Console.WriteLine(&quot;Can't currently retrieve assets other then type 13 using this method.  If the item is in your inventory, change directory to the same folder and try specifying the retrieval by just UUID/Name without specifying type.&quot;);
+                    return;
+                }
+
+                Console.WriteLine(asset.AssetDataToString());
+            }
+            else
+            {
+                // Asset for an item in inventory
+                InventoryFolder iFolder = AgentInventory.getFolder(curDirectory);
+                foreach (InventoryBase ib in iFolder.alContents)
+                {
+                    if (ib is InventoryItem)
+                    {
+                        InventoryItem item = (InventoryItem)ib;
+                        if (item.ItemID.Equals(cmdLine[1]) || item.Name.Equals(cmdLine[1]))
+                        {
+                            Console.WriteLine(&quot;Asset for &quot; + item.Name + &quot; [&quot; + item.ItemID + &quot;]&quot;);
+                            Console.WriteLine(item.Asset.AssetDataToString());
+                        }
+                    }
+                }
+            }
+
+        }
+
         private void rmdir(string[] cmdLine)
         {
             if (cmdLine.Length &lt; 2)
@@ -234,12 +487,12 @@
                 if (ib is InventoryFolder)
                 {
                     InventoryFolder folder = (InventoryFolder)ib;
-                    Console.WriteLine(TYPE_DIR + folder.Name);
+                    Console.WriteLine(TYPE_DIR + &quot;&lt;&quot; + folder.FolderID.ToStringHyphenated() + &quot;&gt; &quot; + folder.Name);
                 }
                 else
                 {
                     InventoryItem item = (InventoryItem)ib;
-                    Console.WriteLine(TYPE_ITEM + item.Name);
+                    Console.WriteLine(TYPE_ITEM + &quot;&lt;&quot; + item.ItemID.ToStringHyphenated() + &quot;&gt; &quot; + item.Name);
                 }
             }
         }

Copied: branches/aditi/libsecondlife-cs/examples/IA_MultiImageUpload (from rev 649, trunk/libsecondlife-cs/examples/IA_MultiImageUpload)


Property changes on: branches/aditi/libsecondlife-cs/examples/IA_MultiImageUpload
___________________________________________________________________
Name: svn:ignore
   + 
obj



Property changes on: branches/aditi/libsecondlife-cs/examples/IA_NotecardTool
___________________________________________________________________
Name: svn:ignore
   + 
obj


Modified: branches/aditi/libsecondlife-cs/examples/IA_SimpleInventory/IA_SimpleInventory.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/IA_SimpleInventory/IA_SimpleInventory.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/IA_SimpleInventory/IA_SimpleInventory.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -71,21 +71,19 @@
             }
         }
 
-        protected void Connect(string FirstName, string LastName, string Password)
+        protected bool Connect(string FirstName, string LastName, string Password)
         {
             Console.WriteLine(&quot;Attempting to connect and login to SecondLife.&quot;);
 
             // Setup Login to Second Life
-            Dictionary&lt;string, object&gt; loginParams = NetworkManager.DefaultLoginValues(FirstName, LastName,
-                Password, &quot;00:00:00:00:00:00&quot;, &quot;last&quot;, &quot;Win&quot;, &quot;0&quot;, &quot;createnotecard&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">static.sprocket at gmail.com</A>&quot;);
             Dictionary&lt;string, object&gt; loginReply = new Dictionary&lt;string, object&gt;();
 
             // Login
-            if (!client.Network.Login(loginParams))
+            if (!client.Network.Login(FirstName, LastName, Password, &quot;createnotecard&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">static.sprocket at gmail.com</A>&quot;))
             {
                 // Login failed
                 Console.WriteLine(&quot;Error logging in: &quot; + client.Network.LoginError);
-                return;
+                return false;
             }
 
             // Login was successful
@@ -109,6 +107,7 @@
                 Console.WriteLine(&quot;Downloading Inventory.&quot;);
                 AgentInventory.DownloadInventory();
             }
+            return true;
         }
 
         protected void Disconnect()
@@ -123,7 +122,15 @@
             Console.WriteLine(&quot;Dumping a copy of &quot; + client.Self.FirstName + &quot;'s inventory to the console.&quot;);
             Console.WriteLine();
 
-            Console.WriteLine(AgentInventory.getRootFolder().toXML(false));
+            if (AgentInventory != null)
+            {
+                InventoryFolder root = AgentInventory.getRootFolder();
+
+                if (root != null)
+                {
+                    Console.WriteLine(root.toXML(false));
+                }
+            }
         }
     }
 }

Copied: branches/aditi/libsecondlife-cs/examples/IA_TestAsyncImage (from rev 649, trunk/libsecondlife-cs/examples/IA_TestAsyncImage)


Property changes on: branches/aditi/libsecondlife-cs/examples/IA_TestAsyncImage
___________________________________________________________________
Name: svn:ignore
   + 
obj


Modified: branches/aditi/libsecondlife-cs/examples/ParcelDownload/ParcelDownload.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/ParcelDownload/ParcelDownload.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/ParcelDownload/ParcelDownload.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -72,7 +72,7 @@
 			{
                 Parcel parcel = (Parcel)client.Network.CurrentSim.Region.Parcels[pkey];
 				// Probably should comment this out :-)
-				//parcel.Buy(client,false,new LLUUID());
+                //parcel.Buy(client, false, LLUUID.Zero);
 				Console.WriteLine(&quot;&lt;Parcel&gt;&quot;);
 				Console.WriteLine(&quot;\tName: &quot; + parcel.Name);
 				Console.WriteLine(&quot;\tSize: &quot; + parcel.Area);


Property changes on: branches/aditi/libsecondlife-cs/examples/Teleport
___________________________________________________________________
Name: svn:ignore
   + 
obj


Modified: branches/aditi/libsecondlife-cs/examples/Teleport/Teleport.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/Teleport/Teleport.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/Teleport/Teleport.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -41,7 +41,7 @@
             if (success)
             {
                 // Get the current sim name
-                while (app.Client.Network.CurrentSim.Region.Name == null)
+                while (app.Client.Network.CurrentSim.Region.Name == &quot;&quot;)
                 {
                     System.Threading.Thread.Sleep(100);
                 }

Copied: branches/aditi/libsecondlife-cs/examples/TestClient (from rev 649, trunk/libsecondlife-cs/examples/TestClient)


Property changes on: branches/aditi/libsecondlife-cs/examples/TestClient
___________________________________________________________________
Name: svn:ignore
   + obj
TestTool.csproj.user


Modified: branches/aditi/libsecondlife-cs/examples/examples.build
===================================================================
--- branches/aditi/libsecondlife-cs/examples/examples.build	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/examples.build	2006-11-29 00:53:56 UTC (rev 650)
@@ -59,7 +59,7 @@
 
   &lt;target name=&quot;build&quot; depends=&quot;init build-dll&quot; description=&quot;Build all examples&quot;&gt;
 	&lt;foreach item=&quot;Folder&quot; in=&quot;.&quot; property=&quot;example_path&quot;&gt;
-	  &lt;call target=&quot;example&quot; unless=&quot;${string::contains(example_path,'svn') or string::contains(example_path,'IA_')}&quot;/&gt;
+	  &lt;call target=&quot;example&quot; unless=&quot;${string::contains(example_path,'svn') or string::contains(example_path,'IA_') or string::contains(example_path,'Test')}&quot;/&gt;
     &lt;/foreach&gt;
   &lt;/target&gt;
 


Property changes on: branches/aditi/libsecondlife-cs/examples/groupmanager
___________________________________________________________________
Name: svn:ignore
   + 
obj


Modified: branches/aditi/libsecondlife-cs/examples/groupmanager/frmGroupInfo.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/groupmanager/frmGroupInfo.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/groupmanager/frmGroupInfo.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -51,15 +51,25 @@
             Invoke(new MethodInvoker(UpdateProfile));
 
             // Waterdrop: new LLUUID(&quot;c77a1c21-e604-7d2c-2c89-5539ce853466&quot;)
-            ImageManager im = new ImageManager(Client);
-            byte[] j2cdata = im.RequestImage(Group.InsigniaID);
-            //
-            JasperWrapper.jas_init();
+
+            byte[] j2cdata;
+            if (Group.InsigniaID != null)
+            {
+                j2cdata = Client.Images.RequestImage(Group.InsigniaID);
+            }
+            else
+            {
+                // TODO: Add somekind of 
+                j2cdata = Client.Images.RequestImage(&quot;c77a1c21-e604-7d2c-2c89-5539ce853466&quot;);
+            }
+
             byte[] imagedata = JasperWrapper.jasper_decode_j2c_to_tiff(j2cdata);
+
             //
             MemoryStream imageStream = new MemoryStream(imagedata, false);
             Image image = Image.FromStream(imageStream, false, false);
             //
+
             picInsignia.Image = image;
         }
 
@@ -74,7 +84,7 @@
             numFee.Value = Profile.MembershipFee;
             chkMature.Checked = Profile.MaturePublish;
 
-            Client.Avatars.BeginGetAvatarName(Profile.FounderID, new AgentNamesCallback(AgentNamesHandler));
+            Client.Avatars.BeginGetAvatarName(Profile.FounderID, new AvatarManager.AgentNamesCallback(AgentNamesHandler));
         }
 
         private void AgentNamesHandler(Dictionary&lt;LLUUID, string&gt; names)
@@ -199,7 +209,7 @@
                 }
             }
 
-            Client.Avatars.BeginGetAvatarNames(requestids, new AgentNamesCallback(AgentNamesHandler));
+            Client.Avatars.BeginGetAvatarNames(requestids, new AvatarManager.AgentNamesCallback(AgentNamesHandler));
         }
 
         private void GroupTitlesHandler(Dictionary&lt;LLUUID, GroupTitle&gt; titles)

Modified: branches/aditi/libsecondlife-cs/examples/name2key/name2key.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/name2key/name2key.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/name2key/name2key.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -73,7 +73,7 @@
 			client = new SecondLife();
 
 			// Setup the callback
-			client.Network.RegisterCallback(PacketType.DirPeopleReply, new PacketCallback(QueryHandler));
+            client.Network.RegisterCallback(PacketType.DirPeopleReply, new NetworkManager.PacketCallback(QueryHandler));
 
 			// Setup the login values
             Dictionary&lt;string, object&gt; loginParams = NetworkManager.DefaultLoginValues(args[0], args[1], args[2], 


Property changes on: branches/aditi/libsecondlife-cs/examples/primexport
___________________________________________________________________
Name: svn:ignore
   + 
obj


Modified: branches/aditi/libsecondlife-cs/examples/primexport/frmPrimExport.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/primexport/frmPrimExport.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/primexport/frmPrimExport.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -4,6 +4,7 @@
 using System.Drawing;
 using System.Text;
 using System.Windows.Forms;
+using System.IO;
 using System.Collections.Generic;
 using libsecondlife;
 
@@ -19,16 +20,26 @@
         private TextBox txtLastName;
         private Button cmdConnect;
         private TextBox txtFirstName;
-        private Button cmdCapture;
+        private Button cmdExport;
         private TextBox txtLog;
-        /// &lt;summary&gt;
-        /// Required designer variable.
-        /// &lt;/summary&gt;
+        private Label label4;
+        private Label label5;
+        private Panel panel1;
+        private RadioButton radObjects;
+        private RadioButton radEntireSim;
+        private Panel panel2;
+        private RadioButton radPrimBlender;
+        private RadioButton radLibPrims;
         private System.ComponentModel.IContainer components = null;
 
+        //
         private SecondLife client;
-        private NewPrimCallback primCallback;
-        private string currentText;
+        private Dictionary&lt;ulong, PrimObject&gt; Prims = new Dictionary&lt;ulong, PrimObject&gt;();
+        private List&lt;ulong&gt; Avatars = new List&lt;ulong&gt;();
+        private List&lt;ulong&gt; Attachments = new List&lt;ulong&gt;();
+        private string CurrentText = &quot;&quot;;
+        private string Filename = &quot;&quot;;
+        private bool EntireSim = true;
 
         /// &lt;summary&gt;
         /// Clean up any resources being used.
@@ -59,9 +70,19 @@
             this.txtLastName = new System.Windows.Forms.TextBox();
             this.cmdConnect = new System.Windows.Forms.Button();
             this.txtFirstName = new System.Windows.Forms.TextBox();
-            this.cmdCapture = new System.Windows.Forms.Button();
+            this.cmdExport = new System.Windows.Forms.Button();
             this.txtLog = new System.Windows.Forms.TextBox();
+            this.label4 = new System.Windows.Forms.Label();
+            this.label5 = new System.Windows.Forms.Label();
+            this.panel1 = new System.Windows.Forms.Panel();
+            this.radObjects = new System.Windows.Forms.RadioButton();
+            this.radEntireSim = new System.Windows.Forms.RadioButton();
+            this.panel2 = new System.Windows.Forms.Panel();
+            this.radPrimBlender = new System.Windows.Forms.RadioButton();
+            this.radLibPrims = new System.Windows.Forms.RadioButton();
             this.grpLogin.SuspendLayout();
+            this.panel1.SuspendLayout();
+            this.panel2.SuspendLayout();
             this.SuspendLayout();
             // 
             // grpLogin
@@ -74,7 +95,7 @@
             this.grpLogin.Controls.Add(this.cmdConnect);
             this.grpLogin.Controls.Add(this.txtFirstName);
             this.grpLogin.Enabled = false;
-            this.grpLogin.Location = new System.Drawing.Point(12, 204);
+            this.grpLogin.Location = new System.Drawing.Point(12, 322);
             this.grpLogin.Name = &quot;grpLogin&quot;;
             this.grpLogin.Size = new System.Drawing.Size(560, 80);
             this.grpLogin.TabIndex = 51;
@@ -135,39 +156,127 @@
             this.txtFirstName.Size = new System.Drawing.Size(120, 20);
             this.txtFirstName.TabIndex = 0;
             // 
-            // cmdCapture
+            // cmdExport
             // 
-            this.cmdCapture.Enabled = false;
-            this.cmdCapture.Location = new System.Drawing.Point(12, 12);
-            this.cmdCapture.Name = &quot;cmdCapture&quot;;
-            this.cmdCapture.Size = new System.Drawing.Size(560, 49);
-            this.cmdCapture.TabIndex = 52;
-            this.cmdCapture.Text = &quot;Start Capture&quot;;
-            this.cmdCapture.Click += new System.EventHandler(this.cmdCapture_Click);
+            this.cmdExport.Location = new System.Drawing.Point(452, 33);
+            this.cmdExport.Name = &quot;cmdExport&quot;;
+            this.cmdExport.Size = new System.Drawing.Size(120, 24);
+            this.cmdExport.TabIndex = 52;
+            this.cmdExport.Text = &quot;Export Prims&quot;;
+            this.cmdExport.Click += new System.EventHandler(this.cmdExport_Click);
             // 
             // txtLog
             // 
-            this.txtLog.Location = new System.Drawing.Point(12, 67);
+            this.txtLog.Location = new System.Drawing.Point(12, 63);
             this.txtLog.Multiline = true;
             this.txtLog.Name = &quot;txtLog&quot;;
             this.txtLog.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
-            this.txtLog.Size = new System.Drawing.Size(560, 131);
+            this.txtLog.Size = new System.Drawing.Size(560, 253);
             this.txtLog.TabIndex = 53;
             // 
+            // label4
+            // 
+            this.label4.AutoSize = true;
+            this.label4.Font = new System.Drawing.Font(&quot;Microsoft Sans Serif&quot;, 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
+            this.label4.Location = new System.Drawing.Point(12, 9);
+            this.label4.Name = &quot;label4&quot;;
+            this.label4.Size = new System.Drawing.Size(40, 13);
+            this.label4.TabIndex = 56;
+            this.label4.Text = &quot;Export:&quot;;
+            // 
+            // label5
+            // 
+            this.label5.AutoSize = true;
+            this.label5.Font = new System.Drawing.Font(&quot;Microsoft Sans Serif&quot;, 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
+            this.label5.Location = new System.Drawing.Point(12, 40);
+            this.label5.Name = &quot;label5&quot;;
+            this.label5.Size = new System.Drawing.Size(42, 13);
+            this.label5.TabIndex = 59;
+            this.label5.Text = &quot;Format:&quot;;
+            // 
+            // panel1
+            // 
+            this.panel1.Controls.Add(this.radObjects);
+            this.panel1.Controls.Add(this.radEntireSim);
+            this.panel1.Location = new System.Drawing.Point(67, 0);
+            this.panel1.Name = &quot;panel1&quot;;
+            this.panel1.Size = new System.Drawing.Size(194, 31);
+            this.panel1.TabIndex = 60;
+            // 
+            // radObjects
+            // 
+            this.radObjects.AutoSize = true;
+            this.radObjects.Enabled = false;
+            this.radObjects.Location = new System.Drawing.Point(81, 8);
+            this.radObjects.Name = &quot;radObjects&quot;;
+            this.radObjects.Size = new System.Drawing.Size(97, 17);
+            this.radObjects.TabIndex = 57;
+            this.radObjects.Text = &quot;Object/Linkjset&quot;;
+            this.radObjects.UseVisualStyleBackColor = true;
+            // 
+            // radEntireSim
+            // 
+            this.radEntireSim.AutoSize = true;
+            this.radEntireSim.Checked = true;
+            this.radEntireSim.Location = new System.Drawing.Point(3, 8);
+            this.radEntireSim.Name = &quot;radEntireSim&quot;;
+            this.radEntireSim.Size = new System.Drawing.Size(72, 17);
+            this.radEntireSim.TabIndex = 56;
+            this.radEntireSim.TabStop = true;
+            this.radEntireSim.Text = &quot;Entire Sim&quot;;
+            this.radEntireSim.UseVisualStyleBackColor = true;
+            // 
+            // panel2
+            // 
+            this.panel2.Controls.Add(this.radPrimBlender);
+            this.panel2.Controls.Add(this.radLibPrims);
+            this.panel2.Location = new System.Drawing.Point(67, 31);
+            this.panel2.Name = &quot;panel2&quot;;
+            this.panel2.Size = new System.Drawing.Size(288, 31);
+            this.panel2.TabIndex = 61;
+            // 
+            // radPrimBlender
+            // 
+            this.radPrimBlender.AutoSize = true;
+            this.radPrimBlender.Location = new System.Drawing.Point(68, 7);
+            this.radPrimBlender.Name = &quot;radPrimBlender&quot;;
+            this.radPrimBlender.Size = new System.Drawing.Size(168, 17);
+            this.radPrimBlender.TabIndex = 60;
+            this.radPrimBlender.Text = &quot;prim.Blender (currently broken)&quot;;
+            this.radPrimBlender.UseVisualStyleBackColor = true;
+            // 
+            // radLibPrims
+            // 
+            this.radLibPrims.AutoSize = true;
+            this.radLibPrims.Checked = true;
+            this.radLibPrims.Location = new System.Drawing.Point(3, 7);
+            this.radLibPrims.Name = &quot;radLibPrims&quot;;
+            this.radLibPrims.Size = new System.Drawing.Size(59, 17);
+            this.radLibPrims.TabIndex = 59;
+            this.radLibPrims.TabStop = true;
+            this.radLibPrims.Text = &quot;libprims&quot;;
+            this.radLibPrims.UseVisualStyleBackColor = true;
+            // 
             // frmPrimExport
             // 
-            this.ClientSize = new System.Drawing.Size(587, 299);
+            this.ClientSize = new System.Drawing.Size(587, 414);
+            this.Controls.Add(this.panel2);
+            this.Controls.Add(this.panel1);
+            this.Controls.Add(this.label5);
+            this.Controls.Add(this.label4);
             this.Controls.Add(this.txtLog);
-            this.Controls.Add(this.cmdCapture);
+            this.Controls.Add(this.cmdExport);
             this.Controls.Add(this.grpLogin);
             this.MaximizeBox = false;
-            this.MaximumSize = new System.Drawing.Size(595, 326);
-            this.MinimumSize = new System.Drawing.Size(595, 326);
             this.Name = &quot;frmPrimExport&quot;;
             this.Text = &quot;Prim Exporter&quot;;
             this.TopMost = true;
             this.grpLogin.ResumeLayout(false);
             this.grpLogin.PerformLayout();
+            this.panel1.ResumeLayout(false);
+            this.panel1.PerformLayout();
+            this.panel2.ResumeLayout(false);
+            this.panel2.PerformLayout();
             this.ResumeLayout(false);
             this.PerformLayout();
 
@@ -175,162 +284,301 @@
 
         #endregion
 
+        /// &lt;summary&gt;
+        /// The main entry point for the application.
+        /// &lt;/summary&gt;
+        [STAThread]
+        static void Main(string[] args)
+        {
+            frmPrimExport exportForm = new frmPrimExport();
+            exportForm.ShowDialog();
+        }
+
         public frmPrimExport()
         {
             InitializeComponent();
 
-            primCallback = new NewPrimCallback(PrimSeen);
+            client = new SecondLife();
+            client.OnLogMessage += new LogCallback(client_OnLogMessage);
+            client.Objects.RequestAllObjects = true;
+            client.Objects.OnNewPrim += new ObjectManager.NewPrimCallback(PrimSeen);
+            client.Objects.OnNewAvatar += new ObjectManager.NewAvatarCallback(AvatarSeen);
+            client.Objects.OnNewAttachment += new ObjectManager.NewAttachmentCallback(AttachmentSeen);
 
-            client = new SecondLife();
             grpLogin.Enabled = true;
         }
 
+        void client_OnLogMessage(string message, Helpers.LogLevel level)
+        {
+            Log(&quot;libsl: &quot; + level.ToString() + &quot;: &quot; + message + Environment.NewLine);
+        }
+
         private void Log(string text)
         {
-            currentText = text;
+            CurrentText = text;
 
-            if (this.InvokeRequired)
+            lock (txtLog)
             {
-                this.Invoke(new MethodInvoker(UpdateLog));
+                if (this.InvokeRequired)
+                {
+                    this.Invoke(new MethodInvoker(UpdateLog));
+                }
+                else
+                {
+                    UpdateLog();
+                }
             }
-            else
-            {
-                UpdateLog();
-            }
         }
 
         private void UpdateLog()
         {
-            txtLog.Text += currentText + Environment.NewLine;
+            txtLog.AppendText(CurrentText);
         }
 
         private void PrimSeen(Simulator simulator, PrimObject prim, ulong regionHandle, ushort timeDilation)
         {
-            uint type = 0;
-            string output = &quot;&quot;;
+            lock (Prims)
+            {
+                if (Prims.ContainsKey(prim.LocalID))
+                {
+                    Prims.Remove(prim.LocalID);
+                }
 
-            output += &quot;&lt;primitive name=\&quot;Object\&quot; description=\&quot;\&quot; key=\&quot;Num_000&quot; + prim.LocalID + &quot;\&quot; version=\&quot;2\&quot;&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;states&gt;&quot; + Environment.NewLine +
-                &quot;&lt;physics params=\&quot;\&quot;&gt;false&lt;/physics&gt;&quot; + Environment.NewLine +
-                &quot;&lt;temporary params=\&quot;\&quot;&gt;false&lt;/temporary&gt;&quot; + Environment.NewLine +
-                &quot;&lt;phantom params=\&quot;\&quot;&gt;false&lt;/phantom&gt;&quot; + Environment.NewLine +
-                &quot;&lt;/states&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;properties&gt;&quot; + Environment.NewLine +
-                &quot;&lt;levelofdetail val=\&quot;9\&quot; /&gt;&quot; + Environment.NewLine;
+                Prims.Add(prim.LocalID, prim);
+                Log(&quot;.&quot;);
+            }
+        }
 
-            if (prim.ProfileCurve == 1 &amp;&amp; prim.PathCurve == 16)
+        void AttachmentSeen(Simulator simulator, PrimObject prim, ulong regionHandle, ushort timeDilation)
+        {
+            lock (Attachments)
             {
-                // PRIM_TYPE_BOX
-                type = 0;
+                Attachments.Add(prim.LocalID);
             }
-            else if (prim.ProfileCurve == 0 &amp;&amp; prim.PathCurve == 16)
+        }
+
+        void AvatarSeen(Simulator simulator, Avatar avatar, ulong regionHandle, ushort timeDilation)
+        {
+            lock (Avatars)
             {
-                // PRIM_TYPE_CYLINDER
-                type = 1;
+                Avatars.Add(avatar.LocalID);
             }
-            else if (prim.ProfileCurve == 3 &amp;&amp; prim.PathCurve == 16)
+        }
+
+        private void ExportPrims()
+        {
+            FileStream file = null;
+            StreamWriter stream = null;
+
+            try
             {
-                // PRIM_TYPE_PRISM
-                type = 2;
+                file = new FileStream(Filename, FileMode.Create);
+                stream = new StreamWriter(file);
+
+                if (radLibPrims.Checked)
+                {
+                    ExportLibPrims(stream);
+                }
+                else
+                {
+                    ExportPrimBlender(stream);
+                }
             }
-            else if (prim.ProfileCurve == 5 &amp;&amp; prim.PathCurve == 32)
+            catch (Exception e)
             {
-                // PRIM_TYPE_SPHERE
-                type = 3;
+                MessageBox.Show(&quot;There was an error writing the prims file, check the log for details&quot;,
+                    &quot;primexport Error&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);
+                Log(&quot;Error writing prims to &quot; + Filename + &quot;: &quot; + e.ToString() + Environment.NewLine);
             }
-            else if (prim.ProfileCurve == 0 &amp;&amp; prim.PathCurve == 32)
+            finally
             {
-                // PRIM_TYPE_TORUS
-                type = 4;
+                if (stream != null) stream.Close();
+                if (file != null) file.Close();
+                cmdExport.Enabled = true;
             }
-            else if (prim.ProfileCurve == 1 &amp;&amp; prim.PathCurve == 32)
+        }
+
+        private void ExportPrimBlender(StreamWriter stream)
+        {
+            uint type = 0;
+            string output;
+
+            lock (Prims)
             {
-                // PRIM_TYPE_TUBE
-                type = 5;
+                stream.WriteLine(&quot;&lt;primitives&gt;&quot;);
+
+                foreach (PrimObject prim in Prims.Values)
+                {
+                    LLVector3 position = prim.Position;
+                    LLQuaternion rotation = prim.Rotation;
+
+                    output = &quot;&quot;;
+
+                    if (prim.ParentID != 0)
+                    {
+                        // This prim is part of a linkset, we need to adjust it's position and rotation
+                        if (Prims.ContainsKey(prim.ParentID))
+                        {
+                            // The child prim only stores a relative position, add the world position of the parent prim
+                            position += Prims[prim.ParentID].Position;
+
+                            // The child prim only stores a relative rotation, start with the parent prim rotation
+                            rotation = rotation * Prims[prim.ParentID].Rotation;
+                        }
+                        else if (Avatars.Contains(prim.ParentID) || Attachments.Contains(prim.ParentID))
+                        {
+                            // Skip this
+                        }
+                        else
+                        {
+                            // We don't have the base position for this child prim, can't render it
+                            Log(&quot;Couldn't export child prim &quot; + prim.ID.ToString() + &quot;, parent prim is missing&quot; +
+                                Environment.NewLine);
+                            continue;
+                        }
+                    }
+
+                    output += &quot;&lt;primitive name=\&quot;Object\&quot; description=\&quot;\&quot; key=\&quot;Num_000&quot; + prim.LocalID + &quot;\&quot; version=\&quot;2\&quot;&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;states&gt;&lt;physics params=\&quot;\&quot;&gt;false&lt;/physics&gt;&lt;temporary params=\&quot;\&quot;&gt;false&lt;/temporary&gt;&lt;phantom params=\&quot;\&quot;&gt;false&lt;/phantom&gt;&lt;/states&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;properties&gt;&quot; + Environment.NewLine +
+                        &quot;&lt;levelofdetail val=\&quot;9\&quot; /&gt;&quot; + Environment.NewLine;
+
+                    switch (prim.ProfileCurve + prim.PathCurve)
+                    {
+                        case 17:
+                            // PRIM_TYPE_BOX
+                            type = 0;
+                            break;
+                        case 16:
+                            // PRIM_TYPE_CYLINDER
+                            type = 1;
+                            break;
+                        case 19:
+                            // PRIM_TYPE_PRISM
+                            type = 2;
+                            break;
+                        case 37:
+                            // PRIM_TYPE_SPHERE
+                            type = 3;
+                            break;
+                        case 32:
+                            // PRIM_TYPE_TORUS
+                            type = 4;
+                            break;
+                        case 33:
+                            // PRIM_TYPE_TUBE
+                            type = 5;
+                            break;
+                        case 35:
+                            // PRIM_TYPE_RING
+                            type = 6;
+                            break;
+                        default:
+                            Log(&quot;Not exporting an unhandled prim, ProfileCurve=&quot; +
+                                prim.ProfileCurve + &quot;, PathCurve=&quot; + prim.PathCurve + Environment.NewLine);
+                            continue;
+                    }
+
+                    output += &quot;&lt;type val=\&quot;&quot; + type + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;position x=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, position.X) +
+                        &quot;\&quot; y=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, position.Y) +
+                        &quot;\&quot; z=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, position.Z) + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;rotation x=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, rotation.X) +
+                        &quot;\&quot; y=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, rotation.Y) +
+                        &quot;\&quot; z=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, rotation.Z) +
+                        &quot;\&quot; s=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, rotation.W) + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;size x=\&quot;&quot; + string.Format(&quot;{0:F3}&quot;, prim.Scale.X) +
+                        &quot;\&quot; y=\&quot;&quot; + string.Format(&quot;{0:F3}&quot;, prim.Scale.Y) +
+                        &quot;\&quot; z=\&quot;&quot; + string.Format(&quot;{0:F3}&quot;, prim.Scale.Z) + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+
+                    if (type == 1)
+                    {
+                        output += &quot;&lt;cut x=\&quot;&quot; + prim.ProfileBegin + &quot;\&quot; y=\&quot;&quot; + prim.ProfileEnd + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                        output += &quot;&lt;dimple x=\&quot;&quot; + prim.PathBegin + &quot;\&quot; y=\&quot;&quot; + prim.PathEnd + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    }
+                    else
+                    {
+                        output += &quot;&lt;cut x=\&quot;&quot; + prim.PathBegin + &quot;\&quot; y=\&quot;&quot; + prim.PathEnd + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                        output += &quot;&lt;dimple x=\&quot;&quot; + prim.ProfileBegin + &quot;\&quot; y=\&quot;&quot; + prim.ProfileEnd + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    }
+
+                    output += &quot;&lt;advancedcut x=\&quot;&quot; + prim.ProfileBegin + &quot;\&quot; y=\&quot;&quot; + prim.ProfileEnd + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;hollow val=\&quot;&quot; + prim.ProfileHollow + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;twist x=\&quot;&quot; + prim.PathTwistBegin + &quot;\&quot; y=\&quot;&quot; + prim.PathTwist + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;topsize x=\&quot;&quot; + Math.Abs(prim.PathScaleX - 1.0f) + &quot;\&quot; y=\&quot;&quot; +
+                        Math.Abs(prim.PathScaleY - 1.0f) + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;holesize x=\&quot;&quot; + (1.0f - prim.PathScaleX) + &quot;\&quot; y=\&quot;&quot; + (1.0f - prim.PathScaleY) + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;topshear x=\&quot;&quot; + prim.PathShearX + &quot;\&quot; y=\&quot;&quot; + prim.PathShearY + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;taper x=\&quot;&quot; + prim.PathTaperX + &quot;\&quot; y=\&quot;&quot; + prim.PathTaperY + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;revolutions val=\&quot;&quot; + prim.PathRevolutions + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;radiusoffset val=\&quot;&quot; + prim.PathRadiusOffset + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;skew val=\&quot;&quot; + prim.PathSkew + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    output += &quot;&lt;material val=\&quot;&quot; + prim.Material + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
+                    // FIXME: Hollowshape. 16-21 = circle, 32-37 = square, 48-53 = triangle
+                    output += &quot;&lt;hollowshape val=\&quot;0\&quot; /&gt;&quot; + Environment.NewLine;
+
+                    output += &quot;&lt;textures params=\&quot;\&quot;&gt;&quot; +
+                        &quot;&lt;/textures&gt;&quot; +
+                        &quot;&lt;scripts params=\&quot;\&quot;&gt;&quot; +
+                        &quot;&lt;/scripts&gt;&quot; + Environment.NewLine +
+                        &quot;&lt;/properties&gt;&quot; + Environment.NewLine +
+                        &quot;&lt;/primitive&gt;&quot; + Environment.NewLine;
+
+                    stream.WriteLine(output);
+                }
             }
-            else if (prim.ProfileCurve == 3 &amp;&amp; prim.PathCurve == 32)
-            {
-                // PRIM_TYPE_RING
-                type = 6;
-            }
-            else
-            {
-                Console.WriteLine(&quot;Unhandled prim type, ProfileCurve=&quot; +
-                    prim.ProfileCurve + &quot;, PathCurve=&quot; + prim.PathCurve);
-                type = 0;
-            }
 
-            output += &quot;&lt;type val=\&quot;&quot; + type + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;position x=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, prim.Position.X) +
-                &quot;\&quot; y=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, prim.Position.Y) +
-                &quot;\&quot; z=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, prim.Position.Z) + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;rotation x=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, prim.Rotation.X) +
-                &quot;\&quot; y=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, prim.Rotation.Y) +
-                &quot;\&quot; z=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, prim.Rotation.Z) +
-                &quot;\&quot; s=\&quot;&quot; + string.Format(&quot;{0:F6}&quot;, prim.Rotation.W) + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;size x=\&quot;&quot; + string.Format(&quot;{0:F3}&quot;, prim.Scale.X) +
-                &quot;\&quot; y=\&quot;&quot; + string.Format(&quot;{0:F3}&quot;, prim.Scale.Y) +
-                &quot;\&quot; z=\&quot;&quot; + string.Format(&quot;{0:F3}&quot;, prim.Scale.Z) + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            
-            if (type == 1)
+            stream.WriteLine(&quot;&lt;/primitives&gt;&quot;);
+        }
+
+        private void ExportLibPrims(StreamWriter stream)
+        {
+            lock (Prims)
             {
-                output += &quot;&lt;cut x=\&quot;&quot; + prim.ProfileBegin + &quot;\&quot; y=\&quot;&quot; + prim.ProfileEnd + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-                output += &quot;&lt;dimple x=\&quot;&quot; + prim.PathBegin + &quot;\&quot; y=\&quot;&quot; + prim.PathEnd + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            }
-            else
-            {
-                output += &quot;&lt;cut x=\&quot;&quot; + prim.PathBegin + &quot;\&quot; y=\&quot;&quot; + prim.PathEnd + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-                output += &quot;&lt;dimple x=\&quot;&quot; + prim.ProfileBegin + &quot;\&quot; y=\&quot;&quot; + prim.ProfileEnd + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            }
-            
-            output += &quot;&lt;advancedcut x=\&quot;&quot; + prim.ProfileBegin + &quot;\&quot; y=\&quot;&quot; + prim.ProfileEnd + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;hollow val=\&quot;&quot; + prim.ProfileHollow + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;twist x=\&quot;&quot; + prim.PathTwistBegin + &quot;\&quot; y=\&quot;&quot; + prim.PathTwist + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;topsize x=\&quot;&quot; + Math.Abs(prim.PathScaleX - 1.0F) + &quot;\&quot; y=\&quot;&quot; +
-                Math.Abs(prim.PathScaleY - 1.0F) + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;holesize x=\&quot;&quot; + (1.0F - prim.PathScaleX) + &quot;\&quot; y=\&quot;&quot; + (1.0F - prim.PathScaleY) + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;topshear x=\&quot;&quot; + prim.PathShearX + &quot;\&quot; y=\&quot;&quot; + prim.PathShearY + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            // prim.blender stores taper values a bit different than the SL network layer
-            output += &quot;&lt;taper x=\&quot;&quot; + /*Math.Abs(prim.PathScaleX - 1.0F)*/ prim.PathTaperX + &quot;\&quot; y=\&quot;&quot; +
-                /*Math.Abs(prim.PathScaleY - 1.0F)*/ prim.PathTaperY + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;revolutions val=\&quot;&quot; + prim.PathRevolutions + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;radiusoffset val=\&quot;&quot; + prim.PathRadiusOffset + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;skew val=\&quot;&quot; + prim.PathSkew + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            output += &quot;&lt;material val=\&quot;&quot; + prim.Material + &quot;\&quot; /&gt;&quot; + Environment.NewLine;
-            // TODO: Hollowshape. 16-21 = circle, 32-37 = square, 48-53 = triangle
-            output += &quot;&lt;hollowshape val=\&quot;0\&quot; /&gt;&quot; + Environment.NewLine;
+                stream.WriteLine(&quot;&lt;Primitives&gt;&quot;);
 
-            output += &quot;&lt;textures params=\&quot;\&quot;&gt;&quot; + Environment.NewLine +
-                &quot;&lt;/textures&gt;&quot; + Environment.NewLine +
-                &quot;&lt;scripts params=\&quot;\&quot;&gt;&quot; + Environment.NewLine +
-                &quot;&lt;/scripts&gt;&quot; + Environment.NewLine +
-                &quot;&lt;/properties&gt;&quot; + Environment.NewLine +
-                &quot;&lt;/primitive&gt;&quot; + Environment.NewLine;
+                foreach (PrimObject prim in Prims.Values)
+                {
+                    if (prim.ParentID != 0)
+                    {
+                        // This prim is part of a linkset, we need to adjust it's position and rotation
+                        if (Prims.ContainsKey(prim.ParentID))
+                        {
+                            stream.WriteLine(prim.GetXml());
+                        }
+                        else if (Avatars.Contains(prim.ParentID) || Attachments.Contains(prim.ParentID))
+                        {
+                            // Skip this
+                        }
+                        else
+                        {
+                            // We don't have the base position for this child prim, can't render it
+                            Log(&quot;Couldn't export child prim &quot; + prim.ID.ToString() + &quot;, parent prim is missing&quot; +
+                                Environment.NewLine);
+                        }
+                    }
+                }
 
-            Log(output);
+                stream.WriteLine(&quot;&lt;/Primitives&gt;&quot;);
+            }
         }
 
         private void cmdConnect_Click(object sender, EventArgs e)
         {
-            cmdCapture.Text = &quot;Start Capture&quot;;
-            cmdCapture.Enabled = false;
-
             if (cmdConnect.Text == &quot;Connect&quot;)
             {
                 cmdConnect.Text = &quot;Disconnect&quot;;
                 txtFirstName.Enabled = txtLastName.Enabled = txtPassword.Enabled = false;
 
-                Dictionary&lt;string, object&gt; loginParams = NetworkManager.DefaultLoginValues(txtFirstName.Text,
-                    txtLastName.Text, txtPassword.Text, &quot;00:00:00:00:00:00&quot;, &quot;last&quot;, 
-                    &quot;Win&quot;, &quot;0&quot;, &quot;primexport&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">jhurliman at wsu.edu</A>&quot;);
-
-                // HAX
-                cmdCapture.Text = &quot;Stop Capture&quot;;
-                client.Objects.OnNewPrim += primCallback;
-
-                if (client.Network.Login(loginParams))
+                if (client.Network.Login(txtFirstName.Text, txtLastName.Text, txtPassword.Text,
+                    &quot;primexport&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">jhurliman at wsu.edu</A>&quot;))
                 {
-                    cmdCapture.Enabled = true;
+                    client.Throttle.Asset = 0;
+                    client.Throttle.Cloud = 0;
+                    client.Throttle.Land = 0;
+                    client.Throttle.Texture = 0;
+                    client.Throttle.Wind = 0;
+                    client.Throttle.Set();
                 }
                 else
                 {
@@ -342,23 +590,35 @@
             else
             {
                 client.Network.Logout();
+
                 cmdConnect.Text = &quot;Connect&quot;;
                 txtFirstName.Enabled = txtLastName.Enabled = txtPassword.Enabled = true;
             }
         }
 
-        private void cmdCapture_Click(object sender, EventArgs e)
+        private void cmdExport_Click(object sender, EventArgs e)
         {
-            if (cmdCapture.Text == &quot;Start Capture&quot;)
+            SaveFileDialog save = new SaveFileDialog();
+
+            if (radLibPrims.Checked)
             {
-                cmdCapture.Text = &quot;Stop Capture&quot;;
-                client.Objects.OnNewPrim += primCallback;
+                save.Filter = &quot;libprims files (*.xml)|*.xml&quot;;
             }
             else
             {
-                cmdCapture.Text = &quot;Start Capture&quot;;
-                client.Objects.OnNewPrim -= primCallback;
+                save.Filter = &quot;Prim.Blender files (*.prims)|*.prims&quot;;
             }
+
+            save.RestoreDirectory = true;
+
+            if (save.ShowDialog() == DialogResult.OK)
+            {
+                EntireSim = radEntireSim.Checked;
+                
+                Filename = save.FileName;
+                cmdExport.Enabled = false;
+                Invoke(new MethodInvoker(ExportPrims));
+            }
         }
     }
 }

Deleted: branches/aditi/libsecondlife-cs/examples/primexport/primexport.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/primexport/primexport.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/primexport/primexport.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,45 +0,0 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using libsecondlife;
-
-namespace primexport
-{
-	class primexport
-	{
-		/// &lt;summary&gt;
-		/// The main entry point for the application.
-		/// &lt;/summary&gt;
-		[STAThread]
-		static void Main(string[] args)
-		{
-            frmPrimExport exportForm = new frmPrimExport();
-            exportForm.ShowDialog();
-		}
-	}
-}

Modified: branches/aditi/libsecondlife-cs/examples/primexport/primexport.csproj
===================================================================
--- branches/aditi/libsecondlife-cs/examples/primexport/primexport.csproj	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/primexport/primexport.csproj	2006-11-29 00:53:56 UTC (rev 650)
@@ -96,9 +96,6 @@
     &lt;Compile Include=&quot;frmPrimExport.cs&quot;&gt;
       &lt;SubType&gt;Form&lt;/SubType&gt;
     &lt;/Compile&gt;
-    &lt;Compile Include=&quot;primexport.cs&quot;&gt;
-      &lt;SubType&gt;Code&lt;/SubType&gt;
-    &lt;/Compile&gt;
   &lt;/ItemGroup&gt;
   &lt;ItemGroup&gt;
     &lt;EmbeddedResource Include=&quot;frmPrimExport.resx&quot;&gt;

Modified: branches/aditi/libsecondlife-cs/examples/slaccountant/frmSLAccountant.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/slaccountant/frmSLAccountant.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/slaccountant/frmSLAccountant.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -381,9 +381,8 @@
 			client = new SecondLife();
 
 			// Install our packet handlers
-			//client.Network.RegisterCallback(PacketType.AvatarAppearance, new PacketCallback(AvatarAppearanceHandler));
-			client.Network.RegisterCallback(PacketType.MoneyBalanceReply, new PacketCallback(BalanceHandler));
-            client.Network.RegisterCallback(PacketType.DirPeopleReply, new PacketCallback(DirPeopleHandler));
+            client.Network.RegisterCallback(PacketType.MoneyBalanceReply, new NetworkManager.PacketCallback(BalanceHandler));
+            client.Network.RegisterCallback(PacketType.DirPeopleReply, new NetworkManager.PacketCallback(DirPeopleHandler));
 
 			grpLogin.Enabled = true;
 		}
@@ -395,11 +394,8 @@
 				cmdConnect.Text = &quot;Disconnect&quot;;
 				txtFirstName.Enabled = txtLastName.Enabled = txtPassword.Enabled = false;
 
-                Dictionary&lt;string, object&gt; loginParams = NetworkManager.DefaultLoginValues(txtFirstName.Text, 
-					txtLastName.Text, txtPassword.Text, &quot;00:00:00:00:00:00&quot;, &quot;last&quot;, 
-					&quot;Win&quot;, &quot;0&quot;, &quot;accountant&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">jhurliman at wsu.edu</A>&quot;);
-
-				if (client.Network.Login(loginParams))
+				if (client.Network.Login(txtFirstName.Text, txtLastName.Text, txtPassword.Text, 
+                    &quot;accountant&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">jhurliman at wsu.edu</A>&quot;))
 				{
 					Random rand = new Random();
 					

Modified: branches/aditi/libsecondlife-cs/examples/sldump/sldump.cs
===================================================================
--- branches/aditi/libsecondlife-cs/examples/sldump/sldump.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/examples/sldump/sldump.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -26,6 +26,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Threading;
 using libsecondlife;
 using libsecondlife.Packets;
 
@@ -39,13 +40,13 @@
 			Console.WriteLine(packet.ToString());
 		}
 
-        public static void DisconnectHandler(DisconnectType type, string message)
+        public static void DisconnectHandler(NetworkManager.DisconnectType type, string message)
         {
-            if (type == DisconnectType.NetworkTimeout)
+            if (type == NetworkManager.DisconnectType.NetworkTimeout)
             {
                 Console.WriteLine(&quot;Network connection timed out, disconnected&quot;);
             }
-            else if (type == DisconnectType.ServerInitiated)
+            else if (type == NetworkManager.DisconnectType.ServerInitiated)
             {
                 Console.WriteLine(&quot;Server disconnected us: &quot; + message);
             }
@@ -59,10 +60,10 @@
 		{
 			SecondLife client;
 
-			if (args.Length == 0 || (args.Length &lt; 3 &amp;&amp; args[0] != &quot;--printmap&quot;))
+			if (args.Length == 0 || (args.Length &lt; 4 &amp;&amp; args[0] != &quot;--printmap&quot;))
 			{
-				Console.WriteLine(&quot;Usage: sldump [--printmap] [--decrypt] [inputfile] [outputfile] [--protocol] [firstname] &quot; +
-					&quot;[lastname] [password]&quot;);
+				Console.WriteLine(&quot;Usage: sldump [--printmap] [--decrypt] [inputfile] [outputfile] &quot;
+                    + &quot;[--protocol] [firstname] [lastname] [password] [seconds (0 for infinite)]&quot;);
 				return;
 			}
 
@@ -102,17 +103,10 @@
 			}
 
 			// Setup the packet callback and disconnect event handler
-			client.Network.RegisterCallback(PacketType.Default, new PacketCallback(DefaultHandler));
-            client.Network.OnDisconnected += new DisconnectCallback(DisconnectHandler);
+            client.Network.RegisterCallback(PacketType.Default, new NetworkManager.PacketCallback(DefaultHandler));
+            client.Network.OnDisconnected += new NetworkManager.DisconnectCallback(DisconnectHandler);
 
-            Dictionary&lt;string, object&gt; loginParams = NetworkManager.DefaultLoginValues(args[0], args[1], args[2], 
-                &quot;0&quot;, &quot;last&quot;, &quot;Win&quot;, &quot;0&quot;, &quot;sldump&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">contact at libsecondlife.org</A>&quot;);
-
-			// An example of how to pass additional options to the login server
-            //loginParams[&quot;id0&quot;] = &quot;65e142a8d3c1ee6632259f111cb168c9&quot;;
-            //loginParams[&quot;viewer_digest&quot;] = &quot;0e63550f-0991-a092-3158-b4206e728ffa&quot;;
-
-			if (!client.Network.Login(loginParams/*, &quot;<A HREF="http://127.0.0.1:8080/">http://127.0.0.1:8080/</A>&quot;*/))
+			if (!client.Network.Login(args[0], args[1], args[2], &quot;sldump&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">contact at libsecondlife.org</A>&quot;))
 			{
 				// Login failed
 				Console.WriteLine(&quot;Error logging in: &quot; + client.Network.LoginError);
@@ -122,10 +116,28 @@
 			// Login was successful
 			Console.WriteLine(&quot;Message of the day: &quot; + client.Network.LoginValues[&quot;message&quot;]);
 
+            // Throttle packets that we don't want all the way down
+			client.Throttle.Land = 0;
+            client.Throttle.Wind = 0;
+            client.Throttle.Cloud = 0;
+            client.Throttle.Texture = 0;
+            client.Throttle.Set();
+
+            int start = Environment.TickCount;
+            int milliseconds = Int32.Parse(args[3]) * 1000;
+            bool forever = (milliseconds &gt; 0) ? false : true;
+
 			while (true)
 			{
-				client.Tick();
+                System.Threading.Thread.Sleep(100);
+
+                if (!forever &amp;&amp; Environment.TickCount - start &gt; milliseconds)
+                {
+                    break;
+                }
 			}
+
+            client.Network.Logout();
 		}
 	}
 }

Modified: branches/aditi/libsecondlife-cs/libsecondlife.csproj
===================================================================
--- branches/aditi/libsecondlife-cs/libsecondlife.csproj	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/libsecondlife.csproj	2006-11-29 00:53:56 UTC (rev 650)
@@ -51,7 +51,7 @@
     &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
   &lt;/PropertyGroup&gt;
   &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Release|AnyCPU' &quot;&gt;
-    &lt;OutputPath&gt;bin\Release\&lt;/OutputPath&gt;
+    &lt;OutputPath&gt;..\bin\&lt;/OutputPath&gt;
     &lt;AllowUnsafeBlocks&gt;false&lt;/AllowUnsafeBlocks&gt;
     &lt;BaseAddress&gt;285212672&lt;/BaseAddress&gt;
     &lt;CheckForOverflowUnderflow&gt;false&lt;/CheckForOverflowUnderflow&gt;
@@ -96,6 +96,10 @@
     &lt;Compile Include=&quot;AssetSystem\AssetManager.cs&quot; /&gt;
     &lt;Compile Include=&quot;AssetSystem\AssetNotecard.cs&quot; /&gt;
     &lt;Compile Include=&quot;AssetSystem\AssetPacketHelpers.cs&quot; /&gt;
+    &lt;Compile Include=&quot;AssetSystem\AssetRequestDownload.cs&quot; /&gt;
+    &lt;Compile Include=&quot;AssetSystem\AssetRequestUpload.cs&quot; /&gt;
+    &lt;Compile Include=&quot;AssetSystem\BodyPart.cs&quot; /&gt;
+    &lt;Compile Include=&quot;AssetSystem\BodyShape\_BodyShapeParams_.cs&quot; /&gt;
     &lt;Compile Include=&quot;AssetSystem\ImageManager.cs&quot; /&gt;
     &lt;Compile Include=&quot;AssetSystem\ImagePacketHelpers.cs&quot; /&gt;
     &lt;Compile Include=&quot;Avatar.cs&quot;&gt;
@@ -105,11 +109,11 @@
     &lt;Compile Include=&quot;EstateTools.cs&quot;&gt;
       &lt;SubType&gt;Code&lt;/SubType&gt;
     &lt;/Compile&gt;
-    &lt;Compile Include=&quot;AssetSystem\FastImageTool.cs&quot; /&gt;
     &lt;Compile Include=&quot;GridManager.cs&quot;&gt;
       &lt;SubType&gt;Code&lt;/SubType&gt;
     &lt;/Compile&gt;
     &lt;Compile Include=&quot;GroupManager.cs&quot; /&gt;
+    &lt;Compile Include=&quot;Helpers.cs&quot; /&gt;
     &lt;Compile Include=&quot;InventorySystem\InventoryBase.cs&quot; /&gt;
     &lt;Compile Include=&quot;InventorySystem\InventoryFolder.cs&quot; /&gt;
     &lt;Compile Include=&quot;InventorySystem\InventoryImage.cs&quot; /&gt;
@@ -138,6 +142,9 @@
     &lt;Compile Include=&quot;Parcel.cs&quot;&gt;
       &lt;SubType&gt;Code&lt;/SubType&gt;
     &lt;/Compile&gt;
+    &lt;Compile Include=&quot;ParticleSystem.cs&quot;&gt;
+      &lt;SubType&gt;Code&lt;/SubType&gt;
+    &lt;/Compile&gt;
     &lt;Compile Include=&quot;Prims.cs&quot;&gt;
       &lt;SubType&gt;Code&lt;/SubType&gt;
     &lt;/Compile&gt;

Modified: branches/aditi/libsecondlife-cs/libsecondlife.sln
===================================================================
--- branches/aditi/libsecondlife-cs/libsecondlife.sln	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/libsecondlife.sln	2006-11-29 00:53:56 UTC (rev 650)
@@ -18,8 +18,6 @@
 EndProject
 Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;IA_SimpleInventory&quot;, &quot;examples\IA_SimpleInventory\IA_SimpleInventory.csproj&quot;, &quot;{E464B963-46E3-4E1A-A36F-9C640C880E68}&quot;
 EndProject
-Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;botmanager&quot;, &quot;examples\botmanager\botmanager.csproj&quot;, &quot;{3E891B97-7267-47D4-AAF1-7DCD2F6D60AB}&quot;
-EndProject
 Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;IA_NotecardTool&quot;, &quot;examples\IA_NotecardTool\IA_NotecardTool.csproj&quot;, &quot;{E185E4E1-62D2-430C-A94C-E8E38190805B}&quot;
 EndProject
 Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Teleport&quot;, &quot;examples\Teleport\Teleport.csproj&quot;, &quot;{B5AC6795-E426-4BC3-950F-D7B2970E2394}&quot;
@@ -36,8 +34,28 @@
 EndProject
 Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;libjaspernet&quot;, &quot;..\libjaspernet\libjaspernet.csproj&quot;, &quot;{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}&quot;
 EndProject
-Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;FastImageApp&quot;, &quot;examples\FastImageApp\FastImageApp.csproj&quot;, &quot;{74E4D0EA-93C2-40BC-A075-9EAD3A8FFCF1}&quot;
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;IA_TestAsyncImage&quot;, &quot;examples\IA_TestAsyncImage\IA_TestAsyncImage.csproj&quot;, &quot;{A4F59DE9-E382-401D-AA8D-4557779D764E}&quot;
 EndProject
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;SLIRC&quot;, &quot;..\applications\SLIRC\SLIRC.csproj&quot;, &quot;{8855EB2F-BC4C-485A-A577-0989EB16BFDC}&quot;
+EndProject
+Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;InventoryImageAssets&quot;, &quot;InventoryImageAssets&quot;, &quot;{AE3B6C21-9B43-490E-ABCE-2018DC1AEA44}&quot;
+EndProject
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;IA_MultiImageUpload&quot;, &quot;examples\IA_MultiImageUpload\IA_MultiImageUpload.csproj&quot;, &quot;{8598E42A-DCBC-4224-9503-5694F17B2F45}&quot;
+EndProject
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;SLProxy&quot;, &quot;..\SLProxy\SLProxy.csproj&quot;, &quot;{E4115DC9-FC88-47D6-B3B6-2400AD19B80D}&quot;
+EndProject
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Analyst&quot;, &quot;..\SLProxy\Analyst.csproj&quot;, &quot;{6222B134-AE5F-489A-8A77-423A721B7C62}&quot;
+EndProject
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;ChatConsole&quot;, &quot;..\SLProxy\ChatConsole.csproj&quot;, &quot;{D8ECCBE1-AC71-4054-AAA6-2D50E5629504}&quot;
+EndProject
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;BodyPartMorphGenerator&quot;, &quot;examples\BodyPartMorphGenerator\BodyPartMorphGenerator.csproj&quot;, &quot;{98C44481-3F15-4305-840D-037EA0D9C221}&quot;
+EndProject
+Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Tools and Examples&quot;, &quot;Tools and Examples&quot;, &quot;{F35EF72F-4302-4924-A162-10447B94F635}&quot;
+EndProject
+Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;SL Proxy&quot;, &quot;SL Proxy&quot;, &quot;{C754652B-2ACB-4D47-8914-834E17919132}&quot;
+EndProject
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;TestClient&quot;, &quot;examples\TestClient\TestClient.csproj&quot;, &quot;{B87682F6-B2D7-4C4D-A529-400C24FD4880}&quot;
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -80,10 +98,6 @@
 		{E464B963-46E3-4E1A-A36F-9C640C880E68}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{E464B963-46E3-4E1A-A36F-9C640C880E68}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{E464B963-46E3-4E1A-A36F-9C640C880E68}.Release|Any CPU.Build.0 = Release|Any CPU
-		{3E891B97-7267-47D4-AAF1-7DCD2F6D60AB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{3E891B97-7267-47D4-AAF1-7DCD2F6D60AB}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{3E891B97-7267-47D4-AAF1-7DCD2F6D60AB}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{3E891B97-7267-47D4-AAF1-7DCD2F6D60AB}.Release|Any CPU.Build.0 = Release|Any CPU
 		{E185E4E1-62D2-430C-A94C-E8E38190805B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{E185E4E1-62D2-430C-A94C-E8E38190805B}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{E185E4E1-62D2-430C-A94C-E8E38190805B}.Release|Any CPU.ActiveCfg = Release|Any CPU
@@ -116,12 +130,63 @@
 		{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}.Release|Any CPU.Build.0 = Release|Any CPU
-		{74E4D0EA-93C2-40BC-A075-9EAD3A8FFCF1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{74E4D0EA-93C2-40BC-A075-9EAD3A8FFCF1}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{74E4D0EA-93C2-40BC-A075-9EAD3A8FFCF1}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{74E4D0EA-93C2-40BC-A075-9EAD3A8FFCF1}.Release|Any CPU.Build.0 = Release|Any CPU
+		{A4F59DE9-E382-401D-AA8D-4557779D764E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{A4F59DE9-E382-401D-AA8D-4557779D764E}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{A4F59DE9-E382-401D-AA8D-4557779D764E}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{A4F59DE9-E382-401D-AA8D-4557779D764E}.Release|Any CPU.Build.0 = Release|Any CPU
+		{8855EB2F-BC4C-485A-A577-0989EB16BFDC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{8855EB2F-BC4C-485A-A577-0989EB16BFDC}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{8855EB2F-BC4C-485A-A577-0989EB16BFDC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{8855EB2F-BC4C-485A-A577-0989EB16BFDC}.Release|Any CPU.Build.0 = Release|Any CPU
+		{8598E42A-DCBC-4224-9503-5694F17B2F45}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{8598E42A-DCBC-4224-9503-5694F17B2F45}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{8598E42A-DCBC-4224-9503-5694F17B2F45}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{8598E42A-DCBC-4224-9503-5694F17B2F45}.Release|Any CPU.Build.0 = Release|Any CPU
+		{E4115DC9-FC88-47D6-B3B6-2400AD19B80D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{E4115DC9-FC88-47D6-B3B6-2400AD19B80D}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{E4115DC9-FC88-47D6-B3B6-2400AD19B80D}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{E4115DC9-FC88-47D6-B3B6-2400AD19B80D}.Release|Any CPU.Build.0 = Release|Any CPU
+		{6222B134-AE5F-489A-8A77-423A721B7C62}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{6222B134-AE5F-489A-8A77-423A721B7C62}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{6222B134-AE5F-489A-8A77-423A721B7C62}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{6222B134-AE5F-489A-8A77-423A721B7C62}.Release|Any CPU.Build.0 = Release|Any CPU
+		{D8ECCBE1-AC71-4054-AAA6-2D50E5629504}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{D8ECCBE1-AC71-4054-AAA6-2D50E5629504}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{D8ECCBE1-AC71-4054-AAA6-2D50E5629504}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{D8ECCBE1-AC71-4054-AAA6-2D50E5629504}.Release|Any CPU.Build.0 = Release|Any CPU
+		{98C44481-3F15-4305-840D-037EA0D9C221}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{98C44481-3F15-4305-840D-037EA0D9C221}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{98C44481-3F15-4305-840D-037EA0D9C221}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{98C44481-3F15-4305-840D-037EA0D9C221}.Release|Any CPU.Build.0 = Release|Any CPU
+		{B87682F6-B2D7-4C4D-A529-400C24FD4880}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{B87682F6-B2D7-4C4D-A529-400C24FD4880}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{B87682F6-B2D7-4C4D-A529-400C24FD4880}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{B87682F6-B2D7-4C4D-A529-400C24FD4880}.Release|Any CPU.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
 	EndGlobalSection
+	GlobalSection(NestedProjects) = preSolution
+		{FC19D5F6-076E-4923-8456-9B0E00E22896} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{66FFD34E-652C-4EF5-81FE-06AD011169D2} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{623B86F7-7753-44B7-A8C8-CBC89FB8AF8E} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{77E5330D-8A8C-41B4-A2D1-6F06FE45ED6D} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{B5AC6795-E426-4BC3-950F-D7B2970E2394} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{7AE16AC1-E64C-4FDC-9B85-4BB6145D511C} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{F460FAB3-0D12-4873-89EB-2696818764B8} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{4EF98AD4-B3B3-42B0-9273-13A614A823F7} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{8855EB2F-BC4C-485A-A577-0989EB16BFDC} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{F6258A68-C624-46A0-BA73-B55D21BB0A3B} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{B87682F6-B2D7-4C4D-A529-400C24FD4880} = {F35EF72F-4302-4924-A162-10447B94F635}
+		{E185E4E1-62D2-430C-A94C-E8E38190805B} = {AE3B6C21-9B43-490E-ABCE-2018DC1AEA44}
+		{8D2E5240-2247-42F5-AAAC-CF0CCCEE349A} = {AE3B6C21-9B43-490E-ABCE-2018DC1AEA44}
+		{D6D1D020-D8D8-4D7E-B7AC-5913A903D6E7} = {AE3B6C21-9B43-490E-ABCE-2018DC1AEA44}
+		{A4F59DE9-E382-401D-AA8D-4557779D764E} = {AE3B6C21-9B43-490E-ABCE-2018DC1AEA44}
+		{E464B963-46E3-4E1A-A36F-9C640C880E68} = {AE3B6C21-9B43-490E-ABCE-2018DC1AEA44}
+		{8598E42A-DCBC-4224-9503-5694F17B2F45} = {AE3B6C21-9B43-490E-ABCE-2018DC1AEA44}
+		{98C44481-3F15-4305-840D-037EA0D9C221} = {AE3B6C21-9B43-490E-ABCE-2018DC1AEA44}
+		{6222B134-AE5F-489A-8A77-423A721B7C62} = {C754652B-2ACB-4D47-8914-834E17919132}
+		{D8ECCBE1-AC71-4054-AAA6-2D50E5629504} = {C754652B-2ACB-4D47-8914-834E17919132}
+		{E4115DC9-FC88-47D6-B3B6-2400AD19B80D} = {C754652B-2ACB-4D47-8914-834E17919132}
+	EndGlobalSection
 EndGlobal


Property changes on: branches/aditi/libsecondlife-cs/mapgenerator
___________________________________________________________________
Name: svn:ignore
   + 
obj


Modified: branches/aditi/libsecondlife-cs/mapgenerator/mapgenerator.cs
===================================================================
--- branches/aditi/libsecondlife-cs/mapgenerator/mapgenerator.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/mapgenerator/mapgenerator.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -66,13 +66,13 @@
             }
             if (field.Type != FieldType.Variable)
             {
-                writer.WriteLine(&quot;            /// &lt;summary&gt;&quot; + field.Name + &quot; field&lt;/summary&gt;&quot;);
+                //writer.WriteLine(&quot;            /// &lt;summary&gt;&quot; + field.Name + &quot; field&lt;/summary&gt;&quot;);
                 writer.WriteLine(&quot;            public &quot; + type + &quot; &quot; + field.Name + &quot;;&quot;);
             }
             else
             {
                 writer.WriteLine(&quot;            private byte[] _&quot; + field.Name.ToLower() + &quot;;&quot;);
-                writer.WriteLine(&quot;            /// &lt;summary&gt;&quot; + field.Name + &quot; field&lt;/summary&gt;&quot;);
+                //writer.WriteLine(&quot;            /// &lt;summary&gt;&quot; + field.Name + &quot; field&lt;/summary&gt;&quot;);
                 writer.WriteLine(&quot;            public byte[] &quot; + field.Name + &quot;\n            {&quot;);
                 writer.WriteLine(&quot;                get { return _&quot; + field.Name.ToLower() + &quot;; }&quot;);
                 writer.WriteLine(&quot;                set\n                {&quot;);
@@ -332,7 +332,8 @@
             bool variableFields = false;
             bool floatFields = false;
 
-            writer.WriteLine(&quot;        /// &lt;summary&gt;&quot; + block.Name + &quot; block&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;        /// &lt;summary&gt;&quot; + block.Name + &quot; block&lt;/summary&gt;&quot;);
+            writer.WriteLine(&quot;        /// &lt;exclude/&gt;&quot;);
             writer.WriteLine(&quot;        public class &quot; + block.Name + &quot;Block\n        {&quot;);
 
             foreach (MapField field in block.Fields)
@@ -345,7 +346,7 @@
 
             // Length property
             writer.WriteLine(&quot;&quot;);
-            writer.WriteLine(&quot;            /// &lt;summary&gt;Length of this block serialized in bytes&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;            /// &lt;summary&gt;Length of this block serialized in bytes&lt;/summary&gt;&quot;);
             writer.WriteLine(&quot;            public int Length\n            {\n                get\n&quot; +
                 &quot;                {&quot;);
             int length = 0;
@@ -377,11 +378,11 @@
             writer.WriteLine(&quot;                }\n            }\n&quot;);
 
             // Default constructor
-            writer.WriteLine(&quot;            /// &lt;summary&gt;Default constructor&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;            /// &lt;summary&gt;Default constructor&lt;/summary&gt;&quot;);
             writer.WriteLine(&quot;            public &quot; + block.Name + &quot;Block() { }&quot;);
 
             // Constructor for building the class from bytes
-            writer.WriteLine(&quot;            /// &lt;summary&gt;Constructor for building the block from a byte array&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;            /// &lt;summary&gt;Constructor for building the block from a byte array&lt;/summary&gt;&quot;);
             writer.WriteLine(&quot;            public &quot; + block.Name + &quot;Block(byte[] bytes, ref int i)&quot; +
                 &quot;\n            {&quot;);
 
@@ -401,7 +402,7 @@
                 &quot;                }\n            }\n&quot;);
 
             // ToBytes() function
-            writer.WriteLine(&quot;            /// &lt;summary&gt;Serialize this block to a byte array&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;            /// &lt;summary&gt;Serialize this block to a byte array&lt;/summary&gt;&quot;);
             writer.WriteLine(&quot;            public void ToBytes(byte[] bytes, ref int i)\n            {&quot;);
 
             // Declare a byte[] variable if we need it for floating point field conversions
@@ -415,7 +416,7 @@
             writer.WriteLine(&quot;            }\n&quot;);
 
             // ToString() function
-            writer.WriteLine(&quot;            /// &lt;summary&gt;Serialize this block to a string&lt;/summary&gt;&lt;returns&gt;A string containing the serialized block&lt;/returns&gt;&quot;);
+            //writer.WriteLine(&quot;            /// &lt;summary&gt;Serialize this block to a string&lt;/summary&gt;&lt;returns&gt;A string containing the serialized block&lt;/returns&gt;&quot;);
             writer.WriteLine(&quot;            public override string ToString()\n            {&quot;);
             writer.WriteLine(&quot;                string output = \&quot;-- &quot; + block.Name + &quot; --\\n\&quot;;&quot;);
 
@@ -440,7 +441,8 @@
         {
             string sanitizedName;
 
-            writer.WriteLine(&quot;    /// &lt;summary&gt;&quot; + packet.Name + &quot; packet&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;    /// &lt;summary&gt;&quot; + packet.Name + &quot; packet&lt;/summary&gt;&quot;);
+            writer.WriteLine(&quot;    /// &lt;exclude/&gt;&quot;);
             writer.WriteLine(&quot;    public class &quot; + packet.Name + &quot;Packet : Packet\n    {&quot;);
 
             // Write out each block class
@@ -451,11 +453,11 @@
 
             // Header member
             writer.WriteLine(&quot;        private Header header;&quot;);
-            writer.WriteLine(&quot;        /// &lt;summary&gt;The header for this packet&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;        /// &lt;summary&gt;The header for this packet&lt;/summary&gt;&quot;);
             writer.WriteLine(&quot;        public override Header Header { get { return header; } set { header = value; } }&quot;);
 
             // PacketType member
-            writer.WriteLine(&quot;        /// &lt;summary&gt;Will return PacketType.&quot; + packet.Name+ &quot;&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;        /// &lt;summary&gt;Will return PacketType.&quot; + packet.Name+ &quot;&lt;/summary&gt;&quot;);
             writer.WriteLine(&quot;        public override PacketType Type { get { return PacketType.&quot; + 
                 packet.Name + &quot;; } }&quot;);
 
@@ -466,7 +468,7 @@
                 if (block.Name == &quot;Header&quot;) { sanitizedName = &quot;_&quot; + block.Name; }
                 else { sanitizedName = block.Name; }
 
-                writer.WriteLine(&quot;        /// &lt;summary&gt;&quot; + block.Name + &quot; block&lt;/summary&gt;&quot;);
+                //writer.WriteLine(&quot;        /// &lt;summary&gt;&quot; + block.Name + &quot; block&lt;/summary&gt;&quot;);
                 writer.WriteLine(&quot;        public &quot; + block.Name + &quot;Block&quot; +
                     ((block.Count != 1) ? &quot;[]&quot; : &quot;&quot;) + &quot; &quot; + sanitizedName + &quot;;&quot;);
             }
@@ -474,7 +476,7 @@
             writer.WriteLine(&quot;&quot;);
 
             // Default constructor
-            writer.WriteLine(&quot;        /// &lt;summary&gt;Default constructor&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;        /// &lt;summary&gt;Default constructor&lt;/summary&gt;&quot;);
             writer.WriteLine(&quot;        public &quot; + packet.Name + &quot;Packet()\n        {&quot;);
             writer.WriteLine(&quot;            Header = new &quot; + packet.Frequency.ToString() + &quot;Header();&quot;);
             writer.WriteLine(&quot;            Header.ID = &quot; + packet.ID + &quot;;&quot;);
@@ -506,7 +508,7 @@
 
             // Constructor that takes a byte array and beginning position only (no prebuilt header)
             bool seenVariable = false;
-            writer.WriteLine(&quot;        /// &lt;summary&gt;Constructor that takes a byte array and beginning position (no prebuilt header)&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;        /// &lt;summary&gt;Constructor that takes a byte array and beginning position (no prebuilt header)&lt;/summary&gt;&quot;);
             writer.WriteLine(&quot;        public &quot; + packet.Name + &quot;Packet(byte[] bytes, ref int i)\n        {&quot;);
             writer.WriteLine(&quot;            int packetEnd = bytes.Length - 1;&quot;);
             writer.WriteLine(&quot;            Header = new &quot; + packet.Frequency.ToString() + 
@@ -553,7 +555,7 @@
             seenVariable = false;
 
             // Constructor that takes a byte array and a prebuilt header
-            writer.WriteLine(&quot;        /// &lt;summary&gt;Constructor that takes a byte array and a prebuilt header&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;        /// &lt;summary&gt;Constructor that takes a byte array and a prebuilt header&lt;/summary&gt;&quot;);
             writer.WriteLine(&quot;        public &quot; + packet.Name + &quot;Packet(Header head, byte[] bytes, ref int i)\n        {&quot;);
             writer.WriteLine(&quot;            Header = head;&quot;);
             foreach (MapBlock block in packet.Blocks)
@@ -596,7 +598,7 @@
             writer.WriteLine(&quot;        }\n&quot;);
 
             // ToBytes() function
-            writer.WriteLine(&quot;        /// &lt;summary&gt;Serialize this packet to a byte array&lt;/summary&gt;&lt;returns&gt;A byte array containing the serialized packet&lt;/returns&gt;&quot;);
+            //writer.WriteLine(&quot;        /// &lt;summary&gt;Serialize this packet to a byte array&lt;/summary&gt;&lt;returns&gt;A byte array containing the serialized packet&lt;/returns&gt;&quot;);
             writer.WriteLine(&quot;        public override byte[] ToBytes()\n        {&quot;);
 
             writer.Write(&quot;            int length = &quot;);
@@ -667,7 +669,7 @@
             writer.WriteLine(&quot;            return bytes;\n        }\n&quot;);
 
             // ToString() function
-            writer.WriteLine(&quot;        /// &lt;summary&gt;Serialize this packet to a string&lt;/summary&gt;&lt;returns&gt;A string containing the serialized packet&lt;/returns&gt;&quot;);
+            //writer.WriteLine(&quot;        /// &lt;summary&gt;Serialize this packet to a string&lt;/summary&gt;&lt;returns&gt;A string containing the serialized packet&lt;/returns&gt;&quot;);
             writer.WriteLine(&quot;        public override string ToString()\n        {&quot;);
             writer.WriteLine(&quot;            string output = \&quot;--- &quot; + packet.Name + &quot; ---\\n\&quot;;&quot;);
 
@@ -727,7 +729,7 @@
             }
 
             // Write the PacketType enum
-            writer.WriteLine(&quot;    /// &lt;summary&gt;Used to identify the type of a packet&lt;/summary&gt;&quot;);
+            //writer.WriteLine(&quot;    /// &lt;summary&gt;Used to identify the type of a packet&lt;/summary&gt;&quot;);
             writer.WriteLine(&quot;    public enum PacketType\n    {\n&quot; +
                 &quot;        /// &lt;summary&gt;A generic value, not an actual packet type&lt;/summary&gt;\n&quot; +
                 &quot;        Default,&quot;);
@@ -735,7 +737,7 @@
             {
                 if (packet != null)
                 {
-                    writer.WriteLine(&quot;        /// &lt;summary&gt;&quot; + packet.Name + &quot;&lt;/summary&gt;&quot;);
+                    //writer.WriteLine(&quot;        /// &lt;summary&gt;&quot; + packet.Name + &quot;&lt;/summary&gt;&quot;);
                     writer.WriteLine(&quot;        &quot; + packet.Name + &quot;,&quot;);
                 }
             }
@@ -743,7 +745,7 @@
             {
                 if (packet != null)
                 {
-                    writer.WriteLine(&quot;        /// &lt;summary&gt;&quot; + packet.Name + &quot;&lt;/summary&gt;&quot;);
+                    //writer.WriteLine(&quot;        /// &lt;summary&gt;&quot; + packet.Name + &quot;&lt;/summary&gt;&quot;);
                     writer.WriteLine(&quot;        &quot; + packet.Name + &quot;,&quot;);
                 }
             }
@@ -751,28 +753,28 @@
             {
                 if (packet != null)
                 {
-                    writer.WriteLine(&quot;        /// &lt;summary&gt;&quot; + packet.Name + &quot;&lt;/summary&gt;&quot;);
+                    //writer.WriteLine(&quot;        /// &lt;summary&gt;&quot; + packet.Name + &quot;&lt;/summary&gt;&quot;);
                     writer.WriteLine(&quot;        &quot; + packet.Name + &quot;,&quot;);
                 }
             }
             writer.WriteLine(&quot;    }\n&quot;);
 
             // Write the base Packet class
-            writer.WriteLine(&quot;    /// &lt;summary&gt;Base class for all packet classes&lt;/summary&gt;\n&quot; +
+            writer.WriteLine(//&quot;    /// &lt;summary&gt;Base class for all packet classes&lt;/summary&gt;\n&quot; +
                 &quot;    public abstract class Packet\n    {\n&quot; + 
-                &quot;        /// &lt;summary&gt;Either a LowHeader, MediumHeader, or HighHeader representing the first bytes of the packet&lt;/summary&gt;\n&quot; +
+                //&quot;        /// &lt;summary&gt;Either a LowHeader, MediumHeader, or HighHeader representing the first bytes of the packet&lt;/summary&gt;\n&quot; +
                 &quot;        public abstract Header Header { get; set; }\n&quot; +
-                &quot;        /// &lt;summary&gt;The type of this packet, identified by it's frequency and ID&lt;/summary&gt;\n&quot; +
+                //&quot;        /// &lt;summary&gt;The type of this packet, identified by it's frequency and ID&lt;/summary&gt;\n&quot; +
                 &quot;        public abstract PacketType Type { get; }\n&quot; +
-                &quot;        /// &lt;summary&gt;Used internally to track timeouts, do not use&lt;/summary&gt;\n&quot; +
+                //&quot;        /// &lt;summary&gt;Used internally to track timeouts, do not use&lt;/summary&gt;\n&quot; +
                 &quot;        public int TickCount;\n\n&quot; +
-                &quot;        /// &lt;summary&gt;Serializes the packet in to a byte array&lt;/summary&gt;\n&quot; +
-                &quot;        /// &lt;returns&gt;A byte array containing the serialized packet payload, ready to be sent across the wire&lt;/returns&gt;\n&quot; +
+                //&quot;        /// &lt;summary&gt;Serializes the packet in to a byte array&lt;/summary&gt;\n&quot; +
+                //&quot;        /// &lt;returns&gt;A byte array containing the serialized packet payload, ready to be sent across the wire&lt;/returns&gt;\n&quot; +
                 &quot;        public abstract byte[] ToBytes();\n\n&quot; +
-                &quot;        /// &lt;summary&gt;Get the PacketType for a given packet id and packet frequency&lt;/summary&gt;\n&quot; +
-                &quot;        /// &lt;param name=\&quot;id\&quot;&gt;The packet ID from the header&lt;/param&gt;\n&quot; +
-                &quot;        /// &lt;param name=\&quot;frequency\&quot;&gt;Frequency of this packet&lt;/param&gt;\n&quot; +
-                &quot;        /// &lt;returns&gt;The packet type, or PacketType.Default&lt;/returns&gt;\n&quot; +
+                //&quot;        /// &lt;summary&gt;Get the PacketType for a given packet id and packet frequency&lt;/summary&gt;\n&quot; +
+                //&quot;        /// &lt;param name=\&quot;id\&quot;&gt;The packet ID from the header&lt;/param&gt;\n&quot; +
+                //&quot;        /// &lt;param name=\&quot;frequency\&quot;&gt;Frequency of this packet&lt;/param&gt;\n&quot; +
+                //&quot;        /// &lt;returns&gt;The packet type, or PacketType.Default&lt;/returns&gt;\n&quot; +
                 &quot;        public static PacketType GetType(ushort id, PacketFrequency frequency)\n        {\n&quot; +
                 &quot;            switch (frequency)\n            {\n                case PacketFrequency.Low:\n&quot; +
                 &quot;                    switch (id)\n                    {&quot;);
@@ -813,15 +815,14 @@
             writer.WriteLine(&quot;                    }\n                    break;\n            }\n\n&quot; +
                 &quot;            return PacketType.Default;\n        }\n&quot;);
 
-            writer.WriteLine(&quot;        /// &lt;summary&gt;Construct a packet in it's native class from a byte array&lt;/summary&gt;\n&quot; +
-                &quot;        /// &lt;param name=\&quot;bytes\&quot;&gt;Byte array containing the packet, starting at position 0&lt;/param&gt;\n&quot; +
-                &quot;        /// &lt;param name=\&quot;packetEnd\&quot;&gt;The last byte of the packet. If the packet was 76 bytes long, packetEnd would be 75&lt;/param&gt;\n&quot; +
-                &quot;        /// &lt;returns&gt;The native packet class for this type of packet, typecasted to the generic Packet&lt;/returns&gt;\n&quot; +
-                &quot;        public static Packet BuildPacket(byte[] bytes, ref int packetEnd)\n&quot; +
+            writer.WriteLine(//&quot;        /// &lt;summary&gt;Construct a packet in it's native class from a byte array&lt;/summary&gt;\n&quot; +
+                //&quot;        /// &lt;param name=\&quot;bytes\&quot;&gt;Byte array containing the packet, starting at position 0&lt;/param&gt;\n&quot; +
+                //&quot;        /// &lt;param name=\&quot;packetEnd\&quot;&gt;The last byte of the packet. If the packet was 76 bytes long, packetEnd would be 75&lt;/param&gt;\n&quot; +
+                //&quot;        /// &lt;returns&gt;The native packet class for this type of packet, typecasted to the generic Packet&lt;/returns&gt;\n&quot; +
+                &quot;        public static Packet BuildPacket(byte[] bytes, ref int packetEnd, byte[] zeroBuffer)\n&quot; +
                 &quot;        {\n            ushort id;\n            int i = 0;\n&quot; +
                 &quot;            Header header = Header.BuildHeader(bytes, ref i, ref packetEnd);\n&quot; +
                 &quot;            if (header.Zerocoded)\n            {\n&quot; +
-                &quot;                byte[] zeroBuffer = new byte[8192];\n&quot; +
                 &quot;                packetEnd = Helpers.ZeroDecode(bytes, packetEnd + 1, zeroBuffer) - 1;\n&quot; +
                 &quot;                bytes = zeroBuffer;\n            }\n\n&quot; + 
                 &quot;            if (bytes[4] == 0xFF)\n            {\n&quot; +

Modified: branches/aditi/libsecondlife-cs/mapgenerator/template.cs
===================================================================
--- branches/aditi/libsecondlife-cs/mapgenerator/template.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/mapgenerator/template.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -30,7 +30,7 @@
 namespace libsecondlife.Packets
 {
     /// &lt;summary&gt;
-    /// 
+    /// Thrown when a packet could not be successfully deserialized
     /// &lt;/summary&gt;
     public class MalformedDataException : ApplicationException
     {
@@ -51,11 +51,13 @@
     }
     
     /// &lt;summary&gt;
-    /// 
+    /// The Second Life header of a message template packet. Either 5, 6, or 8 
+    /// bytes in length at the beginning of the packet, and encapsulates any 
+    /// appended ACKs at the end of the packet as well
     /// &lt;/summary&gt;
     public abstract class Header
     {
-        /// &lt;summary&gt;&lt;/summary&gt;
+        /// &lt;summary&gt;The raw header data, does not include appended ACKs&lt;/summary&gt;
         public byte[] Data;
         /// &lt;summary&gt;&lt;/summary&gt;
         public byte Flags
@@ -67,25 +69,25 @@
         public bool Reliable
         {
             get { return (Data[0] &amp; Helpers.MSG_RELIABLE) != 0; }
-            set { if (value) { Data[0] |= (byte)Helpers.MSG_RELIABLE; } else { Data[0] -= (byte)Helpers.MSG_RELIABLE; } }
+            set { if (value) { Data[0] |= (byte)Helpers.MSG_RELIABLE; } else { byte mask = (byte)Helpers.MSG_RELIABLE ^ 0xFF; Data[0] &amp;= mask; } }
         }
         /// &lt;summary&gt;&lt;/summary&gt;
         public bool Resent
         {
             get { return (Data[0] &amp; Helpers.MSG_RESENT) != 0; }
-            set { if (value) { Data[0] |= (byte)Helpers.MSG_RESENT; } else { Data[0] -= (byte)Helpers.MSG_RESENT; } }
+            set { if (value) { Data[0] |= (byte)Helpers.MSG_RESENT; } else { byte mask = (byte)Helpers.MSG_RESENT ^ 0xFF; Data[0] &amp;= mask; } }
         }
         /// &lt;summary&gt;&lt;/summary&gt;
         public bool Zerocoded
         {
             get { return (Data[0] &amp; Helpers.MSG_ZEROCODED) != 0; }
-            set { if (value) { Data[0] |= (byte)Helpers.MSG_ZEROCODED; } else { Data[0] -= (byte)Helpers.MSG_ZEROCODED; } }
+            set { if (value) { Data[0] |= (byte)Helpers.MSG_ZEROCODED; } else { byte mask = (byte)Helpers.MSG_ZEROCODED ^ 0xFF; Data[0] &amp;= mask; } }
         }
         /// &lt;summary&gt;&lt;/summary&gt;
         public bool AppendedAcks
         {
             get { return (Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0; }
-            set { if (value) { Data[0] |= (byte)Helpers.MSG_APPENDED_ACKS; } else { Data[0] -= (byte)Helpers.MSG_APPENDED_ACKS; } }
+            set { if (value) { Data[0] |= (byte)Helpers.MSG_APPENDED_ACKS; } else { byte mask = (byte)Helpers.MSG_APPENDED_ACKS ^ 0xFF; Data[0] &amp;= mask; } }
         }
         /// &lt;summary&gt;&lt;/summary&gt;
         public ushort Sequence


Property changes on: branches/aditi/libsecondlife-cs/tests
___________________________________________________________________
Name: svn:ignore
   + 
obj


Deleted: branches/aditi/libsecondlife-cs/tests/DebugServer.cs
===================================================================
--- branches/aditi/libsecondlife-cs/tests/DebugServer.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/tests/DebugServer.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -1,122 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Net;
-using System.Net.Sockets;
-using System.Text.RegularExpressions;
-using System.Xml;
-using System.Threading;
-using Nwc.XmlRpc;
-using libsecondlife;
-using libsecondlife.Packets;
-
-namespace libsecondlife.Tests
-{
-    public class DebugServer
-    {
-        public bool Initialized = false;
-
-        private SecondLife libsl;
-        private bool done = false;
-        private Socket Listener;
-        private IPEndPoint Endpoint;
-        EndPoint RemoteEndpoint = new IPEndPoint(IPAddress.Loopback, 0);
-        private ushort Sequence = 0;
-
-        public DebugServer(string keywordFile, string mapFile, int port)
-        {
-            libsl = new SecondLife();
-
-            BindSocket(port);
-        }
-
-        private void BindSocket(int port)
-        {
-            Endpoint = new IPEndPoint(IPAddress.Loopback, port);
-            Listener = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
-
-            Console.WriteLine(&quot;[SERVER] Binding a UDP socket to &quot; + Endpoint.ToString());
-
-            try
-            {
-                Listener.Bind(Endpoint);
-            }
-            catch (SocketException)
-            {
-                Console.WriteLine(&quot;[SERVER] Failed to bind to &quot; + Endpoint.ToString());
-                return;
-            }
-
-            // Start listening for incoming data
-            Thread thread = new Thread(new ThreadStart(Listen));
-            thread.Start();
-
-            Initialized = true;
-        }
-
-        private void Listen()
-        {
-            Packet packet;
-            int length;
-            byte[] bytes = new byte[4096];
-
-            Console.WriteLine(&quot;[SERVER] Listening for incoming data on &quot; + Endpoint.ToString());
-
-            while (!done)
-            {
-                packet = null;
-
-                // Grab the next packet
-                length = Listener.ReceiveFrom(bytes, ref RemoteEndpoint);
-
-                Console.WriteLine(&quot;[SERVER] Received a packet from {0}&quot;, RemoteEndpoint.ToString());
-
-                if (Helpers.FieldToString(bytes).StartsWith(&quot;stopserver&quot;))
-                {
-                    Console.WriteLine(&quot;[SERVER] Received a shutdown request, stopping the server&quot;);
-                    done = true;
-                    break;
-                }
-
-                int packetEnd = length - 1;
-                packet = Packet.BuildPacket(bytes, ref packetEnd);
-
-                if (packet.Header.AppendedAcks)
-                {
-                    Console.WriteLine(&quot;[SERVER] Found &quot; + packet.Header.AckList.Length + &quot; appended acks&quot;);
-                }
-
-                if (packet.Header.Reliable)
-                {
-                    SendACK((uint)packet.Header.Sequence);
-                }
-
-                Console.WriteLine(packet.ToString());
-            }
-
-            Console.WriteLine(&quot;[SERVER] Shutting down the socket on &quot; + Endpoint.ToString());
-            Listener.Close();
-        }
-
-        private void SendACK(uint id)
-        {
-            try
-            {
-                PacketAckPacket ack = new PacketAckPacket();
-                ack.Packets = new PacketAckPacket.PacketsBlock[1];
-                ack.Packets[0].ID = id;
-
-                ack.Header.Reliable = false;
-
-                // Set the sequence number
-                ack.Header.Sequence = ++Sequence;
-
-                Listener.SendTo(ack.ToBytes(), RemoteEndpoint);
-            }
-            catch (Exception e)
-            {
-                Console.WriteLine(e.ToString());
-            }
-        }
-    }
-}

Copied: branches/aditi/libsecondlife-cs/tests/PacketTests.cs (from rev 649, trunk/libsecondlife-cs/tests/PacketTests.cs)

Copied: branches/aditi/libsecondlife-cs/tests/PrimObjectTests.cs (from rev 649, trunk/libsecondlife-cs/tests/PrimObjectTests.cs)

Modified: branches/aditi/libsecondlife-cs/tests/Tests.cs
===================================================================
--- branches/aditi/libsecondlife-cs/tests/Tests.cs	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/tests/Tests.cs	2006-11-29 00:53:56 UTC (rev 650)
@@ -8,88 +8,202 @@
 namespace libsecondlife.Tests
 {
     [TestFixture]
-    public class EndianTests : Assert
+    public class NetworkTests : Assert
     {
-        SecondLife Client = null;
-        DebugServer Server = null;
-        Packet CurrentPacket = null;
-        bool NetworkFinished = false;
+        SecondLife Client;
+        ulong CurrentRegionHandle = 0;
+        ulong AhernRegionHandle = 1096213093149184;
+        ulong MorrisRegionHandle = 1096213093149183;
+        bool DetectedObject = false;
+        bool DoneTeleporting = false;
+        TeleportStatus tpStatus = TeleportStatus.None;
+        string tpMessage = &quot;&quot;;
 
-        [SetUp]
-        public void Init()
+        public NetworkTests()
         {
             Client = new SecondLife();
-            Client.Network.AgentID = LLUUID.GenerateUUID();
-            Client.Network.SessionID = LLUUID.GenerateUUID();
 
-            Server = new DebugServer(&quot;keywords.txt&quot;, &quot;message_template.msg&quot;, 8338);
-            Assert.IsTrue(Server.Initialized, &quot;Failed to initialize the server, couldn't bind to port 8338?&quot;);
+            //string startLoc = NetworkManager.StartLocation(&quot;hooper&quot;, 128, 128, 32);
 
-            Simulator debugSim = Client.Network.Connect(IPAddress.Loopback, 8338, 1, true);
-            Assert.IsNotNull(debugSim, &quot;Failed to connect to the debugging simulator&quot;);
+            // Register callbacks
+            Client.Network.RegisterCallback(PacketType.ObjectUpdate, new NetworkManager.PacketCallback(ObjectUpdateHandler));
+            Client.Self.OnTeleport += new TeleportCallback(OnTeleportHandler);
 
-            Client.Network.RegisterCallback(PacketType.SimulatorAssign, new PacketCallback(SimulatorAssignHandler));
+            Client.Network.Login(&quot;Testing&quot;, &quot;Anvil&quot;, &quot;testinganvil&quot;, &quot;Unit Test Framework&quot;, //startLoc,
+                &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">contact at libsecondlife.org</A>&quot;/*, false*/);
         }
 
-        [Test]
-        public void U8Receive()
+        ~NetworkTests()
         {
-            CurrentPacket = null;
-            NetworkFinished = false;
+            Client.Network.Logout();
+        }
 
-            // 2. Instruct the server to send a SimulatorAssign to the client with some fixed values
+        [SetUp]
+        public void Init()
+        {
+            Assert.IsTrue(Client.Network.Connected, &quot;Client is not connected to the grid: &quot; + Client.Network.LoginError);
 
             int start = Environment.TickCount;
-
-            while (!NetworkFinished &amp;&amp; Environment.TickCount - start &lt; 5000)
+            while (Client.Network.CurrentSim.Region.Name == &quot;&quot;)
             {
-                System.Threading.Thread.Sleep(0);
+                if (Environment.TickCount - start &gt; 5000)
+                {
+                    Assert.Fail(&quot;Timeout waiting for a RegionHandshake packet&quot;);
+                }
             }
 
-            // 5. Parse the Packet and run our assertion(s)
-            Assert.IsNotNull(CurrentPacket, &quot;Never received the packet&quot;);
-            Assert.IsTrue(true);
+            //Assert.AreEqual(&quot;ahern&quot;, Client.Network.CurrentSim.Region.Name.ToLower(), &quot;Logged in to sim &quot; + 
+            //    Client.Network.CurrentSim.Region.Name + &quot; instead of Ahern&quot;);
         }
 
         [Test]
-        public void S8Receive()
+        public void DetectObjects()
         {
-            ;
+            int start = Environment.TickCount;
+            while (!DetectedObject)
+            {
+                if (Environment.TickCount - start &gt; 10000)
+                {
+                    Assert.Fail(&quot;Timeout waiting for an ObjectUpdate packet&quot;);
+                    return;
+                }
+            }
         }
 
         [Test]
-        public void U16Receive()
+        public void U64Receive()
         {
-            ;
+            int start = Environment.TickCount;
+            while (CurrentRegionHandle == 0)
+            {
+                if (Environment.TickCount - start &gt; 10000)
+                {
+                    Assert.Fail(&quot;Timeout waiting for an ObjectUpdate packet&quot;);
+                    return;
+                }
+            }
+
+            Assert.IsTrue(CurrentRegionHandle == AhernRegionHandle, &quot;Current region is &quot; +
+                CurrentRegionHandle + &quot; when we were expecting &quot; + AhernRegionHandle + &quot;, possible endian issue&quot;);
         }
 
         [Test]
-        public void S16Receive()
+        public void Teleport()
         {
-            ;
+            DoneTeleporting = false;
+            tpStatus = TeleportStatus.None;
+
+            Client.Self.Teleport(MorrisRegionHandle, new LLVector3(128, 128, 32));
+
+            int start = Environment.TickCount;
+
+            while (!DoneTeleporting)
+            {
+                System.Threading.Thread.Sleep(100);
+
+                if (Environment.TickCount - start &gt; 10000)
+                {
+                    Assert.Fail(&quot;Timeout waiting for the first teleport to finish&quot;);
+                    return;
+                }
+            }
+
+            Assert.IsTrue(tpStatus == TeleportStatus.Finished, &quot;Teleport status is &quot; + tpStatus.ToString() +
+                &quot;, message=&quot; + tpMessage);
+
+            // Wait for the region information to come in
+            start = Environment.TickCount;
+            while (Client.Network.CurrentSim.Region.Name == &quot;&quot;)
+            {
+                if (Environment.TickCount - start &gt; 5000)
+                {
+                    Assert.Fail(&quot;Timeout waiting for a RegionHandshake packet&quot;);
+                }
+            }
+
+            // Assert that we really did make it to our scheduled destination
+            Assert.AreEqual(&quot;morris&quot;, Client.Network.CurrentSim.Region.Name.ToLower(),
+                &quot;Expected to teleport to Morris, ended up in &quot; + Client.Network.CurrentSim.Region.Name +
+                &quot;. Possibly region full or offline?&quot;);
+
+            ///////////////////////////////////////////////////////////////////
+
+            // TODO: Add a local region teleport
+
+            ///////////////////////////////////////////////////////////////////
+
+            DoneTeleporting = false;
+            tpStatus = TeleportStatus.None;
+
+            Client.Self.Teleport(AhernRegionHandle, new LLVector3(128, 128, 32));
+
+            start = Environment.TickCount;
+
+            while (!DoneTeleporting)
+            {
+                System.Threading.Thread.Sleep(100);
+
+                if (Environment.TickCount - start &gt; 10000)
+                {
+                    Assert.Fail(&quot;Timeout waiting for the second teleport to finish&quot;);
+                    return;
+                }
+            }
+
+            Assert.IsTrue(tpStatus == TeleportStatus.Finished, &quot;Teleport status is &quot; + tpStatus.ToString() +
+                &quot;, message=&quot; + tpMessage);
+
+            // Wait for the region information to come in
+            start = Environment.TickCount;
+            while (Client.Network.CurrentSim.Region.Name == &quot;&quot;)
+            {
+                if (Environment.TickCount - start &gt; 5000)
+                {
+                    Assert.Fail(&quot;Timeout waiting for a RegionHandshake packet&quot;);
+                }
+            }
+
+            // Assert that we really did make it to our scheduled destination
+            Assert.AreEqual(&quot;ahern&quot;, Client.Network.CurrentSim.Region.Name.ToLower(),
+                &quot;Expected to teleport to Ahern, ended up in &quot; + Client.Network.CurrentSim.Region.Name +
+                &quot;. Possibly region full or offline?&quot;);
         }
 
-        private void SimulatorAssignHandler(Packet packet, Simulator sim)
+        private void ObjectUpdateHandler(Packet packet, Simulator sim)
         {
-            CurrentPacket = packet;
-            NetworkFinished = true;
+            ObjectUpdatePacket update = (ObjectUpdatePacket)packet;
+
+            DetectedObject = true;
+            CurrentRegionHandle = update.RegionData.RegionHandle;
         }
 
-        [TearDown]
-        public void Shutdown()
+        private void OnTeleportHandler(string message, TeleportStatus status)
         {
-            try
+            switch (status)
             {
-                Client.Network.SendPacket(System.Text.Encoding.UTF8.GetBytes(&quot;stopserver&quot;));
-                Client.Network.Logout();
+                case TeleportStatus.None:
+                    break;
+                case TeleportStatus.Start:
+                    break;
+                case TeleportStatus.Progress:
+                    break;
+                case TeleportStatus.Failed:
+                    DoneTeleporting = true;
+                    break;
+                case TeleportStatus.Finished:
+                    DoneTeleporting = true;
+                    break;
             }
-            catch (NotConnectedException)
-            {
-                Assert.IsTrue(false, &quot;Logout failed, not connected&quot;);
-            }
 
-            Client = null;
-            Server = null;
+            tpMessage = message;
+            tpStatus = status;
         }
+
+        [TearDown]
+        public void Shutdown()
+        {
+            //Client.Network.Logout();
+            //Client = null;
+        }
     }
 }

Copied: branches/aditi/libsecondlife-cs/tests/TypeTests.cs (from rev 649, trunk/libsecondlife-cs/tests/TypeTests.cs)

Modified: branches/aditi/libsecondlife-cs/tests/libsecondlife.Tests.csproj
===================================================================
--- branches/aditi/libsecondlife-cs/tests/libsecondlife.Tests.csproj	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife-cs/tests/libsecondlife.Tests.csproj	2006-11-29 00:53:56 UTC (rev 650)
@@ -37,7 +37,9 @@
     &lt;Reference Include=&quot;System.Xml&quot; /&gt;
   &lt;/ItemGroup&gt;
   &lt;ItemGroup&gt;
-    &lt;Compile Include=&quot;DebugServer.cs&quot; /&gt;
+    &lt;Compile Include=&quot;PacketTests.cs&quot; /&gt;
+    &lt;Compile Include=&quot;PrimObjectTests.cs&quot; /&gt;
+    &lt;Compile Include=&quot;TypeTests.cs&quot; /&gt;
     &lt;Compile Include=&quot;Tests.cs&quot; /&gt;
   &lt;/ItemGroup&gt;
   &lt;ItemGroup&gt;

Modified: branches/aditi/libsecondlife.build
===================================================================
--- branches/aditi/libsecondlife.build	2006-11-29 00:32:25 UTC (rev 649)
+++ branches/aditi/libsecondlife.build	2006-11-29 00:53:56 UTC (rev 650)
@@ -23,7 +23,8 @@
 
   &lt;!-- build sets --&gt;
   &lt;fileset id=&quot;apps&quot;&gt;
-    &lt;!-- &lt;include name=&quot;applications/Decoder/*.build&quot; /&gt; --&gt;
+    &lt;include name=&quot;applications/TestBot/*.build&quot; /&gt;
+    &lt;include name=&quot;applications/Decoder/*.build&quot; /&gt;
     &lt;!-- &lt;include name=&quot;applications/SecondSuite/*.build&quot; /&gt; --&gt;
     &lt;!-- &lt;include name=&quot;applications/SLChat/*.build&quot; /&gt; --&gt;
     &lt;include name=&quot;applications/SLIRC/*.build&quot; /&gt;

Copied: branches/aditi/libsecondlife.nunit (from rev 649, trunk/libsecondlife.nunit)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000005.html">[Libsecondlife-commits] r649 - in trunk/libsecondlife-cs: .	examples/TestClient examples/TestClient/Commands
</A></li>
	<LI>Next message: <A HREF="000006.html">[Libsecondlife-commits] r651 - branches/aditi/libsecondlife-cs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8">[ date ]</a>
              <a href="thread.html#8">[ thread ]</a>
              <a href="subject.html#8">[ subject ]</a>
              <a href="author.html#8">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">More information about the Libsecondlife-commits
mailing list</a><br>
</body></html>
