<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Libsecondlife-commits] r734 - trunk/SLProxy
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/libsecondlife-commits/2006-December/index.html" >
   <LINK REL="made" HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r734%20-%20trunk/SLProxy&In-Reply-To=%3C200612172025.kBHKPLwg011743%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000100.html">
   <LINK REL="Next"  HREF="000102.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Libsecondlife-commits] r734 - trunk/SLProxy</H1>
    <B>qode at mail.berlios.de</B> 
    <A HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r734%20-%20trunk/SLProxy&In-Reply-To=%3C200612172025.kBHKPLwg011743%40sheep.berlios.de%3E"
       TITLE="[Libsecondlife-commits] r734 - trunk/SLProxy">qode at mail.berlios.de
       </A><BR>
    <I>Sun Dec 17 21:25:21 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000100.html">[Libsecondlife-commits] r733 - trunk
</A></li>
        <LI>Next message: <A HREF="000102.html">[Libsecondlife-commits] r735 - trunk/SLProxy
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#101">[ date ]</a>
              <a href="thread.html#101">[ thread ]</a>
              <a href="subject.html#101">[ subject ]</a>
              <a href="author.html#101">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: qode
Date: 2006-12-17 21:25:16 +0100 (Sun, 17 Dec 2006)
New Revision: 734

Modified:
   trunk/SLProxy/README.txt
   trunk/SLProxy/SLProxy.cs
   trunk/SLProxy/SLProxy.csproj
Log:
Added my (untested) version of slproxy. Please note that it has yet to be tested and any slproxy apps have not be retrofitted for this release. AKA, it breaks the old legacy applications. I'm going to test officially today (hopefully it works in the most part) and commit any bug fixes here in this svn. 

Modified: trunk/SLProxy/README.txt
===================================================================
--- trunk/SLProxy/README.txt	2006-12-17 02:45:06 UTC (rev 733)
+++ trunk/SLProxy/README.txt	2006-12-17 20:25:16 UTC (rev 734)
@@ -1,363 +1,371 @@
-SLProxy is a library that works in conjunction with libsecondlife to
-allow applications to wedge themselves between the official Second
-Life client and servers.  SLProxy applications can inspect and modify
-any packet as it passes between the client and the servers; remove
-packets from the stream; and inject new packets into the stream.
-SLProxy automatically takes care of tracking circuits and modifying
-sequence numbers and acknowledgements to account for changes to the
-packet stream.
-
-The continued existence of this software of course rests on the good
-will of Linden Lab toward the Second Life reverse engineering effort.
-Please use common sense when designing applications and report any
-security holes you may find to <A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">security at lindenlab.com.</A>
-
-To use an SLProxy application, you must first start the proxy, then
-start Second Life with the switch `-loginuri <A HREF="http://localhost:8080/">http://localhost:8080/</A>'.
-In Windows, add this switch (without the quotes) to your Second Life
-shortcut.  In MacOS X, this can be accomplished by sending the
-following commands to the Terminal (assuming Second Life is installed
-in /Applications):
-
-	cd &quot;/Applications/Second Life.app&quot;
-	&quot;Contents/MacOS/Second Life&quot; -loginuri <A HREF="http://localhost:8080/">http://localhost:8080/</A>
-
-Note that for security reasons, by default, SLProxy applications must
-be running on the same computer as Second Life.  If you need to run a
-proxy on a different machine or port, start the proxy with the
---proxy-help switch and see the options available.
-
-SLProxy can only handle one client using a proxy at a time.
-
-BUILDING
-========
-
-To build SLProxy, you must check out the entire libsecondlife trunk
-with subversion:
-
-  svn co <A HREF="svn://svn.gna.org/svn/libsecondlife/trunk">svn://svn.gna.org/svn/libsecondlife/trunk</A> libsecondlife
-
-The libsecondlife-cs project must be built first; see
-libsecondlife-cs/README for instructions.  Building SLProxy should be
-straightforward with Microsoft Visual Studio.  If you're using Mono,
-you can build the solution with the included build script:
-
-  perl build
-
-The SLProxy library and its example applications will be built in
-bin/Debug.  In order to run the example applications, you must first
-add the libsecondlife-cs build directory to your MONO_PATH environment
-variable.  For example, if your libsecondlife-cs directory is
-~/libsecondlife/libsecondlife-cs and your shell is bash, you can type:
-
-  export MONO_PATH=$MONO_PATH:~/libsecondlife/libsecondlife-cs/bin/Debug/
-
-INCLUDED APPLICATIONS
-=====================
-
-Included with SLProxy are a few example application, which are covered
-in this section.
-
-1. Analyst
-----------
-
-Analyst makes SLProxy's packet inspection and modification
-functionality interactive.  When connected to Second Life through
-Analyst, you use the following commands by saying them using in-world
-chat:
-
-/log &lt;packet name&gt;
-
-  Packets of type &lt;packet name&gt; will be dumped to the console.  For
-  example, say `/log ChatFromSimulator' to get a packet dump of all
-  incoming chat.
-
-/-log &lt;packet name&gt;
-
-  Packets of type &lt;packet name&gt; will no longer be dumped to the
-  console.
-
-/log *
-
-  All packets will be dumped to the console.
-
-/-log *
-
-  No packets will be dumped to the console.
-
-/grep [regex]
-
-  Only log packets that have a field for which regex matches
-  &lt;packet name&gt;.&lt;block name&gt;.&lt;field name&gt; = &lt;value&gt;.  To stop
-  filtering, type /grep without an argument.  Matches are case
-  insensitive.  In the case of a variable field, Analyst will try to
-  convert it into a string; if that doesn't match, it will try
-  converting it into a hexidecimal numeral preceeded by 0x.
-
-/set &lt;packet name&gt; &lt;block name&gt; &lt;field name&gt; &lt;value&gt;
-
-  All forthcoming packets of type &lt;packet name&gt; will have the field
-  identified by &lt;block name&gt; and &lt;field name&gt; set to &lt;value&gt;.  For
-  example, if you say `/set ChatFromViewer ChatData Type 0',
-  everything you say thereafter will be whispered.  Values for
-  variable fields will be interpreted as strings unless they begin
-  with a 0x, in which case they will be treated as hexidecimal
-  numerals representing the contents of the field.
-
-/-set &lt;packet name&gt; &lt;block name&gt; &lt;field name&gt;
-
-  Packets of type &lt;packet name&gt; will no longer have the field
-  identified by &lt;block name&gt; and &lt;field name&gt; modified.
-
-/-set *
-
-  No fields will be modified.
-
-/inject &lt;packet file&gt; [value]
-
-  Inject the packet described by &lt;packet file&gt;.packet in the working
-  directory.  The [value] is optional and may be required by some
-  packet files.  `/in' is an alias for `/inject'.  The syntax of a
-  packet file is described in section 2.1.  SLProxy comes with two
-  example packet files: god.packet allows you to enable hacked god
-  mode by typing `/inject god', and whisper.packet allows you to
-  whisper by typing `/inject whisper &lt;message&gt;'.
-
-These commands will not be forwarded to the server, so other people
-won't hear you say them.
-
-Analyst accepts a --log-all command line switch, which causes the
-proxy to start out logging all packets as if you had typed `/log *'.
-This can be useful if you want to capture a complete dump of your
-session, including login.
-
-Analyst also accepts a --log-login command line switch, which causes
-the XML-RPC login request and response to dumped to the console.
-
-2.1 Packet files
-- - - - - - - -
-
-A packet file describes a packet that can be injected with the /inject
-command.  Please refer to god.packet and whisper.packet (in the
-bin/Debug/ directory) as examples.
-
-The first line of a packet file must contain the word `in' or `out',
-specifying whether the packet is incoming or outgoing, respectively,
-followed by the name of the packet.
-
-The remainder of the file specifies the packet's blocks and fields.  A
-block is described by placing its name in square brackets
-(e.g. `[GrantData]').  Following the the line specifying the block's
-name, the block's fields and values are specified, separated by equal
-signs (e.g. `GodLevel = 255'), one per line.
-
-The value of a field can be a literal value (e.g. `255'), or one of
-the following special values:
-
-$Value
-
-  the [value] specified by the user
-
-$UUID
-
-  a random UUID
-
-$AgentID
-
-  the user's AgentID
-
-$SessionID
-
-  the user's SessionID
-
-2. ChatConsole
---------------
-
-ChatConsole is a trivial SLProxy application intended as an example of
-how SLProxy applications can be written.  When connected to Second
-Life through ChatConsole, all in-world chat will be echoed to the
-console, and anything typed in the console will be echoed to the game as
-in-world chat.
-
-PUBLIC INTERFACE
-================
-
-This section describes the interface that SLProxy applications will
-use to interact with the packet stream.  Please see ChatConsole.cs for
-a simple example of how this interface can be used.
-
-SLProxy extends the functionality of libsecondlife, so we assume here
-that the reader is already familiar with libsecondlife's Packet and
-PacketBuilder classes.
-
-1. ProxyConfig class
---------------------
-
-An instance of ProxyConfig represents the configuration of a Proxy
-object, and must be provided when constructing a Proxy.  ProxyConfig
-has two constructors:
-
-	ProxyConfig(string userAgent, string author)
-	ProxyConfig(string userAgent, string author, string[] args)
-
-Both constructors require a user agent name and the author's email
-address.  These are sent to Second Life's login server to identify the
-client, and to allow Linden Lab to get in touch with authors whose
-applications may inadvertantly be causing problems.  The second
-constructor is preferred and takes an array of command-line arguments
-that allow the user to override certain network settings.  For a list
-of command line arguments, start your appliation with the --proxy-help
-switch.
-
-2. Proxy class
---------------
-
-The Proxy class represents an instance of an SLProxy and provides the
-methods necessary to modify the packet stream.  Proxy's sole
-constructor takes an instance of ProxyConfig.
-
-2.1 Login delegates
-- - - - - - - - - -
-
-You may specify that SLProxy should call a delegate method in your
-application when the user requests login or the server responds.
-
-	delegate void XmlRpcRequestDelegate(XmlRpcRequest request)
-	delegate void XmlRpcResponseDelegate(XmlRpcResponse response)
-	void SetLoginRequestDelegate(XmlRpcRequestDelegate loginRequestDelegate)
-	void SetLoginResponseDelegate(XmlRpcResponseDelegate loginResponseDelegate)
-
-A login response delegate, in particular, is useful for retrieving the
-agent_id and session_id, which are required when injecting certain
-types of packets.  See ChatConsole.cs for an example of how these can
-be retrieved.
-
-Note that all delegates must terminate (not go into an infinite loop),
-and must be thread-safe.
-
-2.2 Packet delegates
-- - - - - - - - - -
-
-Packet delegates allow you to inspect and modify packets as they pass
-between the client and the server:
-
-	delegate Packet PacketDelegate(Packet packet, IPEndPoint endPoint)
-	void AddDelegate(string packetName, Direction direction, PacketDelegate packetDelegate)
-	void RemoveDelegate(string packetName, Direction direction)
-
-AddDelegate adds a callback delegate for packets named packetName
-going direction.  Directions are either Direction.Incoming, meaning
-packets heading from the server to the client, or Direction.Outgoing,
-meaning packets heading from the client to the server.  Only one
-delegate can apply to a packet at a time; if you add a new delegate
-with the same packetName and direction, the old one will be removed.
-
-RemoveDelegate simply removes the delegate for the specified type of
-packet.
-
-PacketDelegate methods are passed a copy of the packet (in the form of
-a libsecondlife Packet object) and the IPEndPoint of the server that
-sent (or will receive) the packet.  PacketDelegate methods may do one
-of three things:
-
-1. Return the same packet, in which case it will be passed on.
-2. Return a new packet (built with libsecondlife), in which case the
-   new packet will substitute for the original.  SLProxy will
-   automatically copy the sequence number and appended ACKs from the
-   old packet to the new one.
-3. Return null, in which case the packet will not be passed on.
-
-SLProxy automatically takes care of ensuring that sequence numbers and
-acknowledgements are adjusted to account for changes made by the
-application.  When replacing a reliable packet with an unreliable
-packet or removing a reliable packet, a fake acknowledgement is
-injected.  When replacing an unreliable packet with a reliable packet,
-SLProxy ensures delivery and intercepts its acknowledgement.  Note
-that if a reliable packet is passed on but then lost on the network,
-Second Life will resend it and the delegate will be called again.  You
-can tell if a packet is being resent by checking if (packet.Data[0] &amp;
-Helpers.MSG_RESENT) is nonzero, although be advised that it's possible
-that the original packet never made it to the proxy and the packet
-will be marked RESENT the first time the proxy ever sees it.
-
-Note that all delegates must terminate (not go into an infinite loop),
-and must be thread-safe.
-
-2.3 Packet injection
-- - - - - - - - - -
-
-New packets may be injected into the stream at any point, either
-during a delegate callback or by another thread in your application.
-Packets are injected with the InjectPacket method:
-
-	void InjectPacket(Packet packet, Direction direction)
-
-This will inject a packet heading to either the client or to the
-active server, when direction is Direction.Incoming or
-Direction.Outgoing, respectively.  The packet's sequence number will
-be set automatically, and if the packet is reliable, SLProxy will
-ensure its delivery and intercept its acknowledgement.
-
-Injecting a packet immediately upon (or prior to) connection is not
-recommended, since the client and the server won't have initialized
-their session yet.
-
-2.4 Starting and stopping the proxy
-- - - - - - - - - - - - - - - - - -
-
-Once you've constructed a Proxy and added your delegates, you must
-start it with the Start method:
-
-	void Start()
-
-Once started, the proxy will begin listening for connections.  The
-Start method spawns new threads for the proxy and returns immediately.
-
-When your application is ready to shut down, you must call the Stop
-method:
-
-	void Stop()
-
-Note that this may not actually force the proxy to stop accepting
-connections; it merely guarantees that all foreground threads are
-stopped, allowing the application to exit cleanly.
-
-3. PacketUtility class
-----------------------
-
-The PacketUtility class provides a handful of static methods which may
-be useful when inspecting and modifying packets.
-
-3.1 Hashtable Unbuild(Packet packet)
-- - - - - - - - - - - - - - - - - -
-
-The Unbuild method takes a Packet object and returns a table of
-blocks, structured in a format suitable for passing to PacketUtility's
-GetField and SetField methods or PacketBuilder's BuildPacket method.
-
-For example, this should make an approximate copy of a packet:
-
-Hashtable packetBlocks = PacketUtility.Unbuild(packet);
-Packet packetCopy = PacketBuilder.BuildPacket(packet.Layout.Name, protocolManager, packetBlocks, packet.Data[0]);
-
-3.2 object GetField(Hashtable blocks, string block, string field)
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-
-The GetField method takes a table of blocks (produced by
-PacketUtility.Unbuild) and extracts the value of a particular field.
-If the field is part of a variable block, an arbitrary instance of the
-field will be returned.  If the field does not exist, null will be
-returned.
-
-3.3 void SetField(Hashtable blocks, string block, string field, object value)
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-
-The SetField method takes a table of blocks (produced by
-PacketUtility.Unbuild) and sets the value of a particular field.  If
-the field is part of a variable block, all instances of the field will
-be set.  If the field does not exist, SetField will have no effect.
-
-This can be used by a packet delegate method in conjunction with
-PacketUtility.Unbuild and PacketBuilder.BuildPacket to substitute a
-new packet that is a copy of the original packet with certain fields
-modified.
+NOTE: THIS DEVELOPER BRANCH IS THE NEW PREGEN SLPROXY. THIS DOCUMENT
+MAY NOT BE UP TO DATE WITH THIS VERSION. THIS SLPROXY VERSION IS STILL
+YET TO BE TESTED, SO EXPECT SOME/MOST/ALL FUNCTIONS TO NOT WORK.
+
+MODIFICATIONS BY &quot;ALPHA ZAIUS&quot; / ANDREW ORTMAN. QODE IN EFNET: #LIBSL
+AND #LIBSL-DEV
+
+---------------------------------------------------------------------
+SLProxy is a library that works in conjunction with libsecondlife to
+allow applications to wedge themselves between the official Second
+Life client and servers.  SLProxy applications can inspect and modify
+any packet as it passes between the client and the servers; remove
+packets from the stream; and inject new packets into the stream.
+SLProxy automatically takes care of tracking circuits and modifying
+sequence numbers and acknowledgements to account for changes to the
+packet stream.
+
+The continued existence of this software of course rests on the good
+will of Linden Lab toward the Second Life reverse engineering effort.
+Please use common sense when designing applications and report any
+security holes you may find to <A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">security at lindenlab.com.</A>
+
+To use an SLProxy application, you must first start the proxy, then
+start Second Life with the switch `-loginuri <A HREF="http://localhost:8080/">http://localhost:8080/</A>'.
+In Windows, add this switch (without the quotes) to your Second Life
+shortcut.  In MacOS X, this can be accomplished by sending the
+following commands to the Terminal (assuming Second Life is installed
+in /Applications):
+
+	cd &quot;/Applications/Second Life.app&quot;
+	&quot;Contents/MacOS/Second Life&quot; -loginuri <A HREF="http://localhost:8080/">http://localhost:8080/</A>
+
+Note that for security reasons, by default, SLProxy applications must
+be running on the same computer as Second Life.  If you need to run a
+proxy on a different machine or port, start the proxy with the
+--proxy-help switch and see the options available.
+
+SLProxy can only handle one client using a proxy at a time.
+
+BUILDING
+========
+
+To build SLProxy, you must check out the entire libsecondlife trunk
+with subversion:
+
+  svn co <A HREF="svn://svn.gna.org/svn/libsecondlife/trunk">svn://svn.gna.org/svn/libsecondlife/trunk</A> libsecondlife
+
+The libsecondlife-cs project must be built first; see
+libsecondlife-cs/README for instructions.  Building SLProxy should be
+straightforward with Microsoft Visual Studio.  If you're using Mono,
+you can build the solution with the included build script:
+
+  perl build
+
+The SLProxy library and its example applications will be built in
+bin/Debug.  In order to run the example applications, you must first
+add the libsecondlife-cs build directory to your MONO_PATH environment
+variable.  For example, if your libsecondlife-cs directory is
+~/libsecondlife/libsecondlife-cs and your shell is bash, you can type:
+
+  export MONO_PATH=$MONO_PATH:~/libsecondlife/libsecondlife-cs/bin/Debug/
+
+INCLUDED APPLICATIONS
+=====================
+
+Included with SLProxy are a few example application, which are covered
+in this section.
+
+1. Analyst
+----------
+
+Analyst makes SLProxy's packet inspection and modification
+functionality interactive.  When connected to Second Life through
+Analyst, you use the following commands by saying them using in-world
+chat:
+
+/log &lt;packet name&gt;
+
+  Packets of type &lt;packet name&gt; will be dumped to the console.  For
+  example, say `/log ChatFromSimulator' to get a packet dump of all
+  incoming chat.
+
+/-log &lt;packet name&gt;
+
+  Packets of type &lt;packet name&gt; will no longer be dumped to the
+  console.
+
+/log *
+
+  All packets will be dumped to the console.
+
+/-log *
+
+  No packets will be dumped to the console.
+
+/grep [regex]
+
+  Only log packets that have a field for which regex matches
+  &lt;packet name&gt;.&lt;block name&gt;.&lt;field name&gt; = &lt;value&gt;.  To stop
+  filtering, type /grep without an argument.  Matches are case
+  insensitive.  In the case of a variable field, Analyst will try to
+  convert it into a string; if that doesn't match, it will try
+  converting it into a hexidecimal numeral preceeded by 0x.
+
+/set &lt;packet name&gt; &lt;block name&gt; &lt;field name&gt; &lt;value&gt;
+
+  All forthcoming packets of type &lt;packet name&gt; will have the field
+  identified by &lt;block name&gt; and &lt;field name&gt; set to &lt;value&gt;.  For
+  example, if you say `/set ChatFromViewer ChatData Type 0',
+  everything you say thereafter will be whispered.  Values for
+  variable fields will be interpreted as strings unless they begin
+  with a 0x, in which case they will be treated as hexidecimal
+  numerals representing the contents of the field.
+
+/-set &lt;packet name&gt; &lt;block name&gt; &lt;field name&gt;
+
+  Packets of type &lt;packet name&gt; will no longer have the field
+  identified by &lt;block name&gt; and &lt;field name&gt; modified.
+
+/-set *
+
+  No fields will be modified.
+
+/inject &lt;packet file&gt; [value]
+
+  Inject the packet described by &lt;packet file&gt;.packet in the working
+  directory.  The [value] is optional and may be required by some
+  packet files.  `/in' is an alias for `/inject'.  The syntax of a
+  packet file is described in section 2.1.  SLProxy comes with two
+  example packet files: god.packet allows you to enable hacked god
+  mode by typing `/inject god', and whisper.packet allows you to
+  whisper by typing `/inject whisper &lt;message&gt;'.
+
+These commands will not be forwarded to the server, so other people
+won't hear you say them.
+
+Analyst accepts a --log-all command line switch, which causes the
+proxy to start out logging all packets as if you had typed `/log *'.
+This can be useful if you want to capture a complete dump of your
+session, including login.
+
+Analyst also accepts a --log-login command line switch, which causes
+the XML-RPC login request and response to dumped to the console.
+
+2.1 Packet files
+- - - - - - - -
+
+A packet file describes a packet that can be injected with the /inject
+command.  Please refer to god.packet and whisper.packet (in the
+bin/Debug/ directory) as examples.
+
+The first line of a packet file must contain the word `in' or `out',
+specifying whether the packet is incoming or outgoing, respectively,
+followed by the name of the packet.
+
+The remainder of the file specifies the packet's blocks and fields.  A
+block is described by placing its name in square brackets
+(e.g. `[GrantData]').  Following the the line specifying the block's
+name, the block's fields and values are specified, separated by equal
+signs (e.g. `GodLevel = 255'), one per line.
+
+The value of a field can be a literal value (e.g. `255'), or one of
+the following special values:
+
+$Value
+
+  the [value] specified by the user
+
+$UUID
+
+  a random UUID
+
+$AgentID
+
+  the user's AgentID
+
+$SessionID
+
+  the user's SessionID
+
+2. ChatConsole
+--------------
+
+ChatConsole is a trivial SLProxy application intended as an example of
+how SLProxy applications can be written.  When connected to Second
+Life through ChatConsole, all in-world chat will be echoed to the
+console, and anything typed in the console will be echoed to the game as
+in-world chat.
+
+PUBLIC INTERFACE
+================
+
+This section describes the interface that SLProxy applications will
+use to interact with the packet stream.  Please see ChatConsole.cs for
+a simple example of how this interface can be used.
+
+SLProxy extends the functionality of libsecondlife, so we assume here
+that the reader is already familiar with libsecondlife's Packet and
+PacketBuilder classes.
+
+1. ProxyConfig class
+--------------------
+
+An instance of ProxyConfig represents the configuration of a Proxy
+object, and must be provided when constructing a Proxy.  ProxyConfig
+has two constructors:
+
+	ProxyConfig(string userAgent, string author)
+	ProxyConfig(string userAgent, string author, string[] args)
+
+Both constructors require a user agent name and the author's email
+address.  These are sent to Second Life's login server to identify the
+client, and to allow Linden Lab to get in touch with authors whose
+applications may inadvertantly be causing problems.  The second
+constructor is preferred and takes an array of command-line arguments
+that allow the user to override certain network settings.  For a list
+of command line arguments, start your appliation with the --proxy-help
+switch.
+
+2. Proxy class
+--------------
+
+The Proxy class represents an instance of an SLProxy and provides the
+methods necessary to modify the packet stream.  Proxy's sole
+constructor takes an instance of ProxyConfig.
+
+2.1 Login delegates
+- - - - - - - - - -
+
+You may specify that SLProxy should call a delegate method in your
+application when the user requests login or the server responds.
+
+	delegate void XmlRpcRequestDelegate(XmlRpcRequest request)
+	delegate void XmlRpcResponseDelegate(XmlRpcResponse response)
+	void SetLoginRequestDelegate(XmlRpcRequestDelegate loginRequestDelegate)
+	void SetLoginResponseDelegate(XmlRpcResponseDelegate loginResponseDelegate)
+
+A login response delegate, in particular, is useful for retrieving the
+agent_id and session_id, which are required when injecting certain
+types of packets.  See ChatConsole.cs for an example of how these can
+be retrieved.
+
+Note that all delegates must terminate (not go into an infinite loop),
+and must be thread-safe.
+
+2.2 Packet delegates
+- - - - - - - - - -
+
+Packet delegates allow you to inspect and modify packets as they pass
+between the client and the server:
+
+	delegate Packet PacketDelegate(Packet packet, IPEndPoint endPoint)
+	void AddDelegate(string packetName, Direction direction, PacketDelegate packetDelegate)
+	void RemoveDelegate(string packetName, Direction direction)
+
+AddDelegate adds a callback delegate for packets named packetName
+going direction.  Directions are either Direction.Incoming, meaning
+packets heading from the server to the client, or Direction.Outgoing,
+meaning packets heading from the client to the server.  Only one
+delegate can apply to a packet at a time; if you add a new delegate
+with the same packetName and direction, the old one will be removed.
+
+RemoveDelegate simply removes the delegate for the specified type of
+packet.
+
+PacketDelegate methods are passed a copy of the packet (in the form of
+a libsecondlife Packet object) and the IPEndPoint of the server that
+sent (or will receive) the packet.  PacketDelegate methods may do one
+of three things:
+
+1. Return the same packet, in which case it will be passed on.
+2. Return a new packet (built with libsecondlife), in which case the
+   new packet will substitute for the original.  SLProxy will
+   automatically copy the sequence number and appended ACKs from the
+   old packet to the new one.
+3. Return null, in which case the packet will not be passed on.
+
+SLProxy automatically takes care of ensuring that sequence numbers and
+acknowledgements are adjusted to account for changes made by the
+application.  When replacing a reliable packet with an unreliable
+packet or removing a reliable packet, a fake acknowledgement is
+injected.  When replacing an unreliable packet with a reliable packet,
+SLProxy ensures delivery and intercepts its acknowledgement.  Note
+that if a reliable packet is passed on but then lost on the network,
+Second Life will resend it and the delegate will be called again.  You
+can tell if a packet is being resent by checking if (packet.Data[0] &amp;
+Helpers.MSG_RESENT) is nonzero, although be advised that it's possible
+that the original packet never made it to the proxy and the packet
+will be marked RESENT the first time the proxy ever sees it.
+
+Note that all delegates must terminate (not go into an infinite loop),
+and must be thread-safe.
+
+2.3 Packet injection
+- - - - - - - - - -
+
+New packets may be injected into the stream at any point, either
+during a delegate callback or by another thread in your application.
+Packets are injected with the InjectPacket method:
+
+	void InjectPacket(Packet packet, Direction direction)
+
+This will inject a packet heading to either the client or to the
+active server, when direction is Direction.Incoming or
+Direction.Outgoing, respectively.  The packet's sequence number will
+be set automatically, and if the packet is reliable, SLProxy will
+ensure its delivery and intercept its acknowledgement.
+
+Injecting a packet immediately upon (or prior to) connection is not
+recommended, since the client and the server won't have initialized
+their session yet.
+
+2.4 Starting and stopping the proxy
+- - - - - - - - - - - - - - - - - -
+
+Once you've constructed a Proxy and added your delegates, you must
+start it with the Start method:
+
+	void Start()
+
+Once started, the proxy will begin listening for connections.  The
+Start method spawns new threads for the proxy and returns immediately.
+
+When your application is ready to shut down, you must call the Stop
+method:
+
+	void Stop()
+
+Note that this may not actually force the proxy to stop accepting
+connections; it merely guarantees that all foreground threads are
+stopped, allowing the application to exit cleanly.
+
+3. PacketUtility class
+----------------------
+
+The PacketUtility class provides a handful of static methods which may
+be useful when inspecting and modifying packets.
+
+3.1 Hashtable Unbuild(Packet packet)
+- - - - - - - - - - - - - - - - - -
+
+The Unbuild method takes a Packet object and returns a table of
+blocks, structured in a format suitable for passing to PacketUtility's
+GetField and SetField methods or PacketBuilder's BuildPacket method.
+
+For example, this should make an approximate copy of a packet:
+
+Hashtable packetBlocks = PacketUtility.Unbuild(packet);
+Packet packetCopy = PacketBuilder.BuildPacket(packet.Layout.Name, protocolManager, packetBlocks, packet.Data[0]);
+
+3.2 object GetField(Hashtable blocks, string block, string field)
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+The GetField method takes a table of blocks (produced by
+PacketUtility.Unbuild) and extracts the value of a particular field.
+If the field is part of a variable block, an arbitrary instance of the
+field will be returned.  If the field does not exist, null will be
+returned.
+
+3.3 void SetField(Hashtable blocks, string block, string field, object value)
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+The SetField method takes a table of blocks (produced by
+PacketUtility.Unbuild) and sets the value of a particular field.  If
+the field is part of a variable block, all instances of the field will
+be set.  If the field does not exist, SetField will have no effect.
+
+This can be used by a packet delegate method in conjunction with
+PacketUtility.Unbuild and PacketBuilder.BuildPacket to substitute a
+new packet that is a copy of the original packet with certain fields
+modified.

Modified: trunk/SLProxy/SLProxy.cs
===================================================================
--- trunk/SLProxy/SLProxy.cs	2006-12-17 02:45:06 UTC (rev 733)
+++ trunk/SLProxy/SLProxy.cs	2006-12-17 20:25:16 UTC (rev 734)
@@ -2,6 +2,8 @@
  * SLProxy.cs: implementation of Second Life proxy library
  *
  * Copyright (c) 2006 Austin Jennings
+ * Pregen modifications made by Andrew Ortman on Dec 10, 2006
+ * 
  * All rights reserved.
  *
  * - Redistribution and use in source and binary forms, with or without 
@@ -31,6 +33,7 @@
 using Nwc.XmlRpc;
 using System;
 using System.Collections;
+using System.Collections.Generic;
 using System.IO;
 using System.Net;
 using System.Net.Sockets;
@@ -39,7 +42,9 @@
 using System.Threading;
 using System.Xml;
 using libsecondlife;
+using libsecondlife.Packets;
 
+
 // SLProxy: proxy library for Second Life
 namespace SLProxy {
 	// ProxyConfig: configuration for proxy objects
@@ -49,7 +54,8 @@
 		// author: email address of the proxy application's author
 		public string author;
 		// protocol: libsecondlife ProtocolManager
-		public ProtocolManager protocol;
+		//public ProtocolManager protocol;
+        public SecondLife client;
 		// loginPort: port that the login proxy will listen on
 		public ushort loginPort = 8080;
 		// clientFacingAddress: address from which to communicate with the client
@@ -62,14 +68,14 @@
 		public bool verbose = true;
 
 		// ProxyConfig: construct a default proxy configuration with the specified userAgent, author, and protocol
-		public ProxyConfig(string userAgent, string author, ProtocolManager protocol) {
+		public ProxyConfig(string userAgent, string author, SecondLife slclient) {
 			this.userAgent = userAgent;
 			this.author = author;
-			this.protocol = protocol;
+            this.client = slclient;
 		}
 
 		// ProxyConfig: construct a default proxy configuration, parsing command line arguments (try --proxy-help)
-		public ProxyConfig(string userAgent, string author, ProtocolManager protocol, string[] args) : this(userAgent, author, protocol) {
+		public ProxyConfig(string userAgent, string author, SecondLife slclient, string[] args) : this(userAgent, author, slclient) {
 			Hashtable argumentParsers = new Hashtable();
 			argumentParsers[&quot;proxy-help&quot;] = new ArgumentParser(ParseHelp);
 			argumentParsers[&quot;proxy-login-port&quot;] = new ArgumentParser(ParseLoginPort);
@@ -326,7 +332,7 @@
 			request.Params.Add(requestParams);
 
 			// forward the XML-RPC request to the server
-			XmlRpcResponse response = (XmlRpcResponse)request.Send(proxyConfig.remoteLoginUri.ToString());
+			XmlRpcResponse response = (XmlRpcResponse)request.Send(proxyConfig.remoteLoginUri.ToString(),60000); //added 60 second timeout -- Andrew
 			Hashtable responseData = (Hashtable)response.Value;
 
 			// proxy any simulator address given in the XML-RPC response
@@ -415,76 +421,72 @@
 
 				// interpret the packet according to the SL protocol
 				Packet packet;
-				if ((receiveBuffer[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(receiveBuffer), false);
-				else {
-					Helpers.ZeroDecodeCommand(receiveBuffer, zeroBuffer);
-					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(zeroBuffer), false);
-					needsZero = true;
-				}
+                int end = receiveBuffer.Length - 1;
+
+                packet = Packet.BuildPacket(receiveBuffer, ref end, zeroBuffer);
 #if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;&lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
+				Console.WriteLine(&quot;&lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Header.Sequence);
 #endif
 
 				// check for ACKs we're waiting for
 				packet = simProxy.CheckAcks(packet, Direction.Incoming, ref length, ref needsCopy);
 
 				// modify sequence numbers to account for injections
-				uint oldSequence = packet.Sequence;
+				ushort oldSequence = packet.Header.Sequence;
 				packet = simProxy.ModifySequence(packet, Direction.Incoming, ref length, ref needsCopy);
 
 				// keep track of sequence numbers
-				if (packet.Sequence &gt; simProxy.incomingSequence)
-					simProxy.incomingSequence = packet.Sequence;
+				if (packet.Header.Sequence &gt; simProxy.incomingSequence)
+					simProxy.incomingSequence = packet.Header.Sequence;
 
 				// check the packet for addresses that need proxying
-				if (incomingCheckers.Contains(packet.Layout.Name)) {
+				if (incomingCheckers.Contains(packet.Type)) {
 					if (needsZero) {
-						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
-						packet.Data = zeroBuffer;
+						length = Helpers.ZeroDecode(packet.Header.Data, length, zeroBuffer);
+						packet.Header.Data = zeroBuffer;
 						needsZero = false;
 					}
 
-					Packet newPacket = ((AddressChecker)incomingCheckers[packet.Layout.Name])(packet);
+					Packet newPacket = ((AddressChecker)incomingCheckers[packet.Type])(packet);
 					SwapPacket(packet, newPacket, length);
 					packet = newPacket;
-					length = packet.Data.Length;
+					length = packet.Header.Data.Length;
 					needsCopy = false;
 				}
 
 				// pass the packet to any callback delegates
-				if (incomingDelegates.Contains(packet.Layout.Name)) {
+				if (incomingDelegates.Contains(packet.Type)) {
 					if (needsZero) {
-						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
-						packet.Data = zeroBuffer;
+						length = Helpers.ZeroDecode(packet.Header.Data, length, zeroBuffer);
+						packet.Header.Data = zeroBuffer;
 						needsCopy = true;
 					}
 
 					if (needsCopy) {
 						byte[] newData = new byte[length];
-						Array.Copy(packet.Data, 0, newData, 0, length);
-						packet.Data = newData;
+						Array.Copy(packet.Header.Data, 0, newData, 0, length);
+						packet.Header.Data = newData;
 					}
 
 					try {
-						Packet newPacket = ((PacketDelegate)incomingDelegates[packet.Layout.Name])(packet, (IPEndPoint)remoteEndPoint);
+						Packet newPacket = ((PacketDelegate)incomingDelegates[packet.Type])(packet, (IPEndPoint)remoteEndPoint);
 						if (newPacket == null) {
-							if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
+							if ((packet.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
 								simProxy.Inject(SpoofAck(oldSequence), Direction.Outgoing);
 
-							if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
+							if ((packet.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
 								packet = SeparateAck(packet);
 							else
 								packet = null;
 						} else {
-							bool oldReliable = (packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
-							bool newReliable = (newPacket.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							bool oldReliable = (packet.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							bool newReliable = (newPacket.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
 							if (oldReliable &amp;&amp; !newReliable)
 								simProxy.Inject(SpoofAck(oldSequence), Direction.Outgoing);
 							else if (!oldReliable &amp;&amp; newReliable)
 								simProxy.WaitForAck(packet, Direction.Incoming);
 
-							SwapPacket(packet, newPacket, packet.Data.Length);
+							SwapPacket(packet, newPacket, packet.Header.Data.Length);
 							packet = newPacket;
 						}
 					} catch (Exception e) {
@@ -493,7 +495,7 @@
 					}
 
 					if (packet != null)
-						simProxy.SendPacket(packet, packet.Data.Length, false);
+						simProxy.SendPacket(packet, packet.Header.Data.Length, false);
 				} else
 					simProxy.SendPacket(packet, length, needsZero);
 			} else
@@ -509,67 +511,72 @@
 
 		// SendPacket: send a packet to a sim from our fake client endpoint
 		public void SendPacket(Packet packet, IPEndPoint endPoint, int length, bool skipZero) {
-			if (skipZero || (packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-				simFacingSocket.SendTo(packet.Data, length, SocketFlags.None, endPoint);
+			if (skipZero || (packet.Header.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+				simFacingSocket.SendTo(packet.Header.Data, length, SocketFlags.None, endPoint);
 			else {
-				int zeroLength = Helpers.ZeroEncode(packet.Data, length, zeroBuffer);
+				int zeroLength = Helpers.ZeroEncode(packet.Header.Data, length, zeroBuffer);
 				simFacingSocket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, endPoint);
 			}
 		}
 
 		// SpoofAck: create an ACK for the given packet
-		public Packet SpoofAck(uint sequence) {
-			Hashtable blocks = new Hashtable();
-			Hashtable fields = new Hashtable();
-			fields[&quot;ID&quot;] = (uint)sequence;
-			blocks[fields] = &quot;Packets&quot;;
-			return PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, Helpers.MSG_ZEROCODED);
+		public Packet SpoofAck(ushort sequence) {
+            PacketAckPacket spoof = new PacketAckPacket();
+            spoof.Packets = new PacketAckPacket.PacketsBlock[1];
+            spoof.Packets[0].ID = sequence;
+            return (Packet)spoof;
+            //Legacy:
+            ////Hashtable blocks = new Hashtable();
+            ////Hashtable fields = new Hashtable();
+            ////fields[&quot;ID&quot;] = (uint)sequence;
+            ////blocks[fields] = &quot;Packets&quot;;
+            ////return .BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, Helpers.MSG_ZEROCODED);
 		}
 
 		// SeparateAck: create a standalone PacketAck for packet's appended ACKs
 		public Packet SeparateAck(Packet packet) {
-			int ackCount = ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)packet.Data[packet.Data.Length - 1]);
-			Hashtable blocks = new Hashtable();
-			for (int i = 0; i &lt; ackCount; ++i) {
-				Hashtable fields = new Hashtable();
-				int offset = packet.Data.Length - (ackCount - i) * 4 - 1;
-				fields[&quot;ID&quot;] = (uint)
-					  (packet.Data[offset++] &lt;&lt;  0)
-					+ (packet.Data[offset++] &lt;&lt;  8)
-					+ (packet.Data[offset++] &lt;&lt; 16)
-					+ (packet.Data[offset++] &lt;&lt; 24)
-					;
-				blocks[fields] = &quot;Packets&quot;;
-			}
+            PacketAckPacket seperate = new PacketAckPacket();
+            int ackCount = ((packet.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)packet.Header.Data[packet.Header.Data.Length - 1]);
+            seperate.Packets = new PacketAckPacket.PacketsBlock[ackCount];	
+		
+            for (int i = 0; i &lt; ackCount; ++i)
+            {
+            	int offset = packet.Header.Data.Length - (ackCount - i) * 4 - 1;
+                seperate.Packets[i].ID = (uint) ((packet.Header.Data[offset++] &lt;&lt;  0)
+				                                + (packet.Header.Data[offset++] &lt;&lt;  8)
+				                                + (packet.Header.Data[offset++] &lt;&lt; 16)
+				                                + (packet.Header.Data[offset++] &lt;&lt; 24))
+				                                ;
+            }
 
-			Packet ack = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, Helpers.MSG_ZEROCODED);
-			ack.Sequence = packet.Sequence;
-			return ack;
+            Packet ack = (Packet)seperate;
+            ack.Header.Sequence = packet.Header.Sequence;
+            return ack;
 		}
 
 		// SwapPacket: copy the sequence number and appended ACKs from one packet to another
 		public static void SwapPacket(Packet oldPacket, Packet newPacket, int oldLength) {
-			newPacket.Sequence = oldPacket.Sequence;
+			newPacket.Header.Sequence = oldPacket.Header.Sequence;
 
-			int oldAcks = (oldPacket.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)oldPacket.Data[oldLength - 1];
-			int newAcks = (newPacket.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)newPacket.Data[newPacket.Data.Length - 1];
+			int oldAcks = (oldPacket.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)oldPacket.Header.Data[oldLength - 1];
+			int newAcks = (newPacket.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)newPacket.Header.Data[newPacket.Header.Data.Length - 1];
 
 			if (oldAcks != 0 || newAcks != 0) {
 				int oldAckSize = oldAcks == 0 ? 0 : oldAcks * 4 + 1;
 				int newAckSize = newAcks == 0 ? 0 : newAcks * 4 + 1;
 
-				byte[] newData = new byte[newPacket.Data.Length - newAckSize + oldAckSize];
-				Array.Copy(newPacket.Data, 0, newData, 0, newPacket.Data.Length - newAckSize);
+                byte[] newData = new byte[newPacket.Header.Data.Length - newAckSize + oldAckSize];
+                Array.Copy(newPacket.Header.Data, 0, newData, 0, newPacket.Header.Data.Length - newAckSize);
 
 				if (newAcks != 0)
 					newData[0] ^= Helpers.MSG_APPENDED_ACKS;
 
 				if (oldAcks != 0) {
 					newData[0] |= Helpers.MSG_APPENDED_ACKS;
-					Array.Copy(oldPacket.Data, oldLength - oldAckSize, newData, newPacket.Data.Length - newAckSize, oldAckSize);
+					Array.Copy(oldPacket.Header.Data, oldLength - oldAckSize, newData, newPacket.Header.Data.Length - newAckSize, oldAckSize);
 				}
 
-				newPacket.Data = newData;
+                newPacket.Header.Data = newData;
 			}
 		}
 
@@ -601,12 +608,12 @@
 			private IPEndPoint remoteEndPoint;
 			private Proxy proxy;
 			private Socket socket;
-			public uint incomingSequence;
-			public uint outgoingSequence;
+			public ushort incomingSequence;
+			public ushort outgoingSequence;
 			private ArrayList incomingInjections;
 			private ArrayList outgoingInjections;
-			private uint incomingOffset = 0;
-			private uint outgoingOffset = 0;
+			private ushort incomingOffset = 0;
+			private ushort outgoingOffset = 0;
 			private Hashtable incomingAcks;
 			private Hashtable outgoingAcks;
 			private ArrayList incomingSeenAcks;
@@ -682,24 +689,24 @@
 						outgoingSeenAcksPoint = outgoingSeenAcks.Count;
 					}
 
-					foreach (uint id in incomingAcks.Keys)
+					foreach (ushort id in incomingAcks.Keys)
 						if (!incomingSeenAcks.Contains(id)) {
 							Packet packet = (Packet)incomingAcks[id];
-							packet.Data[0] |= Helpers.MSG_RESENT;
+							packet.Header.Data[0] |= Helpers.MSG_RESENT;
 #if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;RESEND &lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
+							Console.WriteLine(&quot;RESEND &lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Header.Sequence);
 #endif
-							SendPacket(packet, packet.Data.Length, false);
+							SendPacket(packet, packet.Header.Data.Length, false);
 						}
 
-					foreach (uint id in outgoingAcks.Keys)
+					foreach (ushort id in outgoingAcks.Keys)
 						if (!outgoingSeenAcks.Contains(id)) {
 							Packet packet = (Packet)outgoingAcks[id];
-							packet.Data[0] |= Helpers.MSG_RESENT;
+							packet.Header.Data[0] |= Helpers.MSG_RESENT;
 #if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;RESEND -&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
+							Console.WriteLine(&quot;RESEND -&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Header.Sequence);
 #endif
-							proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
+							proxy.SendPacket(packet, remoteEndPoint, packet.Header.Data.Length, false);
 						}
 				}
 			} catch (Exception e) {
@@ -734,77 +741,71 @@
 				length = socket.EndReceiveFrom(ar, ref clientEndPoint);
 
 				// interpret the packet according to the SL protocol
-				Packet packet;
-				if ((receiveBuffer[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(receiveBuffer), false);
-				else {
-					Helpers.ZeroDecodeCommand(receiveBuffer, zeroBuffer);
-					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(zeroBuffer), false);
-					needsZero = true;
-				}
+                int end = receiveBuffer.Length - 1;
+				Packet packet = libsecondlife.Packets.Packet.BuildPacket(receiveBuffer,ref end, zeroBuffer);
+				
 #if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;-&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
+				Console.WriteLine(&quot;-&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Header.Sequence);
 #endif
-
-				// check for ACKs we're waiting for
+                // check for ACKs we're waiting for
 				packet = CheckAcks(packet, Direction.Outgoing, ref length, ref needsCopy);
 
 				// modify sequence numbers to account for injections
-				uint oldSequence = packet.Sequence;
+				ushort oldSequence = packet.Header.Sequence;
 				packet = ModifySequence(packet, Direction.Outgoing, ref length, ref needsCopy);
 
 				// keep track of sequence numbers
-				if (packet.Sequence &gt; outgoingSequence)
-					outgoingSequence = packet.Sequence;
+				if (packet.Header.Sequence &gt; outgoingSequence)
+                    outgoingSequence = packet.Header.Sequence ;
 
 				// check the packet for addresses that need proxying
-				if (proxy.outgoingCheckers.Contains(packet.Layout.Name)) {
-					if (needsZero) {
-						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
-						packet.Data = zeroBuffer;
+				if (proxy.outgoingCheckers.Contains(packet.Type)) {
+					if (packet.Header.Zerocoded) {
+						length = Helpers.ZeroDecode(packet.Header.Data, length, zeroBuffer);
+						packet.Header.Data = zeroBuffer;
 						needsZero = false;
 					}
 
-					Packet newPacket = ((AddressChecker)proxy.outgoingCheckers[packet.Layout.Name])(packet);
+					Packet newPacket = ((AddressChecker)proxy.outgoingCheckers[packet.Type])(packet);
 					SwapPacket(packet, newPacket, length);
 					packet = newPacket;
-					length = packet.Data.Length;
+					length = packet.Header.Data.Length;
 					needsCopy = false;
 				}
 
 				// pass the packet to any callback delegates
-				if (proxy.outgoingDelegates.Contains(packet.Layout.Name)) {
-					if (needsZero) {
-						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
-						packet.Data = zeroBuffer;
+				if (proxy.outgoingDelegates.Contains(packet.Type)) {
+					if (packet.Header.Zerocoded) {
+						length = Helpers.ZeroDecode(packet.Header.Data, length, zeroBuffer);
+						packet.Header.Data = zeroBuffer;
 						needsCopy = true;
 					}
 
 					if (needsCopy) {
 						byte[] newData = new byte[length];
-						Array.Copy(packet.Data, 0, newData, 0, length);
-						packet.Data = newData;
+						Array.Copy(packet.Header.Data, 0, newData, 0, length);
+						packet.Header.Data = newData;
 					}
 
 					try {
-						Packet newPacket = ((PacketDelegate)proxy.outgoingDelegates[packet.Layout.Name])(packet, remoteEndPoint);
+						Packet newPacket = ((PacketDelegate)proxy.outgoingDelegates[packet.Type])(packet, remoteEndPoint);
 						if (newPacket == null) {
-							if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
+							if ((packet.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
 								Inject(proxy.SpoofAck(oldSequence), Direction.Incoming);
 
-							if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
+							if ((packet.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
 								packet = proxy.SeparateAck(packet);
 							else
 								packet = null;
 						} else {
-							bool oldReliable = (packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
-							bool newReliable = (newPacket.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							bool oldReliable = (packet.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							bool newReliable = (newPacket.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
 							if (oldReliable &amp;&amp; !newReliable)
 								Inject(proxy.SpoofAck(oldSequence), Direction.Incoming);
 							else if (!oldReliable &amp;&amp; newReliable)	
 								WaitForAck(packet, Direction.Outgoing);
 
-							SwapPacket(packet, newPacket, packet.Data.Length);
+							SwapPacket(packet, newPacket, packet.Header.Data.Length);
 							packet = newPacket;
 						}
 					} catch (Exception e) {
@@ -813,7 +814,7 @@
 					}
 
 					if (packet != null)
-						proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
+						proxy.SendPacket(packet, remoteEndPoint, packet.Header.Data.Length, false);
 				} else
 					proxy.SendPacket(packet, remoteEndPoint, length, needsZero);
 
@@ -834,10 +835,10 @@
 
 			// SendPacket: send a packet from the sim to the client via our fake sim endpoint
 			public void SendPacket(Packet packet, int length, bool skipZero) {
-				if (skipZero || (packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-					socket.SendTo(packet.Data, length, SocketFlags.None, clientEndPoint);
+				if (skipZero || (packet.Header.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+					socket.SendTo(packet.Header.Data, length, SocketFlags.None, clientEndPoint);
 				else {
-					int zeroLength = Helpers.ZeroEncode(packet.Data, length, zeroBuffer);
+					int zeroLength = Helpers.ZeroEncode(packet.Header.Data, length, zeroBuffer);
 					socket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, clientEndPoint);
 				}
 			}
@@ -851,34 +852,34 @@
 					}
 
 					incomingInjections.Add(++incomingSequence);
-					packet.Sequence = incomingSequence;
+					packet.Header.Sequence = incomingSequence;
 				} else {
 					outgoingInjections.Add(++outgoingSequence);
-					packet.Sequence = outgoingSequence;
+					packet.Header.Sequence = outgoingSequence;
 				}
 
 #if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;INJECT &quot; + (direction == Direction.Incoming ? &quot;&lt;-&quot; : &quot;-&gt;&quot;) + &quot; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
+				Console.WriteLine(&quot;INJECT &quot; + (direction == Direction.Incoming ? &quot;&lt;-&quot; : &quot;-&gt;&quot;) + &quot; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Header.Sequence);
 
 #endif
-				if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
+				if ((packet.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
 					WaitForAck(packet, direction);
 
 				if (direction == Direction.Incoming)
-					if ((packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-						socket.SendTo(packet.Data, packet.Data.Length, SocketFlags.None, clientEndPoint);
+					if ((packet.Header.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+						socket.SendTo(packet.Header.Data, packet.Header.Data.Length, SocketFlags.None, clientEndPoint);
 					else {
-						int zeroLength = Helpers.ZeroEncode(packet.Data, packet.Data.Length, zeroBuffer);
+						int zeroLength = Helpers.ZeroEncode(packet.Header.Data, packet.Header.Data.Length, zeroBuffer);
 						socket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, clientEndPoint);
 					}
 				else
-					proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
+					proxy.SendPacket(packet, remoteEndPoint, packet.Header.Data.Length, false);
 			}
 
 			// WaitForAck: take care of resending a packet until it's ACKed
 			public void WaitForAck(Packet packet, Direction direction) {
 				Hashtable table = direction == Direction.Incoming ? incomingAcks : outgoingAcks;
-				table.Add(packet.Sequence, packet);
+				table.Add(packet.Header.Sequence, packet);
 			}
 
 			// CheckAcks: check for and remove ACKs of packets we've injected
@@ -890,42 +891,52 @@
 					return packet;
 
 				// check for embedded ACKs
-				if (packet.Layout.Name == &quot;PacketAck&quot;) {
+				if (packet.Type == PacketType.PacketAck) {
 					bool changed = false;
-					Hashtable blocks = PacketUtility.Unbuild(packet);
-					Hashtable newBlocks = new Hashtable();
-					foreach (Hashtable fields in blocks.Keys) {
-						uint id = ((uint)fields[&quot;ID&quot;]);
+                    List&lt;PacketAckPacket.PacketsBlock&gt; newPacketBlocks = new List&lt;PacketAckPacket.PacketsBlock&gt;();
+					foreach (PacketAckPacket.PacketsBlock pb in ((PacketAckPacket)packet).Packets) {
+						ushort id = (ushort)pb.ID;
 #if DEBUG_SEQUENCE
 						string hrup = &quot;Check !&quot; + id;
 #endif
-						if (acks.Contains(id)) {
+                        if (acks.Contains(id))
+                        {
 #if DEBUG_SEQUENCE
 							hrup += &quot; get's&quot;;
 #endif
-							seenAcks.Add(id);
-							changed = true;
-						} else
-							newBlocks.Add(fields, blocks[fields]);
+                            seenAcks.Add(id);
+                            changed = true;
+                        }
+                        else
+                            newPacketBlocks.Add(pb);
 #if DEBUG_SEQUENCE
 						Console.WriteLine(hrup);
 #endif
 					}
-					if (changed) {
-						Packet newPacket = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, newBlocks, packet.Data[0]);
-						SwapPacket(packet, newPacket, length);
+					if (changed)
+                    {
+                        PacketAckPacket newPacket = new PacketAckPacket();
+                        newPacket.Packets = new PacketAckPacket.PacketsBlock[newPacketBlocks.Count];
+                        
+                        int a = 0;
+                        foreach (PacketAckPacket.PacketsBlock pb in newPacketBlocks)
+                        {
+                            newPacket.Packets[a++] = pb;
+                        } 
+
+                        SwapPacket(packet, (Packet)newPacket, length);
 						packet = newPacket;
-						length = packet.Data.Length;
+						length = packet.Header.Data.Length;
 						needsCopy = false;
 					}
 				}
 
 				// check for appended ACKs
-				if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
-					byte ackCount = packet.Data[length - 1];
+				if ((packet.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
+					byte ackCount = packet.Header.Data[length - 1];
 					for (int i = 0; i &lt; ackCount;) {
 						int offset = length - (ackCount - i) * 4 - 1;
-						uint ackID = (uint)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8) + (packet.Data[offset + 1] &lt;&lt; 16));
+						ushort ackID = (ushort)(packet.Header.Data[offset + 3] + (packet.Header.Data[offset + 2] &lt;&lt; 8));
 #if DEBUG_SEQUENCE
 						string hrup = &quot;Check @&quot; + ackID;
 #endif
@@ -934,10 +945,10 @@
 							hrup += &quot; get's&quot;;
 #endif
 							byte[] newData = new byte[length -= 4];
-							Array.Copy(packet.Data, 0, newData, 0, offset);
-							Array.Copy(packet.Data, offset + 4, newData, offset, length - offset - 4);
+							Array.Copy(packet.Header.Data, 0, newData, 0, offset);
+							Array.Copy(packet.Header.Data, offset + 4, newData, offset, length - offset - 4);
 							--newData[newData.Length - 1];
-							packet.Data = newData;
+							packet.Header.Data = newData;
 							--ackCount;
 							seenAcks.Add(ackID);
 							needsCopy = false;
@@ -949,9 +960,9 @@
 					}
 					if (ackCount == 0) {
 						byte[] newData = new byte[length -= 1];
-						Array.Copy(packet.Data, 0, newData, 0, length);
+						Array.Copy(packet.Header.Data, 0, newData, 0, length);
 						newData[0] ^= Helpers.MSG_APPENDED_ACKS;
-						packet.Data = newData;
+						packet.Header.Data = newData;
 					}
 				}
 
@@ -962,59 +973,56 @@
 			public Packet ModifySequence(Packet packet, Direction direction, ref int length, ref bool needsCopy) {
 				ArrayList ourInjections = direction == Direction.Outgoing ? outgoingInjections : incomingInjections;
 				ArrayList theirInjections = direction == Direction.Incoming ? outgoingInjections : incomingInjections;
-				uint ourOffset = direction == Direction.Outgoing ? outgoingOffset : incomingOffset;
-				uint theirOffset = direction == Direction.Incoming ? outgoingOffset : incomingOffset;
+				ushort ourOffset = direction == Direction.Outgoing ? outgoingOffset : incomingOffset;
+				ushort theirOffset = direction == Direction.Incoming ? outgoingOffset : incomingOffset;
 
-				uint newSequence = (packet.Sequence + ourOffset);
-				foreach (uint injection in ourInjections)
+				ushort newSequence = (ushort)(packet.Header.Sequence + ourOffset);
+				foreach (ushort injection in ourInjections)
 					if (newSequence &gt;= injection)
 						++newSequence;
 #if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;Mod #&quot; + packet.Sequence + &quot; = &quot; + newSequence);
+				Console.WriteLine(&quot;Mod #&quot; + packet.Header.Sequence + &quot; = &quot; + newSequence);
 #endif
-				packet.Sequence = newSequence;
+				packet.Header.Sequence = newSequence;
 
-				if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
-					int ackCount = packet.Data[length - 1];
+				if ((packet.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
+					int ackCount = packet.Header.Data[length - 1];
 					for (int i = 0; i &lt; ackCount; ++i) {
 						int offset = length - (ackCount - i) * 4 - 1;
-						uint ackID = (uint)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8) + (packet.Data[offset + 1] &lt;&lt; 16)) - theirOffset;
+						uint ackID = (uint)(packet.Header.Data[offset + 3] + (packet.Header.Data[offset + 2] &lt;&lt; 8)) - theirOffset;
 #if DEBUG_SEQUENCE
-						uint hrup = (uint)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8) + (packet.Data[offset + 1] &lt;&lt; 16));
+						uint hrup = (uint)(packet.Header.Data[offset + 3] + (packet.Header.Data[offset + 2] &lt;&lt; 8));
 #endif
 						for (int j = theirInjections.Count - 1; j &gt;= 0; --j)
-							if (ackID &gt;= (uint)theirInjections[j])
+							if (ackID &gt;= (ushort)theirInjections[j])
 								--ackID;
 #if DEBUG_SEQUENCE
 						Console.WriteLine(&quot;Mod @&quot; + hrup + &quot; = &quot; + ackID);
 #endif
-						packet.Data[offset + 3] = (byte)(ackID % 256);
-						packet.Data[offset + 2] = (byte)((ackID / 256) % 256);
-						packet.Data[offset + 1] = (byte)(ackID / 65536);
+						packet.Header.Data[offset + 3] = (byte)(ackID % 256);
+						packet.Header.Data[offset + 2] = (byte)(ackID / 256);
 					}
 				}
 
-				if (packet.Layout.Name == &quot;PacketAck&quot;) {
-					Hashtable blocks = PacketUtility.Unbuild(packet);
-					foreach (Hashtable fields in blocks.Keys) {
-						if ((string)blocks[fields] == &quot;Packets&quot;) {
-							uint ackID = (uint)fields[&quot;ID&quot;] - theirOffset;
+				if (packet.Type == PacketType.PacketAck) {
+                    PacketAckPacket pap = new PacketAckPacket();
+                    foreach(PacketAckPacket.PacketsBlock pb in pap.Packets) {
+                    	uint ackID = (uint)pb.ID - theirOffset;
 #if DEBUG_SEQUENCE
-							uint hrup = (uint)fields[&quot;ID&quot;];
+						uint hrup = (uint)fields[&quot;ID&quot;];
 #endif
-							for (int i = theirInjections.Count - 1; i &gt;= 0; --i)
-								if (ackID &gt;= (uint)theirInjections[i])
-									--ackID;
+						for (int i = theirInjections.Count - 1; i &gt;= 0; --i)
+							if (ackID &gt;= (ushort)theirInjections[i])
+								--ackID;
 #if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;Mod !&quot; + hrup + &quot; = &quot; + ackID);
+						Console.WriteLine(&quot;Mod !&quot; + hrup + &quot; = &quot; + ackID);
 #endif
-							fields[&quot;ID&quot;] = ackID;
-						}
+						pb.ID = ackID;
+					
 					}
-					Packet newPacket = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, packet.Data[0]);
-					SwapPacket(packet, newPacket, length);
-					packet = newPacket;
-					length = packet.Data.Length;
+                    SwapPacket(packet, (Packet)pap, length);
+					packet = (Packet)pap;
+					length = packet.Header.Data.Length;
 					needsCopy = false;
 				}
 
@@ -1036,69 +1044,72 @@
 		// InitializeAddressCheckers: initialize delegates that check packets for addresses that need proxying
 		private void InitializeAddressCheckers() {
 			// TODO: what do we do with mysteries and empty IPs?
-			AddMystery(&quot;OpenCircuit&quot;);
-			AddMystery(&quot;AgentPresenceResponse&quot;);
-			incomingCheckers.Add(&quot;TeleportFinish&quot;, new AddressChecker(CheckTeleportFinish));
+			AddMystery(PacketType.OpenCircuit);
+			AddMystery(PacketType.AgentPresenceResponse);
+			incomingCheckers.Add(PacketType.TeleportFinish, new AddressChecker(CheckTeleportFinish));
 			// ViewerStats: IP is 0.0.0.0
-			incomingCheckers.Add(&quot;AgentToNewRegion&quot;, new AddressChecker(CheckAgentToNewRegion));
-			incomingCheckers.Add(&quot;CrossedRegion&quot;, new AddressChecker(CheckCrossedRegion));
-			incomingCheckers.Add(&quot;EnableSimulator&quot;, new AddressChecker(CheckEnableSimulator));
+			incomingCheckers.Add(PacketType.AgentToNewRegion, new AddressChecker(CheckAgentToNewRegion));
+			incomingCheckers.Add(PacketType.CrossedRegion, new AddressChecker(CheckCrossedRegion));
+			incomingCheckers.Add(PacketType.EnableSimulator, new AddressChecker(CheckEnableSimulator));
 			// KickUser: IP is 0.0.0.0
-			incomingCheckers.Add(&quot;UserLoginLocationReply&quot;, new AddressChecker(CheckUserLoginLocationReply));
+			//incomingCheckers.Add(&quot;UserLoginLocationReply&quot;, new AddressChecker(CheckUserLoginLocationReply));
 		}
 
 		// AddMystery: add a checker delegate that logs packets we're watching for development purposes
-		private void AddMystery(String name) {
-			incomingCheckers.Add(name, new AddressChecker(LogIncomingMysteryPacket));
-			outgoingCheckers.Add(name, new AddressChecker(LogOutgoingMysteryPacket));
+		private void AddMystery(PacketType type) {
+			incomingCheckers.Add(type, new AddressChecker(LogIncomingMysteryPacket));
+			outgoingCheckers.Add(type, new AddressChecker(LogOutgoingMysteryPacket));
 		}
 
 		// GenericCheck: replace the sim address in a packet with our proxy address
-		private Packet GenericCheck(Packet packet, string block, string fieldIP, string fieldPort, bool active) {
-			Hashtable blocks = PacketUtility.Unbuild(packet);
+		private void GenericCheck(ref uint simIP, ref ushort simPort, bool active) {
+            IPAddress sim_ip = new IPAddress((long)simIP);
 
-			IPEndPoint realSim = new IPEndPoint((IPAddress)PacketUtility.GetField(blocks, block, fieldIP), Convert.ToInt32(PacketUtility.GetField(blocks, block, fieldPort)));
+            IPEndPoint realSim = new IPEndPoint(sim_ip, Convert.ToInt32(simPort));
 			IPEndPoint fakeSim = ProxySim(realSim);
-			PacketUtility.SetField(blocks, block, fieldIP, fakeSim.Address);
-			PacketUtility.SetField(blocks, block, fieldPort, (ushort)fakeSim.Port);
 
-			if (active)
-				activeCircuit = realSim;
-
-			return PacketBuilder.BuildPacket(packet.Layout.Name, proxyConfig.protocol, blocks, packet.Data[0]);
+            simPort = (ushort)fakeSim.Port;
+            int i = 0;
+            byte[] bytes = fakeSim.Address.GetAddressBytes();
+            simIP = (uint)(bytes[i++] + (bytes[i++] &lt;&lt; 8) + (bytes[i++] &lt;&lt; 16) + (bytes[i++] &lt;&lt; 24));
+            
+            if (active)
+                activeCircuit = realSim;
 		}
 
 		// CheckTeleportFinish: check TeleportFinish packets
 		private Packet CheckTeleportFinish(Packet packet) {
-			return GenericCheck(packet, &quot;Info&quot;, &quot;SimIP&quot;, &quot;SimPort&quot;, true);
+            TeleportFinishPacket tfp = (TeleportFinishPacket)packet;
+            GenericCheck(ref tfp.Info.SimIP, ref tfp.Info.SimPort, true);
+            return (Packet)tfp;
 		}
 
 		// CheckAgentToNewRegion: check AgentToNewRegion packets
 		private Packet CheckAgentToNewRegion(Packet packet) {
-			return GenericCheck(packet, &quot;RegionData&quot;, &quot;IP&quot;, &quot;Port&quot;, true);
+            AgentToNewRegionPacket atnwp = (AgentToNewRegionPacket)packet;
+            GenericCheck(ref atnwp.RegionData.IP, ref atnwp.RegionData.Port, true);
+            return (Packet)atnwp;
 		}
 
 		// CheckEnableSimulator: check EnableSimulator packets
 		private Packet CheckEnableSimulator(Packet packet) {
-			return GenericCheck(packet, &quot;SimulatorInfo&quot;, &quot;IP&quot;, &quot;Port&quot;, false);
+            EnableSimulatorPacket esp = (EnableSimulatorPacket)packet;
+            GenericCheck(ref esp.SimulatorInfo.IP, ref esp.SimulatorInfo.Port, false);
+            return (Packet)esp;
 		}
 
 		// CheckCrossedRegion: check CrossedRegion packets
 		private Packet CheckCrossedRegion(Packet packet) {
-			return GenericCheck(packet, &quot;RegionData&quot;, &quot;SimIP&quot;, &quot;SimPort&quot;, true);
+            CrossedRegionPacket crp = (CrossedRegionPacket)packet;
+            GenericCheck(ref crp.RegionData.SimIP, ref crp.RegionData.SimPort, true);
+            return (Packet)crp;
 		}
 
-		// CheckUserLoginLocationReply: check UserLoginLocationReply packets
-		private Packet CheckUserLoginLocationReply(Packet packet) {
-			return GenericCheck(packet, &quot;SimulatorBlock&quot;, &quot;IP&quot;, &quot;Port&quot;, true);
-		}
-
-		// LogPacket: log a packet dump
+        // LogPacket: log a packet dump
 		private Packet LogPacket(Packet packet, string type) {
 			Log(type + &quot; packet:&quot;, true);
 			Log(packet, true);
-
-			return PacketBuilder.BuildPacket(packet.Layout.Name, proxyConfig.protocol, PacketUtility.Unbuild(packet), packet.Data[0]);
+            return packet;
 		}
 
 		// LogIncomingMysteryPacket: log an incoming packet we're watching for development purposes
@@ -1126,40 +1137,4 @@
 		Incoming,
 		Outgoing
 	}
-
-	// PacketUtility: provides various utility methods for working with libsecondlife Packet objects
-	public class PacketUtility {
-		// Unbuild: deconstruct a packet into a Hashtable of blocks suitable for passing to PacketBuilder
-		public static Hashtable Unbuild(Packet packet) {
-			Hashtable blockTable = new Hashtable();
-			foreach (Block block in packet.Blocks()) {
-				Hashtable fieldTable = new Hashtable();
-				foreach (Field field in block.Fields)
-					fieldTable[field.Layout.Name] = field.Data;
-				blockTable[fieldTable] = block.Layout.Name;
-			}
-
-			return blockTable;
-		}
-
-		// GetField: given a table of blocks, return the value of the specified block and field
-		// In the case of packets with variable blocks, an arbitrary block will be used.
-		public static object GetField(Hashtable blocks, string block, string field) {
-			foreach (Hashtable fields in blocks.Keys)
-				if ((string)blocks[fields] == block)
-					if (fields.Contains(field))
-						return fields[field];
-
-			return null;
-		}
-
-		// SetField: given a table of blocks, update the value of the specified block and field
-		// In the case of packets with variable blocks, all blocks will be updated.
-		public static void SetField(Hashtable blocks, string block, string field, object value) {
-			foreach (Hashtable fields in blocks.Keys)
-				if ((string)blocks[fields] == block)
-					if (fields.Contains(field))
-						fields[field] = value;
-		}
-	}
 }

Modified: trunk/SLProxy/SLProxy.csproj
===================================================================
--- trunk/SLProxy/SLProxy.csproj	2006-12-17 02:45:06 UTC (rev 733)
+++ trunk/SLProxy/SLProxy.csproj	2006-12-17 20:25:16 UTC (rev 734)
@@ -85,26 +85,16 @@
     &lt;/Reference&gt;
   &lt;/ItemGroup&gt;
   &lt;ItemGroup&gt;
-    &lt;Compile Include=&quot;legacy\Logger.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\Packet.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\ProtocolManager.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\SecondLife.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\Types.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcDeserializer.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcErrorCodes.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcException.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcRequest.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcRequestDeserializer.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcRequestSerializer.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcResponse.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcResponseDeserializer.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcResponseSerializer.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcSerializer.cs&quot; /&gt;
-    &lt;Compile Include=&quot;legacy\XmlRpcXmlTokens.cs&quot; /&gt;
     &lt;Compile Include=&quot;SLProxy.cs&quot;&gt;
       &lt;SubType&gt;Code&lt;/SubType&gt;
     &lt;/Compile&gt;
   &lt;/ItemGroup&gt;
+  &lt;ItemGroup&gt;
+    &lt;ProjectReference Include=&quot;..\libsecondlife-cs\libsecondlife.csproj&quot;&gt;
+      &lt;Project&gt;{D9CDEDFB-8169-4B03-B57F-0DF638F044EC}&lt;/Project&gt;
+      &lt;Name&gt;libsecondlife&lt;/Name&gt;
+    &lt;/ProjectReference&gt;
+  &lt;/ItemGroup&gt;
   &lt;Import Project=&quot;$(MSBuildBinPath)\Microsoft.CSharp.targets&quot; /&gt;
   &lt;PropertyGroup&gt;
     &lt;PreBuildEvent&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000100.html">[Libsecondlife-commits] r733 - trunk
</A></li>
	<LI>Next message: <A HREF="000102.html">[Libsecondlife-commits] r735 - trunk/SLProxy
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#101">[ date ]</a>
              <a href="thread.html#101">[ thread ]</a>
              <a href="subject.html#101">[ subject ]</a>
              <a href="author.html#101">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">More information about the Libsecondlife-commits
mailing list</a><br>
</body></html>
