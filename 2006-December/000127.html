<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Libsecondlife-commits] r758 - trunk/SLProxy
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/libsecondlife-commits/2006-December/index.html" >
   <LINK REL="made" HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r758%20-%20trunk/SLProxy&In-Reply-To=%3C200612221644.kBMGiiT2027203%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000126.html">
   <LINK REL="Next"  HREF="000128.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Libsecondlife-commits] r758 - trunk/SLProxy</H1>
    <B>jhurliman at BerliOS</B> 
    <A HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r758%20-%20trunk/SLProxy&In-Reply-To=%3C200612221644.kBMGiiT2027203%40sheep.berlios.de%3E"
       TITLE="[Libsecondlife-commits] r758 - trunk/SLProxy">jhurliman at mail.berlios.de
       </A><BR>
    <I>Fri Dec 22 17:44:44 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000126.html">[Libsecondlife-commits] r757 - trunk/SLProxy
</A></li>
        <LI>Next message: <A HREF="000128.html">[Libsecondlife-commits] r759 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#127">[ date ]</a>
              <a href="thread.html#127">[ thread ]</a>
              <a href="subject.html#127">[ subject ]</a>
              <a href="author.html#127">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jhurliman
Date: 2006-12-22 17:44:43 +0100 (Fri, 22 Dec 2006)
New Revision: 758

Modified:
   trunk/SLProxy/Analyst.cs
Log:
Fixing a potential non-uniform line ending issue

Modified: trunk/SLProxy/Analyst.cs
===================================================================
--- trunk/SLProxy/Analyst.cs	2006-12-22 16:35:30 UTC (rev 757)
+++ trunk/SLProxy/Analyst.cs	2006-12-22 16:44:43 UTC (rev 758)
@@ -1,31 +1,32 @@
-/*
- * Analyst.cs: proxy that makes packet inspection and modifcation interactive
- *   See the README for usage instructions.
- *
- * Copyright (c) 2006 Austin Jennings
- * Modified by &quot;qode&quot; and &quot;mcortez&quot; on December 21st, 2006 to work with the new pregen 
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
+/*
+ * Analyst.cs: proxy that makes packet inspection and modifcation interactive
+ *   See the README for usage instructions.
+ *
+ * Copyright (c) 2006 Austin Jennings
+ * Modified by &quot;qode&quot; and &quot;mcortez&quot; on December 21st, 2006 to work with the new
+ * pregen
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the Second Life Reverse Engineering Team nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 using SLProxy;
@@ -230,17 +231,17 @@
         }
     }
 
-    /*	// CmdGrep: handle a /grep command
-        private static void CmdGrep(string[] words) {
-            if (words.Length == 1) {
-                logGrep = null;
-                SayToUser(&quot;stopped filtering logs&quot;);
-            } else {
-                string[] regexArray = new string[words.Length - 1];
-                Array.Copy(words, 1, regexArray, 0, words.Length - 1);
-                logGrep = String.Join(&quot; &quot;, regexArray);
-                SayToUser(&quot;filtering log with &quot; + logGrep);
-            }
+    /*	// CmdGrep: handle a /grep command
+        private static void CmdGrep(string[] words) {
+            if (words.Length == 1) {
+                logGrep = null;
+                SayToUser(&quot;stopped filtering logs&quot;);
+            } else {
+                string[] regexArray = new string[words.Length - 1];
+                Array.Copy(words, 1, regexArray, 0, words.Length - 1);
+                logGrep = String.Join(&quot; &quot;, regexArray);
+                SayToUser(&quot;filtering log with &quot; + logGrep);
+            }
         } */
 
     // CmdSet: handle a /set command
@@ -544,10 +545,10 @@
     {
         Type packetClass = libslAssembly.GetType(&quot;libsecondlife.Packets.&quot; + name + &quot;Packet&quot;);
         if (packetClass == null) throw new Exception(&quot;Couldn't get class &quot; + name + &quot;Packet&quot;);
-        /*		try {
-                    packetMap = protocolManager.Command(name);
-                } catch {
-                    throw new Exception(&quot;unkown packet &quot; + name);
+        /*		try {
+                    packetMap = protocolManager.Command(name);
+                } catch {
+                    throw new Exception(&quot;unkown packet &quot; + name);
                 } */
 
 
@@ -689,34 +690,34 @@
         {
             throw new Exception(&quot;unable to interpret &quot; + value + &quot; as &quot; + fieldClass);
         }
-        /*				try {
-                            switch (fieldMap.Type) {
-                                case FieldType.LLVector3:
-                                case FieldType.IPADDR:
-                                    return IPAddress.Parse(value);
-                                case FieldType.IPPORT:
-                                    return Convert.ToUInt16(value);
-                                case FieldType.Variable:
-                                    Match match = Regex.Match(value, @&quot;^0x([0-9a-fA-F]{2})*&quot;, RegexOptions.IgnoreCase);
-                                    if (match.Success) {
-                                        byte[] buf = new byte[match.Groups[1].Captures.Count];
-                                        int i = 0;
-                                        foreach (Capture capture in match.Groups[1].Captures)
-                                            buf[i++] = Byte.Parse(capture.ToString(), NumberStyles.AllowHexSpecifier);
-                                        return buf;
-                                    } else
-                                        return value;
-                            }
-                        } catch {
-                            throw new Exception(&quot;unable to interpret &quot; + value + &quot; as &quot; + fieldMap.Type);
-                        }
-
-                        throw new Exception(&quot;unsupported field type &quot; + fieldMap.Type);
-                    }
-
-                    throw new Exception(&quot;unknown field &quot; + name + &quot;.&quot; + block + &quot;.&quot; + field);
-                }
-
+        /*				try {
+                            switch (fieldMap.Type) {
+                                case FieldType.LLVector3:
+                                case FieldType.IPADDR:
+                                    return IPAddress.Parse(value);
+                                case FieldType.IPPORT:
+                                    return Convert.ToUInt16(value);
+                                case FieldType.Variable:
+                                    Match match = Regex.Match(value, @&quot;^0x([0-9a-fA-F]{2})*&quot;, RegexOptions.IgnoreCase);
+                                    if (match.Success) {
+                                        byte[] buf = new byte[match.Groups[1].Captures.Count];
+                                        int i = 0;
+                                        foreach (Capture capture in match.Groups[1].Captures)
+                                            buf[i++] = Byte.Parse(capture.ToString(), NumberStyles.AllowHexSpecifier);
+                                        return buf;
+                                    } else
+                                        return value;
+                            }
+                        } catch {
+                            throw new Exception(&quot;unable to interpret &quot; + value + &quot; as &quot; + fieldMap.Type);
+                        }
+
+                        throw new Exception(&quot;unsupported field type &quot; + fieldMap.Type);
+                    }
+
+                    throw new Exception(&quot;unknown field &quot; + name + &quot;.&quot; + block + &quot;.&quot; + field);
+                }
+
                 throw new Exception(&quot;unknown block &quot; + name + &quot;.&quot; + block); */
     }
 
@@ -832,34 +833,34 @@
     // LogPacket: dump a packet to the console
     private static void LogPacket(Packet packet, IPEndPoint endPoint, Direction direction)
     {
-        /* if (logGrep != null) {
-            bool match = false;
-            foreach (Block block in packet.Blocks())
-                foreach (Field field in block.Fields) {
-                    string value;
-                    if (field.Layout.Type == FieldType.Variable)
-                        value = DataConvert.toChoppedString(field.Data);
-                    else
-                        value = field.Data.ToString();
-                    if (Regex.Match(packet.Layout.Name + &quot;.&quot; + block.Layout.Name + &quot;.&quot; + field.Layout.Name + &quot; = &quot; + value, logGrep, RegexOptions.IgnoreCase).Success) {
-                        match = true;
-                        break;
-                    }
-
-                    // try matching variable fields in 0x notation
-                    if (field.Layout.Type == FieldType.Variable) {
-                        StringWriter sw = new StringWriter();
-                        sw.Write(&quot;0x&quot;);
-                        foreach (byte b in (byte[])field.Data)
-                            sw.Write(&quot;{0:x2}&quot;, b);
-                        if (Regex.Match(packet.Layout.Name + &quot;.&quot; + block.Layout.Name + &quot;.&quot; + field.Layout.Name + &quot; = &quot; + sw, logGrep, RegexOptions.IgnoreCase).Success) {
-                            match = true;
-                            break;
-                        }
-                    }
-                }
-            if (!match)
-                return;
+        /* if (logGrep != null) {
+            bool match = false;
+            foreach (Block block in packet.Blocks())
+                foreach (Field field in block.Fields) {
+                    string value;
+                    if (field.Layout.Type == FieldType.Variable)
+                        value = DataConvert.toChoppedString(field.Data);
+                    else
+                        value = field.Data.ToString();
+                    if (Regex.Match(packet.Layout.Name + &quot;.&quot; + block.Layout.Name + &quot;.&quot; + field.Layout.Name + &quot; = &quot; + value, logGrep, RegexOptions.IgnoreCase).Success) {
+                        match = true;
+                        break;
+                    }
+
+                    // try matching variable fields in 0x notation
+                    if (field.Layout.Type == FieldType.Variable) {
+                        StringWriter sw = new StringWriter();
+                        sw.Write(&quot;0x&quot;);
+                        foreach (byte b in (byte[])field.Data)
+                            sw.Write(&quot;{0:x2}&quot;, b);
+                        if (Regex.Match(packet.Layout.Name + &quot;.&quot; + block.Layout.Name + &quot;.&quot; + field.Layout.Name + &quot; = &quot; + sw, logGrep, RegexOptions.IgnoreCase).Success) {
+                            match = true;
+                            break;
+                        }
+                    }
+                }
+            if (!match)
+                return;
         } */
 
         Console.WriteLine(&quot;{0} {1,21} {2,5} {3}{4}{5}&quot;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000126.html">[Libsecondlife-commits] r757 - trunk/SLProxy
</A></li>
	<LI>Next message: <A HREF="000128.html">[Libsecondlife-commits] r759 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#127">[ date ]</a>
              <a href="thread.html#127">[ thread ]</a>
              <a href="subject.html#127">[ subject ]</a>
              <a href="author.html#127">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">More information about the Libsecondlife-commits
mailing list</a><br>
</body></html>
