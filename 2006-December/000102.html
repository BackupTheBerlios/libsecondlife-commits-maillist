<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Libsecondlife-commits] r735 - trunk/SLProxy
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/libsecondlife-commits/2006-December/index.html" >
   <LINK REL="made" HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r735%20-%20trunk/SLProxy&In-Reply-To=%3C200612172034.kBHKYcVD013632%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000101.html">
   <LINK REL="Next"  HREF="000103.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Libsecondlife-commits] r735 - trunk/SLProxy</H1>
    <B>qode at mail.berlios.de</B> 
    <A HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r735%20-%20trunk/SLProxy&In-Reply-To=%3C200612172034.kBHKYcVD013632%40sheep.berlios.de%3E"
       TITLE="[Libsecondlife-commits] r735 - trunk/SLProxy">qode at mail.berlios.de
       </A><BR>
    <I>Sun Dec 17 21:34:38 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000101.html">[Libsecondlife-commits] r734 - trunk/SLProxy
</A></li>
        <LI>Next message: <A HREF="000103.html">[Libsecondlife-commits] r736 - trunk/libsecondlife-cs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#102">[ date ]</a>
              <a href="thread.html#102">[ thread ]</a>
              <a href="subject.html#102">[ subject ]</a>
              <a href="author.html#102">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: qode
Date: 2006-12-17 21:34:29 +0100 (Sun, 17 Dec 2006)
New Revision: 735

Modified:
   trunk/SLProxy/README.txt
   trunk/SLProxy/SLProxy.cs
   trunk/SLProxy/SLProxy.csproj
Log:
OH SH!+, I committed to the wrong SVN! Fixed public repository.

Modified: trunk/SLProxy/README.txt
===================================================================
--- trunk/SLProxy/README.txt	2006-12-17 20:25:16 UTC (rev 734)
+++ trunk/SLProxy/README.txt	2006-12-17 20:34:29 UTC (rev 735)
@@ -1,371 +1,363 @@
-NOTE: THIS DEVELOPER BRANCH IS THE NEW PREGEN SLPROXY. THIS DOCUMENT
-MAY NOT BE UP TO DATE WITH THIS VERSION. THIS SLPROXY VERSION IS STILL
-YET TO BE TESTED, SO EXPECT SOME/MOST/ALL FUNCTIONS TO NOT WORK.
-
-MODIFICATIONS BY &quot;ALPHA ZAIUS&quot; / ANDREW ORTMAN. QODE IN EFNET: #LIBSL
-AND #LIBSL-DEV
-
----------------------------------------------------------------------
-SLProxy is a library that works in conjunction with libsecondlife to
-allow applications to wedge themselves between the official Second
-Life client and servers.  SLProxy applications can inspect and modify
-any packet as it passes between the client and the servers; remove
-packets from the stream; and inject new packets into the stream.
-SLProxy automatically takes care of tracking circuits and modifying
-sequence numbers and acknowledgements to account for changes to the
-packet stream.
-
-The continued existence of this software of course rests on the good
-will of Linden Lab toward the Second Life reverse engineering effort.
-Please use common sense when designing applications and report any
-security holes you may find to <A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">security at lindenlab.com.</A>
-
-To use an SLProxy application, you must first start the proxy, then
-start Second Life with the switch `-loginuri <A HREF="http://localhost:8080/">http://localhost:8080/</A>'.
-In Windows, add this switch (without the quotes) to your Second Life
-shortcut.  In MacOS X, this can be accomplished by sending the
-following commands to the Terminal (assuming Second Life is installed
-in /Applications):
-
-	cd &quot;/Applications/Second Life.app&quot;
-	&quot;Contents/MacOS/Second Life&quot; -loginuri <A HREF="http://localhost:8080/">http://localhost:8080/</A>
-
-Note that for security reasons, by default, SLProxy applications must
-be running on the same computer as Second Life.  If you need to run a
-proxy on a different machine or port, start the proxy with the
---proxy-help switch and see the options available.
-
-SLProxy can only handle one client using a proxy at a time.
-
-BUILDING
-========
-
-To build SLProxy, you must check out the entire libsecondlife trunk
-with subversion:
-
-  svn co <A HREF="svn://svn.gna.org/svn/libsecondlife/trunk">svn://svn.gna.org/svn/libsecondlife/trunk</A> libsecondlife
-
-The libsecondlife-cs project must be built first; see
-libsecondlife-cs/README for instructions.  Building SLProxy should be
-straightforward with Microsoft Visual Studio.  If you're using Mono,
-you can build the solution with the included build script:
-
-  perl build
-
-The SLProxy library and its example applications will be built in
-bin/Debug.  In order to run the example applications, you must first
-add the libsecondlife-cs build directory to your MONO_PATH environment
-variable.  For example, if your libsecondlife-cs directory is
-~/libsecondlife/libsecondlife-cs and your shell is bash, you can type:
-
-  export MONO_PATH=$MONO_PATH:~/libsecondlife/libsecondlife-cs/bin/Debug/
-
-INCLUDED APPLICATIONS
-=====================
-
-Included with SLProxy are a few example application, which are covered
-in this section.
-
-1. Analyst
-----------
-
-Analyst makes SLProxy's packet inspection and modification
-functionality interactive.  When connected to Second Life through
-Analyst, you use the following commands by saying them using in-world
-chat:
-
-/log &lt;packet name&gt;
-
-  Packets of type &lt;packet name&gt; will be dumped to the console.  For
-  example, say `/log ChatFromSimulator' to get a packet dump of all
-  incoming chat.
-
-/-log &lt;packet name&gt;
-
-  Packets of type &lt;packet name&gt; will no longer be dumped to the
-  console.
-
-/log *
-
-  All packets will be dumped to the console.
-
-/-log *
-
-  No packets will be dumped to the console.
-
-/grep [regex]
-
-  Only log packets that have a field for which regex matches
-  &lt;packet name&gt;.&lt;block name&gt;.&lt;field name&gt; = &lt;value&gt;.  To stop
-  filtering, type /grep without an argument.  Matches are case
-  insensitive.  In the case of a variable field, Analyst will try to
-  convert it into a string; if that doesn't match, it will try
-  converting it into a hexidecimal numeral preceeded by 0x.
-
-/set &lt;packet name&gt; &lt;block name&gt; &lt;field name&gt; &lt;value&gt;
-
-  All forthcoming packets of type &lt;packet name&gt; will have the field
-  identified by &lt;block name&gt; and &lt;field name&gt; set to &lt;value&gt;.  For
-  example, if you say `/set ChatFromViewer ChatData Type 0',
-  everything you say thereafter will be whispered.  Values for
-  variable fields will be interpreted as strings unless they begin
-  with a 0x, in which case they will be treated as hexidecimal
-  numerals representing the contents of the field.
-
-/-set &lt;packet name&gt; &lt;block name&gt; &lt;field name&gt;
-
-  Packets of type &lt;packet name&gt; will no longer have the field
-  identified by &lt;block name&gt; and &lt;field name&gt; modified.
-
-/-set *
-
-  No fields will be modified.
-
-/inject &lt;packet file&gt; [value]
-
-  Inject the packet described by &lt;packet file&gt;.packet in the working
-  directory.  The [value] is optional and may be required by some
-  packet files.  `/in' is an alias for `/inject'.  The syntax of a
-  packet file is described in section 2.1.  SLProxy comes with two
-  example packet files: god.packet allows you to enable hacked god
-  mode by typing `/inject god', and whisper.packet allows you to
-  whisper by typing `/inject whisper &lt;message&gt;'.
-
-These commands will not be forwarded to the server, so other people
-won't hear you say them.
-
-Analyst accepts a --log-all command line switch, which causes the
-proxy to start out logging all packets as if you had typed `/log *'.
-This can be useful if you want to capture a complete dump of your
-session, including login.
-
-Analyst also accepts a --log-login command line switch, which causes
-the XML-RPC login request and response to dumped to the console.
-
-2.1 Packet files
-- - - - - - - -
-
-A packet file describes a packet that can be injected with the /inject
-command.  Please refer to god.packet and whisper.packet (in the
-bin/Debug/ directory) as examples.
-
-The first line of a packet file must contain the word `in' or `out',
-specifying whether the packet is incoming or outgoing, respectively,
-followed by the name of the packet.
-
-The remainder of the file specifies the packet's blocks and fields.  A
-block is described by placing its name in square brackets
-(e.g. `[GrantData]').  Following the the line specifying the block's
-name, the block's fields and values are specified, separated by equal
-signs (e.g. `GodLevel = 255'), one per line.
-
-The value of a field can be a literal value (e.g. `255'), or one of
-the following special values:
-
-$Value
-
-  the [value] specified by the user
-
-$UUID
-
-  a random UUID
-
-$AgentID
-
-  the user's AgentID
-
-$SessionID
-
-  the user's SessionID
-
-2. ChatConsole
---------------
-
-ChatConsole is a trivial SLProxy application intended as an example of
-how SLProxy applications can be written.  When connected to Second
-Life through ChatConsole, all in-world chat will be echoed to the
-console, and anything typed in the console will be echoed to the game as
-in-world chat.
-
-PUBLIC INTERFACE
-================
-
-This section describes the interface that SLProxy applications will
-use to interact with the packet stream.  Please see ChatConsole.cs for
-a simple example of how this interface can be used.
-
-SLProxy extends the functionality of libsecondlife, so we assume here
-that the reader is already familiar with libsecondlife's Packet and
-PacketBuilder classes.
-
-1. ProxyConfig class
---------------------
-
-An instance of ProxyConfig represents the configuration of a Proxy
-object, and must be provided when constructing a Proxy.  ProxyConfig
-has two constructors:
-
-	ProxyConfig(string userAgent, string author)
-	ProxyConfig(string userAgent, string author, string[] args)
-
-Both constructors require a user agent name and the author's email
-address.  These are sent to Second Life's login server to identify the
-client, and to allow Linden Lab to get in touch with authors whose
-applications may inadvertantly be causing problems.  The second
-constructor is preferred and takes an array of command-line arguments
-that allow the user to override certain network settings.  For a list
-of command line arguments, start your appliation with the --proxy-help
-switch.
-
-2. Proxy class
---------------
-
-The Proxy class represents an instance of an SLProxy and provides the
-methods necessary to modify the packet stream.  Proxy's sole
-constructor takes an instance of ProxyConfig.
-
-2.1 Login delegates
-- - - - - - - - - -
-
-You may specify that SLProxy should call a delegate method in your
-application when the user requests login or the server responds.
-
-	delegate void XmlRpcRequestDelegate(XmlRpcRequest request)
-	delegate void XmlRpcResponseDelegate(XmlRpcResponse response)
-	void SetLoginRequestDelegate(XmlRpcRequestDelegate loginRequestDelegate)
-	void SetLoginResponseDelegate(XmlRpcResponseDelegate loginResponseDelegate)
-
-A login response delegate, in particular, is useful for retrieving the
-agent_id and session_id, which are required when injecting certain
-types of packets.  See ChatConsole.cs for an example of how these can
-be retrieved.
-
-Note that all delegates must terminate (not go into an infinite loop),
-and must be thread-safe.
-
-2.2 Packet delegates
-- - - - - - - - - -
-
-Packet delegates allow you to inspect and modify packets as they pass
-between the client and the server:
-
-	delegate Packet PacketDelegate(Packet packet, IPEndPoint endPoint)
-	void AddDelegate(string packetName, Direction direction, PacketDelegate packetDelegate)
-	void RemoveDelegate(string packetName, Direction direction)
-
-AddDelegate adds a callback delegate for packets named packetName
-going direction.  Directions are either Direction.Incoming, meaning
-packets heading from the server to the client, or Direction.Outgoing,
-meaning packets heading from the client to the server.  Only one
-delegate can apply to a packet at a time; if you add a new delegate
-with the same packetName and direction, the old one will be removed.
-
-RemoveDelegate simply removes the delegate for the specified type of
-packet.
-
-PacketDelegate methods are passed a copy of the packet (in the form of
-a libsecondlife Packet object) and the IPEndPoint of the server that
-sent (or will receive) the packet.  PacketDelegate methods may do one
-of three things:
-
-1. Return the same packet, in which case it will be passed on.
-2. Return a new packet (built with libsecondlife), in which case the
-   new packet will substitute for the original.  SLProxy will
-   automatically copy the sequence number and appended ACKs from the
-   old packet to the new one.
-3. Return null, in which case the packet will not be passed on.
-
-SLProxy automatically takes care of ensuring that sequence numbers and
-acknowledgements are adjusted to account for changes made by the
-application.  When replacing a reliable packet with an unreliable
-packet or removing a reliable packet, a fake acknowledgement is
-injected.  When replacing an unreliable packet with a reliable packet,
-SLProxy ensures delivery and intercepts its acknowledgement.  Note
-that if a reliable packet is passed on but then lost on the network,
-Second Life will resend it and the delegate will be called again.  You
-can tell if a packet is being resent by checking if (packet.Data[0] &amp;
-Helpers.MSG_RESENT) is nonzero, although be advised that it's possible
-that the original packet never made it to the proxy and the packet
-will be marked RESENT the first time the proxy ever sees it.
-
-Note that all delegates must terminate (not go into an infinite loop),
-and must be thread-safe.
-
-2.3 Packet injection
-- - - - - - - - - -
-
-New packets may be injected into the stream at any point, either
-during a delegate callback or by another thread in your application.
-Packets are injected with the InjectPacket method:
-
-	void InjectPacket(Packet packet, Direction direction)
-
-This will inject a packet heading to either the client or to the
-active server, when direction is Direction.Incoming or
-Direction.Outgoing, respectively.  The packet's sequence number will
-be set automatically, and if the packet is reliable, SLProxy will
-ensure its delivery and intercept its acknowledgement.
-
-Injecting a packet immediately upon (or prior to) connection is not
-recommended, since the client and the server won't have initialized
-their session yet.
-
-2.4 Starting and stopping the proxy
-- - - - - - - - - - - - - - - - - -
-
-Once you've constructed a Proxy and added your delegates, you must
-start it with the Start method:
-
-	void Start()
-
-Once started, the proxy will begin listening for connections.  The
-Start method spawns new threads for the proxy and returns immediately.
-
-When your application is ready to shut down, you must call the Stop
-method:
-
-	void Stop()
-
-Note that this may not actually force the proxy to stop accepting
-connections; it merely guarantees that all foreground threads are
-stopped, allowing the application to exit cleanly.
-
-3. PacketUtility class
-----------------------
-
-The PacketUtility class provides a handful of static methods which may
-be useful when inspecting and modifying packets.
-
-3.1 Hashtable Unbuild(Packet packet)
-- - - - - - - - - - - - - - - - - -
-
-The Unbuild method takes a Packet object and returns a table of
-blocks, structured in a format suitable for passing to PacketUtility's
-GetField and SetField methods or PacketBuilder's BuildPacket method.
-
-For example, this should make an approximate copy of a packet:
-
-Hashtable packetBlocks = PacketUtility.Unbuild(packet);
-Packet packetCopy = PacketBuilder.BuildPacket(packet.Layout.Name, protocolManager, packetBlocks, packet.Data[0]);
-
-3.2 object GetField(Hashtable blocks, string block, string field)
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-
-The GetField method takes a table of blocks (produced by
-PacketUtility.Unbuild) and extracts the value of a particular field.
-If the field is part of a variable block, an arbitrary instance of the
-field will be returned.  If the field does not exist, null will be
-returned.
-
-3.3 void SetField(Hashtable blocks, string block, string field, object value)
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-
-The SetField method takes a table of blocks (produced by
-PacketUtility.Unbuild) and sets the value of a particular field.  If
-the field is part of a variable block, all instances of the field will
-be set.  If the field does not exist, SetField will have no effect.
-
-This can be used by a packet delegate method in conjunction with
-PacketUtility.Unbuild and PacketBuilder.BuildPacket to substitute a
-new packet that is a copy of the original packet with certain fields
-modified.
+SLProxy is a library that works in conjunction with libsecondlife to
+allow applications to wedge themselves between the official Second
+Life client and servers.  SLProxy applications can inspect and modify
+any packet as it passes between the client and the servers; remove
+packets from the stream; and inject new packets into the stream.
+SLProxy automatically takes care of tracking circuits and modifying
+sequence numbers and acknowledgements to account for changes to the
+packet stream.
+
+The continued existence of this software of course rests on the good
+will of Linden Lab toward the Second Life reverse engineering effort.
+Please use common sense when designing applications and report any
+security holes you may find to <A HREF="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">security at lindenlab.com.</A>
+
+To use an SLProxy application, you must first start the proxy, then
+start Second Life with the switch `-loginuri <A HREF="http://localhost:8080/">http://localhost:8080/</A>'.
+In Windows, add this switch (without the quotes) to your Second Life
+shortcut.  In MacOS X, this can be accomplished by sending the
+following commands to the Terminal (assuming Second Life is installed
+in /Applications):
+
+	cd &quot;/Applications/Second Life.app&quot;
+	&quot;Contents/MacOS/Second Life&quot; -loginuri <A HREF="http://localhost:8080/">http://localhost:8080/</A>
+
+Note that for security reasons, by default, SLProxy applications must
+be running on the same computer as Second Life.  If you need to run a
+proxy on a different machine or port, start the proxy with the
+--proxy-help switch and see the options available.
+
+SLProxy can only handle one client using a proxy at a time.
+
+BUILDING
+========
+
+To build SLProxy, you must check out the entire libsecondlife trunk
+with subversion:
+
+  svn co <A HREF="svn://svn.gna.org/svn/libsecondlife/trunk">svn://svn.gna.org/svn/libsecondlife/trunk</A> libsecondlife
+
+The libsecondlife-cs project must be built first; see
+libsecondlife-cs/README for instructions.  Building SLProxy should be
+straightforward with Microsoft Visual Studio.  If you're using Mono,
+you can build the solution with the included build script:
+
+  perl build
+
+The SLProxy library and its example applications will be built in
+bin/Debug.  In order to run the example applications, you must first
+add the libsecondlife-cs build directory to your MONO_PATH environment
+variable.  For example, if your libsecondlife-cs directory is
+~/libsecondlife/libsecondlife-cs and your shell is bash, you can type:
+
+  export MONO_PATH=$MONO_PATH:~/libsecondlife/libsecondlife-cs/bin/Debug/
+
+INCLUDED APPLICATIONS
+=====================
+
+Included with SLProxy are a few example application, which are covered
+in this section.
+
+1. Analyst
+----------
+
+Analyst makes SLProxy's packet inspection and modification
+functionality interactive.  When connected to Second Life through
+Analyst, you use the following commands by saying them using in-world
+chat:
+
+/log &lt;packet name&gt;
+
+  Packets of type &lt;packet name&gt; will be dumped to the console.  For
+  example, say `/log ChatFromSimulator' to get a packet dump of all
+  incoming chat.
+
+/-log &lt;packet name&gt;
+
+  Packets of type &lt;packet name&gt; will no longer be dumped to the
+  console.
+
+/log *
+
+  All packets will be dumped to the console.
+
+/-log *
+
+  No packets will be dumped to the console.
+
+/grep [regex]
+
+  Only log packets that have a field for which regex matches
+  &lt;packet name&gt;.&lt;block name&gt;.&lt;field name&gt; = &lt;value&gt;.  To stop
+  filtering, type /grep without an argument.  Matches are case
+  insensitive.  In the case of a variable field, Analyst will try to
+  convert it into a string; if that doesn't match, it will try
+  converting it into a hexidecimal numeral preceeded by 0x.
+
+/set &lt;packet name&gt; &lt;block name&gt; &lt;field name&gt; &lt;value&gt;
+
+  All forthcoming packets of type &lt;packet name&gt; will have the field
+  identified by &lt;block name&gt; and &lt;field name&gt; set to &lt;value&gt;.  For
+  example, if you say `/set ChatFromViewer ChatData Type 0',
+  everything you say thereafter will be whispered.  Values for
+  variable fields will be interpreted as strings unless they begin
+  with a 0x, in which case they will be treated as hexidecimal
+  numerals representing the contents of the field.
+
+/-set &lt;packet name&gt; &lt;block name&gt; &lt;field name&gt;
+
+  Packets of type &lt;packet name&gt; will no longer have the field
+  identified by &lt;block name&gt; and &lt;field name&gt; modified.
+
+/-set *
+
+  No fields will be modified.
+
+/inject &lt;packet file&gt; [value]
+
+  Inject the packet described by &lt;packet file&gt;.packet in the working
+  directory.  The [value] is optional and may be required by some
+  packet files.  `/in' is an alias for `/inject'.  The syntax of a
+  packet file is described in section 2.1.  SLProxy comes with two
+  example packet files: god.packet allows you to enable hacked god
+  mode by typing `/inject god', and whisper.packet allows you to
+  whisper by typing `/inject whisper &lt;message&gt;'.
+
+These commands will not be forwarded to the server, so other people
+won't hear you say them.
+
+Analyst accepts a --log-all command line switch, which causes the
+proxy to start out logging all packets as if you had typed `/log *'.
+This can be useful if you want to capture a complete dump of your
+session, including login.
+
+Analyst also accepts a --log-login command line switch, which causes
+the XML-RPC login request and response to dumped to the console.
+
+2.1 Packet files
+- - - - - - - -
+
+A packet file describes a packet that can be injected with the /inject
+command.  Please refer to god.packet and whisper.packet (in the
+bin/Debug/ directory) as examples.
+
+The first line of a packet file must contain the word `in' or `out',
+specifying whether the packet is incoming or outgoing, respectively,
+followed by the name of the packet.
+
+The remainder of the file specifies the packet's blocks and fields.  A
+block is described by placing its name in square brackets
+(e.g. `[GrantData]').  Following the the line specifying the block's
+name, the block's fields and values are specified, separated by equal
+signs (e.g. `GodLevel = 255'), one per line.
+
+The value of a field can be a literal value (e.g. `255'), or one of
+the following special values:
+
+$Value
+
+  the [value] specified by the user
+
+$UUID
+
+  a random UUID
+
+$AgentID
+
+  the user's AgentID
+
+$SessionID
+
+  the user's SessionID
+
+2. ChatConsole
+--------------
+
+ChatConsole is a trivial SLProxy application intended as an example of
+how SLProxy applications can be written.  When connected to Second
+Life through ChatConsole, all in-world chat will be echoed to the
+console, and anything typed in the console will be echoed to the game as
+in-world chat.
+
+PUBLIC INTERFACE
+================
+
+This section describes the interface that SLProxy applications will
+use to interact with the packet stream.  Please see ChatConsole.cs for
+a simple example of how this interface can be used.
+
+SLProxy extends the functionality of libsecondlife, so we assume here
+that the reader is already familiar with libsecondlife's Packet and
+PacketBuilder classes.
+
+1. ProxyConfig class
+--------------------
+
+An instance of ProxyConfig represents the configuration of a Proxy
+object, and must be provided when constructing a Proxy.  ProxyConfig
+has two constructors:
+
+	ProxyConfig(string userAgent, string author)
+	ProxyConfig(string userAgent, string author, string[] args)
+
+Both constructors require a user agent name and the author's email
+address.  These are sent to Second Life's login server to identify the
+client, and to allow Linden Lab to get in touch with authors whose
+applications may inadvertantly be causing problems.  The second
+constructor is preferred and takes an array of command-line arguments
+that allow the user to override certain network settings.  For a list
+of command line arguments, start your appliation with the --proxy-help
+switch.
+
+2. Proxy class
+--------------
+
+The Proxy class represents an instance of an SLProxy and provides the
+methods necessary to modify the packet stream.  Proxy's sole
+constructor takes an instance of ProxyConfig.
+
+2.1 Login delegates
+- - - - - - - - - -
+
+You may specify that SLProxy should call a delegate method in your
+application when the user requests login or the server responds.
+
+	delegate void XmlRpcRequestDelegate(XmlRpcRequest request)
+	delegate void XmlRpcResponseDelegate(XmlRpcResponse response)
+	void SetLoginRequestDelegate(XmlRpcRequestDelegate loginRequestDelegate)
+	void SetLoginResponseDelegate(XmlRpcResponseDelegate loginResponseDelegate)
+
+A login response delegate, in particular, is useful for retrieving the
+agent_id and session_id, which are required when injecting certain
+types of packets.  See ChatConsole.cs for an example of how these can
+be retrieved.
+
+Note that all delegates must terminate (not go into an infinite loop),
+and must be thread-safe.
+
+2.2 Packet delegates
+- - - - - - - - - -
+
+Packet delegates allow you to inspect and modify packets as they pass
+between the client and the server:
+
+	delegate Packet PacketDelegate(Packet packet, IPEndPoint endPoint)
+	void AddDelegate(string packetName, Direction direction, PacketDelegate packetDelegate)
+	void RemoveDelegate(string packetName, Direction direction)
+
+AddDelegate adds a callback delegate for packets named packetName
+going direction.  Directions are either Direction.Incoming, meaning
+packets heading from the server to the client, or Direction.Outgoing,
+meaning packets heading from the client to the server.  Only one
+delegate can apply to a packet at a time; if you add a new delegate
+with the same packetName and direction, the old one will be removed.
+
+RemoveDelegate simply removes the delegate for the specified type of
+packet.
+
+PacketDelegate methods are passed a copy of the packet (in the form of
+a libsecondlife Packet object) and the IPEndPoint of the server that
+sent (or will receive) the packet.  PacketDelegate methods may do one
+of three things:
+
+1. Return the same packet, in which case it will be passed on.
+2. Return a new packet (built with libsecondlife), in which case the
+   new packet will substitute for the original.  SLProxy will
+   automatically copy the sequence number and appended ACKs from the
+   old packet to the new one.
+3. Return null, in which case the packet will not be passed on.
+
+SLProxy automatically takes care of ensuring that sequence numbers and
+acknowledgements are adjusted to account for changes made by the
+application.  When replacing a reliable packet with an unreliable
+packet or removing a reliable packet, a fake acknowledgement is
+injected.  When replacing an unreliable packet with a reliable packet,
+SLProxy ensures delivery and intercepts its acknowledgement.  Note
+that if a reliable packet is passed on but then lost on the network,
+Second Life will resend it and the delegate will be called again.  You
+can tell if a packet is being resent by checking if (packet.Data[0] &amp;
+Helpers.MSG_RESENT) is nonzero, although be advised that it's possible
+that the original packet never made it to the proxy and the packet
+will be marked RESENT the first time the proxy ever sees it.
+
+Note that all delegates must terminate (not go into an infinite loop),
+and must be thread-safe.
+
+2.3 Packet injection
+- - - - - - - - - -
+
+New packets may be injected into the stream at any point, either
+during a delegate callback or by another thread in your application.
+Packets are injected with the InjectPacket method:
+
+	void InjectPacket(Packet packet, Direction direction)
+
+This will inject a packet heading to either the client or to the
+active server, when direction is Direction.Incoming or
+Direction.Outgoing, respectively.  The packet's sequence number will
+be set automatically, and if the packet is reliable, SLProxy will
+ensure its delivery and intercept its acknowledgement.
+
+Injecting a packet immediately upon (or prior to) connection is not
+recommended, since the client and the server won't have initialized
+their session yet.
+
+2.4 Starting and stopping the proxy
+- - - - - - - - - - - - - - - - - -
+
+Once you've constructed a Proxy and added your delegates, you must
+start it with the Start method:
+
+	void Start()
+
+Once started, the proxy will begin listening for connections.  The
+Start method spawns new threads for the proxy and returns immediately.
+
+When your application is ready to shut down, you must call the Stop
+method:
+
+	void Stop()
+
+Note that this may not actually force the proxy to stop accepting
+connections; it merely guarantees that all foreground threads are
+stopped, allowing the application to exit cleanly.
+
+3. PacketUtility class
+----------------------
+
+The PacketUtility class provides a handful of static methods which may
+be useful when inspecting and modifying packets.
+
+3.1 Hashtable Unbuild(Packet packet)
+- - - - - - - - - - - - - - - - - -
+
+The Unbuild method takes a Packet object and returns a table of
+blocks, structured in a format suitable for passing to PacketUtility's
+GetField and SetField methods or PacketBuilder's BuildPacket method.
+
+For example, this should make an approximate copy of a packet:
+
+Hashtable packetBlocks = PacketUtility.Unbuild(packet);
+Packet packetCopy = PacketBuilder.BuildPacket(packet.Layout.Name, protocolManager, packetBlocks, packet.Data[0]);
+
+3.2 object GetField(Hashtable blocks, string block, string field)
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+The GetField method takes a table of blocks (produced by
+PacketUtility.Unbuild) and extracts the value of a particular field.
+If the field is part of a variable block, an arbitrary instance of the
+field will be returned.  If the field does not exist, null will be
+returned.
+
+3.3 void SetField(Hashtable blocks, string block, string field, object value)
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+The SetField method takes a table of blocks (produced by
+PacketUtility.Unbuild) and sets the value of a particular field.  If
+the field is part of a variable block, all instances of the field will
+be set.  If the field does not exist, SetField will have no effect.
+
+This can be used by a packet delegate method in conjunction with
+PacketUtility.Unbuild and PacketBuilder.BuildPacket to substitute a
+new packet that is a copy of the original packet with certain fields
+modified.

Modified: trunk/SLProxy/SLProxy.cs
===================================================================
--- trunk/SLProxy/SLProxy.cs	2006-12-17 20:25:16 UTC (rev 734)
+++ trunk/SLProxy/SLProxy.cs	2006-12-17 20:34:29 UTC (rev 735)
@@ -2,8 +2,6 @@
  * SLProxy.cs: implementation of Second Life proxy library
  *
  * Copyright (c) 2006 Austin Jennings
- * Pregen modifications made by Andrew Ortman on Dec 10, 2006
- * 
  * All rights reserved.
  *
  * - Redistribution and use in source and binary forms, with or without 
@@ -33,7 +31,6 @@
 using Nwc.XmlRpc;
 using System;
 using System.Collections;
-using System.Collections.Generic;
 using System.IO;
 using System.Net;
 using System.Net.Sockets;
@@ -42,9 +39,7 @@
 using System.Threading;
 using System.Xml;
 using libsecondlife;
-using libsecondlife.Packets;
 
-
 // SLProxy: proxy library for Second Life
 namespace SLProxy {
 	// ProxyConfig: configuration for proxy objects
@@ -54,8 +49,7 @@
 		// author: email address of the proxy application's author
 		public string author;
 		// protocol: libsecondlife ProtocolManager
-		//public ProtocolManager protocol;
-        public SecondLife client;
+		public ProtocolManager protocol;
 		// loginPort: port that the login proxy will listen on
 		public ushort loginPort = 8080;
 		// clientFacingAddress: address from which to communicate with the client
@@ -68,14 +62,14 @@
 		public bool verbose = true;
 
 		// ProxyConfig: construct a default proxy configuration with the specified userAgent, author, and protocol
-		public ProxyConfig(string userAgent, string author, SecondLife slclient) {
+		public ProxyConfig(string userAgent, string author, ProtocolManager protocol) {
 			this.userAgent = userAgent;
 			this.author = author;
-            this.client = slclient;
+			this.protocol = protocol;
 		}
 
 		// ProxyConfig: construct a default proxy configuration, parsing command line arguments (try --proxy-help)
-		public ProxyConfig(string userAgent, string author, SecondLife slclient, string[] args) : this(userAgent, author, slclient) {
+		public ProxyConfig(string userAgent, string author, ProtocolManager protocol, string[] args) : this(userAgent, author, protocol) {
 			Hashtable argumentParsers = new Hashtable();
 			argumentParsers[&quot;proxy-help&quot;] = new ArgumentParser(ParseHelp);
 			argumentParsers[&quot;proxy-login-port&quot;] = new ArgumentParser(ParseLoginPort);
@@ -332,7 +326,7 @@
 			request.Params.Add(requestParams);
 
 			// forward the XML-RPC request to the server
-			XmlRpcResponse response = (XmlRpcResponse)request.Send(proxyConfig.remoteLoginUri.ToString(),60000); //added 60 second timeout -- Andrew
+			XmlRpcResponse response = (XmlRpcResponse)request.Send(proxyConfig.remoteLoginUri.ToString());
 			Hashtable responseData = (Hashtable)response.Value;
 
 			// proxy any simulator address given in the XML-RPC response
@@ -421,72 +415,76 @@
 
 				// interpret the packet according to the SL protocol
 				Packet packet;
-                int end = receiveBuffer.Length - 1;
-
-                packet = Packet.BuildPacket(receiveBuffer, ref end, zeroBuffer);
+				if ((receiveBuffer[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(receiveBuffer), false);
+				else {
+					Helpers.ZeroDecodeCommand(receiveBuffer, zeroBuffer);
+					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(zeroBuffer), false);
+					needsZero = true;
+				}
 #if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;&lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Header.Sequence);
+				Console.WriteLine(&quot;&lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
 #endif
 
 				// check for ACKs we're waiting for
 				packet = simProxy.CheckAcks(packet, Direction.Incoming, ref length, ref needsCopy);
 
 				// modify sequence numbers to account for injections
-				ushort oldSequence = packet.Header.Sequence;
+				uint oldSequence = packet.Sequence;
 				packet = simProxy.ModifySequence(packet, Direction.Incoming, ref length, ref needsCopy);
 
 				// keep track of sequence numbers
-				if (packet.Header.Sequence &gt; simProxy.incomingSequence)
-					simProxy.incomingSequence = packet.Header.Sequence;
+				if (packet.Sequence &gt; simProxy.incomingSequence)
+					simProxy.incomingSequence = packet.Sequence;
 
 				// check the packet for addresses that need proxying
-				if (incomingCheckers.Contains(packet.Type)) {
+				if (incomingCheckers.Contains(packet.Layout.Name)) {
 					if (needsZero) {
-						length = Helpers.ZeroDecode(packet.Header.Data, length, zeroBuffer);
-						packet.Header.Data = zeroBuffer;
+						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
+						packet.Data = zeroBuffer;
 						needsZero = false;
 					}
 
-					Packet newPacket = ((AddressChecker)incomingCheckers[packet.Type])(packet);
+					Packet newPacket = ((AddressChecker)incomingCheckers[packet.Layout.Name])(packet);
 					SwapPacket(packet, newPacket, length);
 					packet = newPacket;
-					length = packet.Header.Data.Length;
+					length = packet.Data.Length;
 					needsCopy = false;
 				}
 
 				// pass the packet to any callback delegates
-				if (incomingDelegates.Contains(packet.Type)) {
+				if (incomingDelegates.Contains(packet.Layout.Name)) {
 					if (needsZero) {
-						length = Helpers.ZeroDecode(packet.Header.Data, length, zeroBuffer);
-						packet.Header.Data = zeroBuffer;
+						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
+						packet.Data = zeroBuffer;
 						needsCopy = true;
 					}
 
 					if (needsCopy) {
 						byte[] newData = new byte[length];
-						Array.Copy(packet.Header.Data, 0, newData, 0, length);
-						packet.Header.Data = newData;
+						Array.Copy(packet.Data, 0, newData, 0, length);
+						packet.Data = newData;
 					}
 
 					try {
-						Packet newPacket = ((PacketDelegate)incomingDelegates[packet.Type])(packet, (IPEndPoint)remoteEndPoint);
+						Packet newPacket = ((PacketDelegate)incomingDelegates[packet.Layout.Name])(packet, (IPEndPoint)remoteEndPoint);
 						if (newPacket == null) {
-							if ((packet.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
+							if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
 								simProxy.Inject(SpoofAck(oldSequence), Direction.Outgoing);
 
-							if ((packet.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
+							if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
 								packet = SeparateAck(packet);
 							else
 								packet = null;
 						} else {
-							bool oldReliable = (packet.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
-							bool newReliable = (newPacket.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							bool oldReliable = (packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							bool newReliable = (newPacket.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
 							if (oldReliable &amp;&amp; !newReliable)
 								simProxy.Inject(SpoofAck(oldSequence), Direction.Outgoing);
 							else if (!oldReliable &amp;&amp; newReliable)
 								simProxy.WaitForAck(packet, Direction.Incoming);
 
-							SwapPacket(packet, newPacket, packet.Header.Data.Length);
+							SwapPacket(packet, newPacket, packet.Data.Length);
 							packet = newPacket;
 						}
 					} catch (Exception e) {
@@ -495,7 +493,7 @@
 					}
 
 					if (packet != null)
-						simProxy.SendPacket(packet, packet.Header.Data.Length, false);
+						simProxy.SendPacket(packet, packet.Data.Length, false);
 				} else
 					simProxy.SendPacket(packet, length, needsZero);
 			} else
@@ -511,72 +509,67 @@
 
 		// SendPacket: send a packet to a sim from our fake client endpoint
 		public void SendPacket(Packet packet, IPEndPoint endPoint, int length, bool skipZero) {
-			if (skipZero || (packet.Header.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-				simFacingSocket.SendTo(packet.Header.Data, length, SocketFlags.None, endPoint);
+			if (skipZero || (packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+				simFacingSocket.SendTo(packet.Data, length, SocketFlags.None, endPoint);
 			else {
-				int zeroLength = Helpers.ZeroEncode(packet.Header.Data, length, zeroBuffer);
+				int zeroLength = Helpers.ZeroEncode(packet.Data, length, zeroBuffer);
 				simFacingSocket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, endPoint);
 			}
 		}
 
 		// SpoofAck: create an ACK for the given packet
-		public Packet SpoofAck(ushort sequence) {
-            PacketAckPacket spoof = new PacketAckPacket();
-            spoof.Packets = new PacketAckPacket.PacketsBlock[1];
-            spoof.Packets[0].ID = sequence;
-            return (Packet)spoof;
-            //Legacy:
-            ////Hashtable blocks = new Hashtable();
-            ////Hashtable fields = new Hashtable();
-            ////fields[&quot;ID&quot;] = (uint)sequence;
-            ////blocks[fields] = &quot;Packets&quot;;
-            ////return .BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, Helpers.MSG_ZEROCODED);
+		public Packet SpoofAck(uint sequence) {
+			Hashtable blocks = new Hashtable();
+			Hashtable fields = new Hashtable();
+			fields[&quot;ID&quot;] = (uint)sequence;
+			blocks[fields] = &quot;Packets&quot;;
+			return PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, Helpers.MSG_ZEROCODED);
 		}
 
 		// SeparateAck: create a standalone PacketAck for packet's appended ACKs
 		public Packet SeparateAck(Packet packet) {
-            PacketAckPacket seperate = new PacketAckPacket();
-            int ackCount = ((packet.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)packet.Header.Data[packet.Header.Data.Length - 1]);
-            seperate.Packets = new PacketAckPacket.PacketsBlock[ackCount];	
-		
-            for (int i = 0; i &lt; ackCount; ++i)
-            {
-            	int offset = packet.Header.Data.Length - (ackCount - i) * 4 - 1;
-                seperate.Packets[i].ID = (uint) ((packet.Header.Data[offset++] &lt;&lt;  0)
-				                                + (packet.Header.Data[offset++] &lt;&lt;  8)
-				                                + (packet.Header.Data[offset++] &lt;&lt; 16)
-				                                + (packet.Header.Data[offset++] &lt;&lt; 24))
-				                                ;
-            }
+			int ackCount = ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)packet.Data[packet.Data.Length - 1]);
+			Hashtable blocks = new Hashtable();
+			for (int i = 0; i &lt; ackCount; ++i) {
+				Hashtable fields = new Hashtable();
+				int offset = packet.Data.Length - (ackCount - i) * 4 - 1;
+				fields[&quot;ID&quot;] = (uint)
+					  (packet.Data[offset++] &lt;&lt;  0)
+					+ (packet.Data[offset++] &lt;&lt;  8)
+					+ (packet.Data[offset++] &lt;&lt; 16)
+					+ (packet.Data[offset++] &lt;&lt; 24)
+					;
+				blocks[fields] = &quot;Packets&quot;;
+			}
 
-            Packet ack = (Packet)seperate;
-            ack.Header.Sequence = packet.Header.Sequence;
-            return ack;
+			Packet ack = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, Helpers.MSG_ZEROCODED);
+			ack.Sequence = packet.Sequence;
+			return ack;
 		}
 
 		// SwapPacket: copy the sequence number and appended ACKs from one packet to another
 		public static void SwapPacket(Packet oldPacket, Packet newPacket, int oldLength) {
-			newPacket.Header.Sequence = oldPacket.Header.Sequence;
+			newPacket.Sequence = oldPacket.Sequence;
 
-			int oldAcks = (oldPacket.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)oldPacket.Header.Data[oldLength - 1];
-			int newAcks = (newPacket.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)newPacket.Header.Data[newPacket.Header.Data.Length - 1];
+			int oldAcks = (oldPacket.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)oldPacket.Data[oldLength - 1];
+			int newAcks = (newPacket.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) == 0 ? 0 : (int)newPacket.Data[newPacket.Data.Length - 1];
 
 			if (oldAcks != 0 || newAcks != 0) {
 				int oldAckSize = oldAcks == 0 ? 0 : oldAcks * 4 + 1;
 				int newAckSize = newAcks == 0 ? 0 : newAcks * 4 + 1;
 
-                byte[] newData = new byte[newPacket.Header.Data.Length - newAckSize + oldAckSize];
-                Array.Copy(newPacket.Header.Data, 0, newData, 0, newPacket.Header.Data.Length - newAckSize);
+				byte[] newData = new byte[newPacket.Data.Length - newAckSize + oldAckSize];
+				Array.Copy(newPacket.Data, 0, newData, 0, newPacket.Data.Length - newAckSize);
 
 				if (newAcks != 0)
 					newData[0] ^= Helpers.MSG_APPENDED_ACKS;
 
 				if (oldAcks != 0) {
 					newData[0] |= Helpers.MSG_APPENDED_ACKS;
-					Array.Copy(oldPacket.Header.Data, oldLength - oldAckSize, newData, newPacket.Header.Data.Length - newAckSize, oldAckSize);
+					Array.Copy(oldPacket.Data, oldLength - oldAckSize, newData, newPacket.Data.Length - newAckSize, oldAckSize);
 				}
 
-                newPacket.Header.Data = newData;
+				newPacket.Data = newData;
 			}
 		}
 
@@ -608,12 +601,12 @@
 			private IPEndPoint remoteEndPoint;
 			private Proxy proxy;
 			private Socket socket;
-			public ushort incomingSequence;
-			public ushort outgoingSequence;
+			public uint incomingSequence;
+			public uint outgoingSequence;
 			private ArrayList incomingInjections;
 			private ArrayList outgoingInjections;
-			private ushort incomingOffset = 0;
-			private ushort outgoingOffset = 0;
+			private uint incomingOffset = 0;
+			private uint outgoingOffset = 0;
 			private Hashtable incomingAcks;
 			private Hashtable outgoingAcks;
 			private ArrayList incomingSeenAcks;
@@ -689,24 +682,24 @@
 						outgoingSeenAcksPoint = outgoingSeenAcks.Count;
 					}
 
-					foreach (ushort id in incomingAcks.Keys)
+					foreach (uint id in incomingAcks.Keys)
 						if (!incomingSeenAcks.Contains(id)) {
 							Packet packet = (Packet)incomingAcks[id];
-							packet.Header.Data[0] |= Helpers.MSG_RESENT;
+							packet.Data[0] |= Helpers.MSG_RESENT;
 #if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;RESEND &lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Header.Sequence);
+							Console.WriteLine(&quot;RESEND &lt;- &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
 #endif
-							SendPacket(packet, packet.Header.Data.Length, false);
+							SendPacket(packet, packet.Data.Length, false);
 						}
 
-					foreach (ushort id in outgoingAcks.Keys)
+					foreach (uint id in outgoingAcks.Keys)
 						if (!outgoingSeenAcks.Contains(id)) {
 							Packet packet = (Packet)outgoingAcks[id];
-							packet.Header.Data[0] |= Helpers.MSG_RESENT;
+							packet.Data[0] |= Helpers.MSG_RESENT;
 #if DEBUG_SEQUENCE
-							Console.WriteLine(&quot;RESEND -&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Header.Sequence);
+							Console.WriteLine(&quot;RESEND -&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
 #endif
-							proxy.SendPacket(packet, remoteEndPoint, packet.Header.Data.Length, false);
+							proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
 						}
 				}
 			} catch (Exception e) {
@@ -741,71 +734,77 @@
 				length = socket.EndReceiveFrom(ar, ref clientEndPoint);
 
 				// interpret the packet according to the SL protocol
-                int end = receiveBuffer.Length - 1;
-				Packet packet = libsecondlife.Packets.Packet.BuildPacket(receiveBuffer,ref end, zeroBuffer);
-				
+				Packet packet;
+				if ((receiveBuffer[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(receiveBuffer), false);
+				else {
+					Helpers.ZeroDecodeCommand(receiveBuffer, zeroBuffer);
+					packet = new Packet(receiveBuffer, length, proxyConfig.protocol, proxyConfig.protocol.Command(zeroBuffer), false);
+					needsZero = true;
+				}
 #if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;-&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Header.Sequence);
+				Console.WriteLine(&quot;-&gt; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
 #endif
-                // check for ACKs we're waiting for
+
+				// check for ACKs we're waiting for
 				packet = CheckAcks(packet, Direction.Outgoing, ref length, ref needsCopy);
 
 				// modify sequence numbers to account for injections
-				ushort oldSequence = packet.Header.Sequence;
+				uint oldSequence = packet.Sequence;
 				packet = ModifySequence(packet, Direction.Outgoing, ref length, ref needsCopy);
 
 				// keep track of sequence numbers
-				if (packet.Header.Sequence &gt; outgoingSequence)
-                    outgoingSequence = packet.Header.Sequence ;
+				if (packet.Sequence &gt; outgoingSequence)
+					outgoingSequence = packet.Sequence;
 
 				// check the packet for addresses that need proxying
-				if (proxy.outgoingCheckers.Contains(packet.Type)) {
-					if (packet.Header.Zerocoded) {
-						length = Helpers.ZeroDecode(packet.Header.Data, length, zeroBuffer);
-						packet.Header.Data = zeroBuffer;
+				if (proxy.outgoingCheckers.Contains(packet.Layout.Name)) {
+					if (needsZero) {
+						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
+						packet.Data = zeroBuffer;
 						needsZero = false;
 					}
 
-					Packet newPacket = ((AddressChecker)proxy.outgoingCheckers[packet.Type])(packet);
+					Packet newPacket = ((AddressChecker)proxy.outgoingCheckers[packet.Layout.Name])(packet);
 					SwapPacket(packet, newPacket, length);
 					packet = newPacket;
-					length = packet.Header.Data.Length;
+					length = packet.Data.Length;
 					needsCopy = false;
 				}
 
 				// pass the packet to any callback delegates
-				if (proxy.outgoingDelegates.Contains(packet.Type)) {
-					if (packet.Header.Zerocoded) {
-						length = Helpers.ZeroDecode(packet.Header.Data, length, zeroBuffer);
-						packet.Header.Data = zeroBuffer;
+				if (proxy.outgoingDelegates.Contains(packet.Layout.Name)) {
+					if (needsZero) {
+						length = Helpers.ZeroDecode(packet.Data, length, zeroBuffer);
+						packet.Data = zeroBuffer;
 						needsCopy = true;
 					}
 
 					if (needsCopy) {
 						byte[] newData = new byte[length];
-						Array.Copy(packet.Header.Data, 0, newData, 0, length);
-						packet.Header.Data = newData;
+						Array.Copy(packet.Data, 0, newData, 0, length);
+						packet.Data = newData;
 					}
 
 					try {
-						Packet newPacket = ((PacketDelegate)proxy.outgoingDelegates[packet.Type])(packet, remoteEndPoint);
+						Packet newPacket = ((PacketDelegate)proxy.outgoingDelegates[packet.Layout.Name])(packet, remoteEndPoint);
 						if (newPacket == null) {
-							if ((packet.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
+							if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
 								Inject(proxy.SpoofAck(oldSequence), Direction.Incoming);
 
-							if ((packet.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
+							if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0)
 								packet = proxy.SeparateAck(packet);
 							else
 								packet = null;
 						} else {
-							bool oldReliable = (packet.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
-							bool newReliable = (newPacket.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							bool oldReliable = (packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
+							bool newReliable = (newPacket.Data[0] &amp; Helpers.MSG_RELIABLE) != 0;
 							if (oldReliable &amp;&amp; !newReliable)
 								Inject(proxy.SpoofAck(oldSequence), Direction.Incoming);
 							else if (!oldReliable &amp;&amp; newReliable)	
 								WaitForAck(packet, Direction.Outgoing);
 
-							SwapPacket(packet, newPacket, packet.Header.Data.Length);
+							SwapPacket(packet, newPacket, packet.Data.Length);
 							packet = newPacket;
 						}
 					} catch (Exception e) {
@@ -814,7 +813,7 @@
 					}
 
 					if (packet != null)
-						proxy.SendPacket(packet, remoteEndPoint, packet.Header.Data.Length, false);
+						proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
 				} else
 					proxy.SendPacket(packet, remoteEndPoint, length, needsZero);
 
@@ -835,10 +834,10 @@
 
 			// SendPacket: send a packet from the sim to the client via our fake sim endpoint
 			public void SendPacket(Packet packet, int length, bool skipZero) {
-				if (skipZero || (packet.Header.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-					socket.SendTo(packet.Header.Data, length, SocketFlags.None, clientEndPoint);
+				if (skipZero || (packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+					socket.SendTo(packet.Data, length, SocketFlags.None, clientEndPoint);
 				else {
-					int zeroLength = Helpers.ZeroEncode(packet.Header.Data, length, zeroBuffer);
+					int zeroLength = Helpers.ZeroEncode(packet.Data, length, zeroBuffer);
 					socket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, clientEndPoint);
 				}
 			}
@@ -852,34 +851,34 @@
 					}
 
 					incomingInjections.Add(++incomingSequence);
-					packet.Header.Sequence = incomingSequence;
+					packet.Sequence = incomingSequence;
 				} else {
 					outgoingInjections.Add(++outgoingSequence);
-					packet.Header.Sequence = outgoingSequence;
+					packet.Sequence = outgoingSequence;
 				}
 
 #if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;INJECT &quot; + (direction == Direction.Incoming ? &quot;&lt;-&quot; : &quot;-&gt;&quot;) + &quot; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Header.Sequence);
+				Console.WriteLine(&quot;INJECT &quot; + (direction == Direction.Incoming ? &quot;&lt;-&quot; : &quot;-&gt;&quot;) + &quot; &quot; + packet.Layout.Name + &quot; #&quot; + packet.Sequence);
 
 #endif
-				if ((packet.Header.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
+				if ((packet.Data[0] &amp; Helpers.MSG_RELIABLE) != 0)
 					WaitForAck(packet, direction);
 
 				if (direction == Direction.Incoming)
-					if ((packet.Header.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
-						socket.SendTo(packet.Header.Data, packet.Header.Data.Length, SocketFlags.None, clientEndPoint);
+					if ((packet.Data[0] &amp; Helpers.MSG_ZEROCODED) == 0)
+						socket.SendTo(packet.Data, packet.Data.Length, SocketFlags.None, clientEndPoint);
 					else {
-						int zeroLength = Helpers.ZeroEncode(packet.Header.Data, packet.Header.Data.Length, zeroBuffer);
+						int zeroLength = Helpers.ZeroEncode(packet.Data, packet.Data.Length, zeroBuffer);
 						socket.SendTo(zeroBuffer, zeroLength, SocketFlags.None, clientEndPoint);
 					}
 				else
-					proxy.SendPacket(packet, remoteEndPoint, packet.Header.Data.Length, false);
+					proxy.SendPacket(packet, remoteEndPoint, packet.Data.Length, false);
 			}
 
 			// WaitForAck: take care of resending a packet until it's ACKed
 			public void WaitForAck(Packet packet, Direction direction) {
 				Hashtable table = direction == Direction.Incoming ? incomingAcks : outgoingAcks;
-				table.Add(packet.Header.Sequence, packet);
+				table.Add(packet.Sequence, packet);
 			}
 
 			// CheckAcks: check for and remove ACKs of packets we've injected
@@ -891,52 +890,42 @@
 					return packet;
 
 				// check for embedded ACKs
-				if (packet.Type == PacketType.PacketAck) {
+				if (packet.Layout.Name == &quot;PacketAck&quot;) {
 					bool changed = false;
-                    List&lt;PacketAckPacket.PacketsBlock&gt; newPacketBlocks = new List&lt;PacketAckPacket.PacketsBlock&gt;();
-					foreach (PacketAckPacket.PacketsBlock pb in ((PacketAckPacket)packet).Packets) {
-						ushort id = (ushort)pb.ID;
+					Hashtable blocks = PacketUtility.Unbuild(packet);
+					Hashtable newBlocks = new Hashtable();
+					foreach (Hashtable fields in blocks.Keys) {
+						uint id = ((uint)fields[&quot;ID&quot;]);
 #if DEBUG_SEQUENCE
 						string hrup = &quot;Check !&quot; + id;
 #endif
-                        if (acks.Contains(id))
-                        {
+						if (acks.Contains(id)) {
 #if DEBUG_SEQUENCE
 							hrup += &quot; get's&quot;;
 #endif
-                            seenAcks.Add(id);
-                            changed = true;
-                        }
-                        else
-                            newPacketBlocks.Add(pb);
+							seenAcks.Add(id);
+							changed = true;
+						} else
+							newBlocks.Add(fields, blocks[fields]);
 #if DEBUG_SEQUENCE
 						Console.WriteLine(hrup);
 #endif
 					}
-					if (changed)
-                    {
-                        PacketAckPacket newPacket = new PacketAckPacket();
-                        newPacket.Packets = new PacketAckPacket.PacketsBlock[newPacketBlocks.Count];
-                        
-                        int a = 0;
-                        foreach (PacketAckPacket.PacketsBlock pb in newPacketBlocks)
-                        {
-                            newPacket.Packets[a++] = pb;
-                        } 
-
-                        SwapPacket(packet, (Packet)newPacket, length);
+					if (changed) {
+						Packet newPacket = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, newBlocks, packet.Data[0]);
+						SwapPacket(packet, newPacket, length);
 						packet = newPacket;
-						length = packet.Header.Data.Length;
+						length = packet.Data.Length;
 						needsCopy = false;
 					}
 				}
 
 				// check for appended ACKs
-				if ((packet.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
-					byte ackCount = packet.Header.Data[length - 1];
+				if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
+					byte ackCount = packet.Data[length - 1];
 					for (int i = 0; i &lt; ackCount;) {
 						int offset = length - (ackCount - i) * 4 - 1;
-						ushort ackID = (ushort)(packet.Header.Data[offset + 3] + (packet.Header.Data[offset + 2] &lt;&lt; 8));
+						uint ackID = (uint)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8) + (packet.Data[offset + 1] &lt;&lt; 16));
 #if DEBUG_SEQUENCE
 						string hrup = &quot;Check @&quot; + ackID;
 #endif
@@ -945,10 +934,10 @@
 							hrup += &quot; get's&quot;;
 #endif
 							byte[] newData = new byte[length -= 4];
-							Array.Copy(packet.Header.Data, 0, newData, 0, offset);
-							Array.Copy(packet.Header.Data, offset + 4, newData, offset, length - offset - 4);
+							Array.Copy(packet.Data, 0, newData, 0, offset);
+							Array.Copy(packet.Data, offset + 4, newData, offset, length - offset - 4);
 							--newData[newData.Length - 1];
-							packet.Header.Data = newData;
+							packet.Data = newData;
 							--ackCount;
 							seenAcks.Add(ackID);
 							needsCopy = false;
@@ -960,9 +949,9 @@
 					}
 					if (ackCount == 0) {
 						byte[] newData = new byte[length -= 1];
-						Array.Copy(packet.Header.Data, 0, newData, 0, length);
+						Array.Copy(packet.Data, 0, newData, 0, length);
 						newData[0] ^= Helpers.MSG_APPENDED_ACKS;
-						packet.Header.Data = newData;
+						packet.Data = newData;
 					}
 				}
 
@@ -973,56 +962,59 @@
 			public Packet ModifySequence(Packet packet, Direction direction, ref int length, ref bool needsCopy) {
 				ArrayList ourInjections = direction == Direction.Outgoing ? outgoingInjections : incomingInjections;
 				ArrayList theirInjections = direction == Direction.Incoming ? outgoingInjections : incomingInjections;
-				ushort ourOffset = direction == Direction.Outgoing ? outgoingOffset : incomingOffset;
-				ushort theirOffset = direction == Direction.Incoming ? outgoingOffset : incomingOffset;
+				uint ourOffset = direction == Direction.Outgoing ? outgoingOffset : incomingOffset;
+				uint theirOffset = direction == Direction.Incoming ? outgoingOffset : incomingOffset;
 
-				ushort newSequence = (ushort)(packet.Header.Sequence + ourOffset);
-				foreach (ushort injection in ourInjections)
+				uint newSequence = (packet.Sequence + ourOffset);
+				foreach (uint injection in ourInjections)
 					if (newSequence &gt;= injection)
 						++newSequence;
 #if DEBUG_SEQUENCE
-				Console.WriteLine(&quot;Mod #&quot; + packet.Header.Sequence + &quot; = &quot; + newSequence);
+				Console.WriteLine(&quot;Mod #&quot; + packet.Sequence + &quot; = &quot; + newSequence);
 #endif
-				packet.Header.Sequence = newSequence;
+				packet.Sequence = newSequence;
 
-				if ((packet.Header.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
-					int ackCount = packet.Header.Data[length - 1];
+				if ((packet.Data[0] &amp; Helpers.MSG_APPENDED_ACKS) != 0) {
+					int ackCount = packet.Data[length - 1];
 					for (int i = 0; i &lt; ackCount; ++i) {
 						int offset = length - (ackCount - i) * 4 - 1;
-						uint ackID = (uint)(packet.Header.Data[offset + 3] + (packet.Header.Data[offset + 2] &lt;&lt; 8)) - theirOffset;
+						uint ackID = (uint)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8) + (packet.Data[offset + 1] &lt;&lt; 16)) - theirOffset;
 #if DEBUG_SEQUENCE
-						uint hrup = (uint)(packet.Header.Data[offset + 3] + (packet.Header.Data[offset + 2] &lt;&lt; 8));
+						uint hrup = (uint)(packet.Data[offset + 3] + (packet.Data[offset + 2] &lt;&lt; 8) + (packet.Data[offset + 1] &lt;&lt; 16));
 #endif
 						for (int j = theirInjections.Count - 1; j &gt;= 0; --j)
-							if (ackID &gt;= (ushort)theirInjections[j])
+							if (ackID &gt;= (uint)theirInjections[j])
 								--ackID;
 #if DEBUG_SEQUENCE
 						Console.WriteLine(&quot;Mod @&quot; + hrup + &quot; = &quot; + ackID);
 #endif
-						packet.Header.Data[offset + 3] = (byte)(ackID % 256);
-						packet.Header.Data[offset + 2] = (byte)(ackID / 256);
+						packet.Data[offset + 3] = (byte)(ackID % 256);
+						packet.Data[offset + 2] = (byte)((ackID / 256) % 256);
+						packet.Data[offset + 1] = (byte)(ackID / 65536);
 					}
 				}
 
-				if (packet.Type == PacketType.PacketAck) {
-                    PacketAckPacket pap = new PacketAckPacket();
-                    foreach(PacketAckPacket.PacketsBlock pb in pap.Packets) {
-                    	uint ackID = (uint)pb.ID - theirOffset;
+				if (packet.Layout.Name == &quot;PacketAck&quot;) {
+					Hashtable blocks = PacketUtility.Unbuild(packet);
+					foreach (Hashtable fields in blocks.Keys) {
+						if ((string)blocks[fields] == &quot;Packets&quot;) {
+							uint ackID = (uint)fields[&quot;ID&quot;] - theirOffset;
 #if DEBUG_SEQUENCE
-						uint hrup = (uint)fields[&quot;ID&quot;];
+							uint hrup = (uint)fields[&quot;ID&quot;];
 #endif
-						for (int i = theirInjections.Count - 1; i &gt;= 0; --i)
-							if (ackID &gt;= (ushort)theirInjections[i])
-								--ackID;
+							for (int i = theirInjections.Count - 1; i &gt;= 0; --i)
+								if (ackID &gt;= (uint)theirInjections[i])
+									--ackID;
 #if DEBUG_SEQUENCE
-						Console.WriteLine(&quot;Mod !&quot; + hrup + &quot; = &quot; + ackID);
+							Console.WriteLine(&quot;Mod !&quot; + hrup + &quot; = &quot; + ackID);
 #endif
-						pb.ID = ackID;
-					
+							fields[&quot;ID&quot;] = ackID;
+						}
 					}
-                    SwapPacket(packet, (Packet)pap, length);
-					packet = (Packet)pap;
-					length = packet.Header.Data.Length;
+					Packet newPacket = PacketBuilder.BuildPacket(&quot;PacketAck&quot;, proxyConfig.protocol, blocks, packet.Data[0]);
+					SwapPacket(packet, newPacket, length);
+					packet = newPacket;
+					length = packet.Data.Length;
 					needsCopy = false;
 				}
 
@@ -1044,72 +1036,69 @@
 		// InitializeAddressCheckers: initialize delegates that check packets for addresses that need proxying
 		private void InitializeAddressCheckers() {
 			// TODO: what do we do with mysteries and empty IPs?
-			AddMystery(PacketType.OpenCircuit);
-			AddMystery(PacketType.AgentPresenceResponse);
-			incomingCheckers.Add(PacketType.TeleportFinish, new AddressChecker(CheckTeleportFinish));
+			AddMystery(&quot;OpenCircuit&quot;);
+			AddMystery(&quot;AgentPresenceResponse&quot;);
+			incomingCheckers.Add(&quot;TeleportFinish&quot;, new AddressChecker(CheckTeleportFinish));
 			// ViewerStats: IP is 0.0.0.0
-			incomingCheckers.Add(PacketType.AgentToNewRegion, new AddressChecker(CheckAgentToNewRegion));
-			incomingCheckers.Add(PacketType.CrossedRegion, new AddressChecker(CheckCrossedRegion));
-			incomingCheckers.Add(PacketType.EnableSimulator, new AddressChecker(CheckEnableSimulator));
+			incomingCheckers.Add(&quot;AgentToNewRegion&quot;, new AddressChecker(CheckAgentToNewRegion));
+			incomingCheckers.Add(&quot;CrossedRegion&quot;, new AddressChecker(CheckCrossedRegion));
+			incomingCheckers.Add(&quot;EnableSimulator&quot;, new AddressChecker(CheckEnableSimulator));
 			// KickUser: IP is 0.0.0.0
-			//incomingCheckers.Add(&quot;UserLoginLocationReply&quot;, new AddressChecker(CheckUserLoginLocationReply));
+			incomingCheckers.Add(&quot;UserLoginLocationReply&quot;, new AddressChecker(CheckUserLoginLocationReply));
 		}
 
 		// AddMystery: add a checker delegate that logs packets we're watching for development purposes
-		private void AddMystery(PacketType type) {
-			incomingCheckers.Add(type, new AddressChecker(LogIncomingMysteryPacket));
-			outgoingCheckers.Add(type, new AddressChecker(LogOutgoingMysteryPacket));
+		private void AddMystery(String name) {
+			incomingCheckers.Add(name, new AddressChecker(LogIncomingMysteryPacket));
+			outgoingCheckers.Add(name, new AddressChecker(LogOutgoingMysteryPacket));
 		}
 
 		// GenericCheck: replace the sim address in a packet with our proxy address
-		private void GenericCheck(ref uint simIP, ref ushort simPort, bool active) {
-            IPAddress sim_ip = new IPAddress((long)simIP);
+		private Packet GenericCheck(Packet packet, string block, string fieldIP, string fieldPort, bool active) {
+			Hashtable blocks = PacketUtility.Unbuild(packet);
 
-            IPEndPoint realSim = new IPEndPoint(sim_ip, Convert.ToInt32(simPort));
+			IPEndPoint realSim = new IPEndPoint((IPAddress)PacketUtility.GetField(blocks, block, fieldIP), Convert.ToInt32(PacketUtility.GetField(blocks, block, fieldPort)));
 			IPEndPoint fakeSim = ProxySim(realSim);
+			PacketUtility.SetField(blocks, block, fieldIP, fakeSim.Address);
+			PacketUtility.SetField(blocks, block, fieldPort, (ushort)fakeSim.Port);
 
-            simPort = (ushort)fakeSim.Port;
-            int i = 0;
-            byte[] bytes = fakeSim.Address.GetAddressBytes();
-            simIP = (uint)(bytes[i++] + (bytes[i++] &lt;&lt; 8) + (bytes[i++] &lt;&lt; 16) + (bytes[i++] &lt;&lt; 24));
-            
-            if (active)
-                activeCircuit = realSim;
+			if (active)
+				activeCircuit = realSim;
+
+			return PacketBuilder.BuildPacket(packet.Layout.Name, proxyConfig.protocol, blocks, packet.Data[0]);
 		}
 
 		// CheckTeleportFinish: check TeleportFinish packets
 		private Packet CheckTeleportFinish(Packet packet) {
-            TeleportFinishPacket tfp = (TeleportFinishPacket)packet;
-            GenericCheck(ref tfp.Info.SimIP, ref tfp.Info.SimPort, true);
-            return (Packet)tfp;
+			return GenericCheck(packet, &quot;Info&quot;, &quot;SimIP&quot;, &quot;SimPort&quot;, true);
 		}
 
 		// CheckAgentToNewRegion: check AgentToNewRegion packets
 		private Packet CheckAgentToNewRegion(Packet packet) {
-            AgentToNewRegionPacket atnwp = (AgentToNewRegionPacket)packet;
-            GenericCheck(ref atnwp.RegionData.IP, ref atnwp.RegionData.Port, true);
-            return (Packet)atnwp;
+			return GenericCheck(packet, &quot;RegionData&quot;, &quot;IP&quot;, &quot;Port&quot;, true);
 		}
 
 		// CheckEnableSimulator: check EnableSimulator packets
 		private Packet CheckEnableSimulator(Packet packet) {
-            EnableSimulatorPacket esp = (EnableSimulatorPacket)packet;
-            GenericCheck(ref esp.SimulatorInfo.IP, ref esp.SimulatorInfo.Port, false);
-            return (Packet)esp;
+			return GenericCheck(packet, &quot;SimulatorInfo&quot;, &quot;IP&quot;, &quot;Port&quot;, false);
 		}
 
 		// CheckCrossedRegion: check CrossedRegion packets
 		private Packet CheckCrossedRegion(Packet packet) {
-            CrossedRegionPacket crp = (CrossedRegionPacket)packet;
-            GenericCheck(ref crp.RegionData.SimIP, ref crp.RegionData.SimPort, true);
-            return (Packet)crp;
+			return GenericCheck(packet, &quot;RegionData&quot;, &quot;SimIP&quot;, &quot;SimPort&quot;, true);
 		}
 
-        // LogPacket: log a packet dump
+		// CheckUserLoginLocationReply: check UserLoginLocationReply packets
+		private Packet CheckUserLoginLocationReply(Packet packet) {
+			return GenericCheck(packet, &quot;SimulatorBlock&quot;, &quot;IP&quot;, &quot;Port&quot;, true);
+		}
+
+		// LogPacket: log a packet dump
 		private Packet LogPacket(Packet packet, string type) {
 			Log(type + &quot; packet:&quot;, true);
 			Log(packet, true);
-            return packet;
+
+			return PacketBuilder.BuildPacket(packet.Layout.Name, proxyConfig.protocol, PacketUtility.Unbuild(packet), packet.Data[0]);
 		}
 
 		// LogIncomingMysteryPacket: log an incoming packet we're watching for development purposes
@@ -1137,4 +1126,40 @@
 		Incoming,
 		Outgoing
 	}
+
+	// PacketUtility: provides various utility methods for working with libsecondlife Packet objects
+	public class PacketUtility {
+		// Unbuild: deconstruct a packet into a Hashtable of blocks suitable for passing to PacketBuilder
+		public static Hashtable Unbuild(Packet packet) {
+			Hashtable blockTable = new Hashtable();
+			foreach (Block block in packet.Blocks()) {
+				Hashtable fieldTable = new Hashtable();
+				foreach (Field field in block.Fields)
+					fieldTable[field.Layout.Name] = field.Data;
+				blockTable[fieldTable] = block.Layout.Name;
+			}
+
+			return blockTable;
+		}
+
+		// GetField: given a table of blocks, return the value of the specified block and field
+		// In the case of packets with variable blocks, an arbitrary block will be used.
+		public static object GetField(Hashtable blocks, string block, string field) {
+			foreach (Hashtable fields in blocks.Keys)
+				if ((string)blocks[fields] == block)
+					if (fields.Contains(field))
+						return fields[field];
+
+			return null;
+		}
+
+		// SetField: given a table of blocks, update the value of the specified block and field
+		// In the case of packets with variable blocks, all blocks will be updated.
+		public static void SetField(Hashtable blocks, string block, string field, object value) {
+			foreach (Hashtable fields in blocks.Keys)
+				if ((string)blocks[fields] == block)
+					if (fields.Contains(field))
+						fields[field] = value;
+		}
+	}
 }

Modified: trunk/SLProxy/SLProxy.csproj
===================================================================
--- trunk/SLProxy/SLProxy.csproj	2006-12-17 20:25:16 UTC (rev 734)
+++ trunk/SLProxy/SLProxy.csproj	2006-12-17 20:34:29 UTC (rev 735)
@@ -85,16 +85,26 @@
     &lt;/Reference&gt;
   &lt;/ItemGroup&gt;
   &lt;ItemGroup&gt;
+    &lt;Compile Include=&quot;legacy\Logger.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\Packet.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\ProtocolManager.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\SecondLife.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\Types.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcDeserializer.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcErrorCodes.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcException.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcRequest.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcRequestDeserializer.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcRequestSerializer.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcResponse.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcResponseDeserializer.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcResponseSerializer.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcSerializer.cs&quot; /&gt;
+    &lt;Compile Include=&quot;legacy\XmlRpcXmlTokens.cs&quot; /&gt;
     &lt;Compile Include=&quot;SLProxy.cs&quot;&gt;
       &lt;SubType&gt;Code&lt;/SubType&gt;
     &lt;/Compile&gt;
   &lt;/ItemGroup&gt;
-  &lt;ItemGroup&gt;
-    &lt;ProjectReference Include=&quot;..\libsecondlife-cs\libsecondlife.csproj&quot;&gt;
-      &lt;Project&gt;{D9CDEDFB-8169-4B03-B57F-0DF638F044EC}&lt;/Project&gt;
-      &lt;Name&gt;libsecondlife&lt;/Name&gt;
-    &lt;/ProjectReference&gt;
-  &lt;/ItemGroup&gt;
   &lt;Import Project=&quot;$(MSBuildBinPath)\Microsoft.CSharp.targets&quot; /&gt;
   &lt;PropertyGroup&gt;
     &lt;PreBuildEvent&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000101.html">[Libsecondlife-commits] r734 - trunk/SLProxy
</A></li>
	<LI>Next message: <A HREF="000103.html">[Libsecondlife-commits] r736 - trunk/libsecondlife-cs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#102">[ date ]</a>
              <a href="thread.html#102">[ thread ]</a>
              <a href="subject.html#102">[ subject ]</a>
              <a href="author.html#102">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">More information about the Libsecondlife-commits
mailing list</a><br>
</body></html>
