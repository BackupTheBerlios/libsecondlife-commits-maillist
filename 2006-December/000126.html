<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Libsecondlife-commits] r757 - trunk/SLProxy
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/libsecondlife-commits/2006-December/index.html" >
   <LINK REL="made" HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r757%20-%20trunk/SLProxy&In-Reply-To=%3C200612221635.kBMGZWnt026431%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000124.html">
   <LINK REL="Next"  HREF="000127.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Libsecondlife-commits] r757 - trunk/SLProxy</H1>
    <B>jhurliman at BerliOS</B> 
    <A HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r757%20-%20trunk/SLProxy&In-Reply-To=%3C200612221635.kBMGZWnt026431%40sheep.berlios.de%3E"
       TITLE="[Libsecondlife-commits] r757 - trunk/SLProxy">jhurliman at mail.berlios.de
       </A><BR>
    <I>Fri Dec 22 17:35:32 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000124.html">[Libsecondlife-commits] r756 - in trunk: . applications
</A></li>
        <LI>Next message: <A HREF="000127.html">[Libsecondlife-commits] r758 - trunk/SLProxy
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#126">[ date ]</a>
              <a href="thread.html#126">[ thread ]</a>
              <a href="subject.html#126">[ subject ]</a>
              <a href="author.html#126">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jhurliman
Date: 2006-12-22 17:35:30 +0100 (Fri, 22 Dec 2006)
New Revision: 757

Modified:
   trunk/SLProxy/Analyst.cs
Log:
Fixed /log *, /-log *, and formatted the whitespace

Modified: trunk/SLProxy/Analyst.cs
===================================================================
--- trunk/SLProxy/Analyst.cs	2006-12-22 15:33:30 UTC (rev 756)
+++ trunk/SLProxy/Analyst.cs	2006-12-22 16:35:30 UTC (rev 757)
@@ -26,711 +26,864 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  * POSSIBILITY OF SUCH DAMAGE.
- */
+ */
+
+using SLProxy;
+using libsecondlife;
+using Nwc.XmlRpc;
+using libsecondlife.Packets;
+using System.Reflection;
+
+using System;
+using System.Collections;
+using System.Globalization;
+using System.IO;
+using System.Net;
+using System.Text.RegularExpressions;
+
+public class Analyst
+{
+    private static Proxy proxy;
+    private static Hashtable commandDelegates = new Hashtable();
+    private static Hashtable loggedPackets = new Hashtable();
+    // private static string logGrep = null;
+    private static Hashtable modifiedPackets = new Hashtable();
+    private static LLUUID agentID;
+    private static LLUUID sessionID;
+    private static bool logLogin = false;
+    private static Assembly libslAssembly;
+
+    public static void Main(string[] args)
+    {
+
+        libslAssembly = Assembly.Load(&quot;libsecondlife&quot;);
+        if (libslAssembly == null) throw new Exception(&quot;Assembly load exception&quot;);
+
+        ProxyConfig proxyConfig = new ProxyConfig(&quot;Analyst V2&quot;, &quot;Austin Jennings / Andrew Ortman&quot;, args);
+        proxy = new Proxy(proxyConfig);
+
+        // build the table of /command delegates
+        InitializeCommandDelegates();
+
+        // add delegates for login
+        proxy.SetLoginRequestDelegate(new XmlRpcRequestDelegate(LoginRequest));
+        proxy.SetLoginResponseDelegate(new XmlRpcResponseDelegate(LoginResponse));
+
+        // add a delegate for outgoing chat
+        proxy.AddDelegate(PacketType.ChatFromViewer, Direction.Incoming, new PacketDelegate(ChatFromViewerIn));
+        proxy.AddDelegate(PacketType.ChatFromViewer, Direction.Outgoing, new PacketDelegate(ChatFromViewerOut));
+
+        //  handle command line arguments
+        foreach (string arg in args)
+            if (arg == &quot;--log-all&quot;)
+                LogAll();
+            else if (arg == &quot;--log-login&quot;)
+                logLogin = true;
+
+        // start the proxy
+        proxy.Start();
+    }
+
+    // LoginRequest: dump a login request to the console
+    private static void LoginRequest(XmlRpcRequest request)
+    {
+        if (logLogin)
+        {
+            Console.WriteLine(&quot;==&gt; Login Request&quot;);
+            Console.WriteLine(request);
+        }
+    }
+
+    // Loginresponse: dump a login response to the console
+    private static void LoginResponse(XmlRpcResponse response)
+    {
+        Hashtable values = (Hashtable)response.Value;
+        if (values.Contains(&quot;agent_id&quot;))
+            agentID = new LLUUID((string)values[&quot;agent_id&quot;]);
+        if (values.Contains(&quot;session_id&quot;))
+            sessionID = new LLUUID((string)values[&quot;session_id&quot;]);
+
+        if (logLogin)
+        {
+            Console.WriteLine(&quot;&lt;== Login Response&quot;);
+            Console.WriteLine(response);
+        }
+    }
+
+    // ChatFromViewerIn: incoming ChatFromViewer delegate; shouldn't be possible, but just in case...
+    private static Packet ChatFromViewerIn(Packet packet, IPEndPoint sim)
+    {
+        if (loggedPackets.Contains(PacketType.ChatFromViewer) || modifiedPackets.Contains(PacketType.ChatFromViewer))
+            // user has asked to log or modify this packet
+            return Analyze(packet, sim, Direction.Incoming);
+        else
+            // return the packet unmodified
+            return packet;
+    }
+
+    // ChatFromViewerOut: outgoing ChatFromViewer delegate; check for Analyst commands
+    private static Packet ChatFromViewerOut(Packet packet, IPEndPoint sim)
+    {
+        // deconstruct the packet
+        ChatFromViewerPacket cpacket = (ChatFromViewerPacket)packet;
+        string message = System.Text.Encoding.UTF8.GetString(cpacket.ChatData.Message).Replace(&quot;\0&quot;, &quot;&quot;);
+
+        if (message.Length &gt; 1 &amp;&amp; message[0] == '/')
+        {
+            string[] words = message.Split(' ');
+            if (commandDelegates.Contains(words[0]))
+            {
+                // this is an Analyst command; act on it and drop the chat packet
+                ((CommandDelegate)commandDelegates[words[0]])(words);
+                return null;
+            }
+        }
+
+        if (loggedPackets.Contains(PacketType.ChatFromViewer) || modifiedPackets.Contains(PacketType.ChatFromViewer))
+            // user has asked to log or modify this packet
+            return Analyze(packet, sim, Direction.Outgoing);
+        else
+            // return the packet unmodified
+            return packet;
+    }
+
+    // CommandDelegate: specifies a callback delegate for a /command
+    private delegate void CommandDelegate(string[] words);
+
+    // InitializeCommandDelegates: configure Analyst's commands
+    private static void InitializeCommandDelegates()
+    {
+        commandDelegates[&quot;/log&quot;] = new CommandDelegate(CmdLog);
+        commandDelegates[&quot;/-log&quot;] = new CommandDelegate(CmdNoLog);
+        // commandDelegates[&quot;/grep&quot;] = new CommandDelegate(CmdGrep);
+        commandDelegates[&quot;/set&quot;] = new CommandDelegate(CmdSet);
+        commandDelegates[&quot;/-set&quot;] = new CommandDelegate(CmdNoSet);
+        commandDelegates[&quot;/inject&quot;] = new CommandDelegate(CmdInject);
+        commandDelegates[&quot;/in&quot;] = new CommandDelegate(CmdInject);
+    }
+
+    private static PacketType packetTypeFromName(string name)
+    {
+        Type packetTypeType = typeof(PacketType);
+        System.Reflection.FieldInfo f = packetTypeType.GetField(name);
+        if (f == null) throw new ArgumentException(&quot;Bad packet type&quot;);
+        return (PacketType)Enum.ToObject(packetTypeType, (int)f.GetValue(packetTypeType));
+    }
+
+    // CmdLog: handle a /log command
+    private static void CmdLog(string[] words)
+    {
+        if (words.Length != 2)
+            SayToUser(&quot;Usage: /log &lt;packet name&gt;&quot;);
+        else if (words[1] == &quot;*&quot;)
+        {
+            LogAll();
+            SayToUser(&quot;logging all packets&quot;);
+        }
+        else
+        {
+            PacketType pType;
+            try
+            {
+                pType = packetTypeFromName(words[1]);
+            }
+            catch (ArgumentException e)
+            {
+                SayToUser(&quot;Bad packet name: &quot; + words[1]);
+                return;
+            }
+            loggedPackets[pType] = null;
+            if (words[1] != &quot;ChatFromViewer&quot;)
+            {
+                proxy.AddDelegate(pType, Direction.Incoming, new PacketDelegate(AnalyzeIn));
+                proxy.AddDelegate(pType, Direction.Outgoing, new PacketDelegate(AnalyzeOut));
+            }
+            SayToUser(&quot;logging &quot; + words[1]);
+        }
+    }
+
+    // CmdNoLog: handle a /-log command
+    private static void CmdNoLog(string[] words)
+    {
+        if (words.Length != 2)
+            SayToUser(&quot;Usage: /-log &lt;packet name&gt;&quot;);
+        else if (words[1] == &quot;*&quot;)
+        {
+            NoLogAll();
+            SayToUser(&quot;stopped logging all packets&quot;);
+        }
+        else
+        {
+            PacketType pType = packetTypeFromName(words[1]);
+            loggedPackets.Remove(pType);
+
+            if (!modifiedPackets.Contains(words[1]))
+            {
+                if (words[1] != &quot;ChatFromViewer&quot;)
+                {
+                    proxy.RemoveDelegate(pType, Direction.Incoming);
+                    proxy.RemoveDelegate(pType, Direction.Outgoing);
+                }
+            }
+
+            SayToUser(&quot;stopped logging &quot; + words[1]);
+        }
+    }
+
+    /*	// CmdGrep: handle a /grep command
+        private static void CmdGrep(string[] words) {
+            if (words.Length == 1) {
+                logGrep = null;
+                SayToUser(&quot;stopped filtering logs&quot;);
+            } else {
+                string[] regexArray = new string[words.Length - 1];
+                Array.Copy(words, 1, regexArray, 0, words.Length - 1);
+                logGrep = String.Join(&quot; &quot;, regexArray);
+                SayToUser(&quot;filtering log with &quot; + logGrep);
+            }
+        } */
+
+    // CmdSet: handle a /set command
+    private static void CmdSet(string[] words)
+    {
+        if (words.Length &lt; 5)
+            SayToUser(&quot;Usage: /set &lt;packet name&gt; &lt;block&gt; &lt;field&gt; &lt;value&gt;&quot;);
+        else
+        {
+            PacketType pType;
+            try
+            {
+                pType = packetTypeFromName(words[1]);
+            }
+            catch (ArgumentException e)
+            {
+                SayToUser(&quot;Bad packet name: &quot; + words[1]);
+                return;
+            }
+
+            string[] valueArray = new string[words.Length - 4];
+            Array.Copy(words, 4, valueArray, 0, words.Length - 4);
+            string valueString = String.Join(&quot; &quot;, valueArray);
+            object value;
+            try
+            {
+                value = MagicCast(words[1], words[2], words[3], valueString);
+            }
+            catch (Exception e)
+            {
+                SayToUser(e.Message);
+                return;
+            }
+
+            Hashtable fields;
+            if (modifiedPackets.Contains(pType))
+                fields = (Hashtable)modifiedPackets[pType];
+            else
+                fields = new Hashtable();
+
+            fields[new BlockField(words[2], words[3])] = value;
+            modifiedPackets[pType] = fields;
+
+            if (words[1] != &quot;ChatFromViewer&quot;)
+            {
+                proxy.AddDelegate(pType, Direction.Incoming, new PacketDelegate(AnalyzeIn));
+                proxy.AddDelegate(pType, Direction.Outgoing, new PacketDelegate(AnalyzeOut));
+            }
+
+            SayToUser(&quot;setting &quot; + words[1] + &quot;.&quot; + words[2] + &quot;.&quot; + words[3] + &quot; = &quot; + valueString);
+        }
+    }
+
+    // CmdNoSet: handle a /-set command
+    private static void CmdNoSet(string[] words)
+    {
+        if (words.Length == 2 &amp;&amp; words[1] == &quot;*&quot;)
+        {
+            foreach (PacketType pType in modifiedPackets.Keys)
+                if (!loggedPackets.Contains(pType) &amp;&amp; pType != PacketType.ChatFromViewer)
+                {
+                    proxy.RemoveDelegate(pType, Direction.Incoming);
+                    proxy.RemoveDelegate(pType, Direction.Outgoing);
+                }
+            modifiedPackets = new Hashtable();
+
+            SayToUser(&quot;stopped setting all fields&quot;);
+        }
+        else if (words.Length == 4)
+        {
+            PacketType pType;
+            try
+            {
+                pType = packetTypeFromName(words[1]);
+            }
+            catch (ArgumentException e)
+            {
+                SayToUser(&quot;Bad packet name: &quot; + words[1]);
+                return;
+            }
+
+
+            if (modifiedPackets.Contains(pType))
+            {
+                Hashtable fields = (Hashtable)modifiedPackets[pType];
+                fields.Remove(new BlockField(words[2], words[3]));
+
+                if (fields.Count == 0)
+                {
+                    modifiedPackets.Remove(pType);
+
+                    if (!loggedPackets.Contains(pType))
+                    {
+                        if (words[1] != &quot;ChatFromViewer&quot;)
+                        {
+                            proxy.RemoveDelegate(pType, Direction.Incoming);
+                            proxy.RemoveDelegate(pType, Direction.Outgoing);
+                        }
+                    }
+                }
+            }
+
+            SayToUser(&quot;stopped setting &quot; + words[1] + &quot;.&quot; + words[2] + &quot;.&quot; + words[3]);
+        }
+        else
+            SayToUser(&quot;Usage: /-set &lt;packet name&gt; &lt;block&gt; &lt;field&gt;&quot;);
+    }
+
+
+    // CmdInject: handle an /inject command
+    private static void CmdInject(string[] words)
+    {
+        if (words.Length &lt; 2)
+            SayToUser(&quot;Usage: /inject &lt;packet file&gt; [value]&quot;);
+        else
+        {
+            string[] valueArray = new string[words.Length - 2];
+            Array.Copy(words, 2, valueArray, 0, words.Length - 2);
+            string value = String.Join(&quot; &quot;, valueArray);
+
+            FileStream fs = null;
+            StreamReader sr = null;
+            Direction direction = Direction.Incoming;
+            string name = null;
+            //Hashtable blocks = new Hashtable();
+            string block = null;
+            object blockObj = null;
+            //Hashtable fields = new Hashtable();
+            Type packetClass = null;
+            Packet packet = null;
+
+            try
+            {
+                fs = File.OpenRead(words[1] + &quot;.packet&quot;);
+                sr = new StreamReader(fs);
+
+                string line;
+                while ((line = sr.ReadLine()) != null)
+                {
+                    Match match;
+
+                    if (name == null)
+                    {
+                        match = (new Regex(@&quot;^\s*(in|out)\s+(\w+)\s*$&quot;)).Match(line);
+                        if (!match.Success)
+                        {
+                            SayToUser(&quot;expecting direction and packet name, got: &quot; + line);
+                            return;
+                        }
+
+                        string lineDir = match.Groups[1].Captures[0].ToString();
+                        string lineName = match.Groups[2].Captures[0].ToString();
+
+                        if (lineDir == &quot;in&quot;)
+                            direction = Direction.Incoming;
+                        else if (lineDir == &quot;out&quot;)
+                            direction = Direction.Outgoing;
+                        else
+                        {
+                            SayToUser(&quot;expecting 'in' or 'out', got: &quot; + line);
+                            return;
+                        }
+
+                        name = lineName;
+                        packetClass = libslAssembly.GetType(&quot;libsecondlife.Packets.&quot; + name + &quot;Packet&quot;);
+                        if (packetClass == null) throw new Exception(&quot;Couldn't get class &quot; + name + &quot;Packet&quot;);
+                        ConstructorInfo ctr = packetClass.GetConstructor(new Type[] { });
+                        if (ctr == null) throw new Exception(&quot;Couldn't get suitable constructor for &quot; + name + &quot;Packet&quot;);
+                        packet = (Packet)ctr.Invoke(new object[] { });
+                        Console.WriteLine(&quot;Created new &quot; + name + &quot;Packet&quot;);
+                    }
+                    else
+                    {
+                        match = (new Regex(@&quot;^\s*\[(\w+)\]\s*$&quot;)).Match(line);
+                        if (match.Success)
+                        {
+                            //FIXME: support variable blocks
+
+                            block = match.Groups[1].Captures[0].ToString();
+                            FieldInfo blockField = packetClass.GetField(block);
+                            if (blockField == null) throw new Exception(&quot;Couldn't get &quot; + name + &quot;Packet.&quot; + block);
+                            blockObj = blockField.GetValue(packet);
+                            if (blockObj == null) throw new Exception(&quot;Got &quot; + name + &quot;Packet.&quot; + block + &quot; == null&quot;);
+                            Console.WriteLine(&quot;Got block &quot; + name + &quot;Packet.&quot; + block);
+
+                            continue;
+                        }
+
+                        if (block == null)
+                        {
+                            SayToUser(&quot;expecting block name, got: &quot; + line);
+                            return;
+                        }
+
+                        match = (new Regex(@&quot;^\s*(\w+)\s*=\s*(.*)$&quot;)).Match(line);
+                        if (match.Success)
+                        {
+                            string lineField = match.Groups[1].Captures[0].ToString();
+                            string lineValue = match.Groups[2].Captures[0].ToString();
+                            object fval;
+
+                            //FIXME: use of MagicCast inefficient
+                            if (lineValue == &quot;$Value&quot;)
+                                fval = MagicCast(name, block, lineField, value);
+                            else if (lineValue == &quot;$UUID&quot;)
+                                fval = LLUUID.Random();
+                            else if (lineValue == &quot;$AgentID&quot;)
+                                fval = agentID;
+                            else if (lineValue == &quot;$SessionID&quot;)
+                                fval = sessionID;
+                            else
+                                fval = MagicCast(name, block, lineField, lineValue);
+
+                            MagicSetField(blockObj, lineField, fval);
+                            continue;
+                        }
+
+                        SayToUser(&quot;expecting block name or field, got: &quot; + line);
+                        return;
+                    }
+                }
+
+                if (name == null)
+                {
+                    SayToUser(&quot;expecting direction and packet name, got EOF&quot;);
+                    return;
+                }
+
+                packet.Header.Flags |= Helpers.MSG_RELIABLE;
+                //if (protocolManager.Command(name).Encoded)
+                //	packet.Header.Flags |= Helpers.MSG_ZEROCODED;
+                proxy.InjectPacket(packet, direction);
+
+                SayToUser(&quot;injected &quot; + words[1]);
+            }
+            catch (Exception e)
+            {
+                SayToUser(&quot;failed to inject &quot; + words[1] + &quot;: &quot; + e.Message);
+                Console.WriteLine(&quot;failed to inject &quot; + words[1] + &quot;: &quot; + e.Message + &quot;\n&quot; + e.StackTrace);
+            }
+            finally
+            {
+                if (fs != null)
+                    fs.Close();
+                if (sr != null)
+                    sr.Close();
+            }
+        }
+    }
+
+    // SayToUser: send a message to the user as in-world chat
+    private static void SayToUser(string message)
+    {
+        ChatFromSimulatorPacket packet = new ChatFromSimulatorPacket();
+        packet.ChatData.FromName = Helpers.StringToField(&quot;Analyst&quot;);
+        packet.ChatData.SourceID = LLUUID.Random();
+        packet.ChatData.OwnerID = agentID;
+        packet.ChatData.SourceType = (byte)2;
+        packet.ChatData.ChatType = (byte)1;
+        packet.ChatData.Audible = (byte)1;
+        packet.ChatData.Position = new LLVector3(0, 0, 0);
+        packet.ChatData.Message = Helpers.StringToField(message);
+        proxy.InjectPacket(packet, Direction.Incoming);
+    }
+
+    // BlockField: product type for a block name and field name
+    private struct BlockField
+    {
+        public string block;
+        public string field;
+
+
+        public BlockField(string block, string field)
+        {
+            this.block = block;
+            this.field = field;
+        }
+    }
+
+    private static void MagicSetField(object obj, string field, object val)
+    {
+        Type cls = obj.GetType();
+
+        FieldInfo fieldInf = cls.GetField(field);
+        if (fieldInf == null)
+        {
+            PropertyInfo prop = cls.GetProperty(field);
+            if (prop == null) throw new Exception(&quot;Couldn't find field &quot; + cls.Name + &quot;.&quot; + field);
+            prop.SetValue(obj, val, null);
+            //throw new Exception(&quot;FIXME: can't set properties&quot;);
+        }
+        else
+        {
+            fieldInf.SetValue(obj, val);
+        }
+
+    }
+
+    // MagicCast: given a packet/block/field name and a string, convert the string to a value of the appropriate type
+    private static object MagicCast(string name, string block, string field, string value)
+    {
+        Type packetClass = libslAssembly.GetType(&quot;libsecondlife.Packets.&quot; + name + &quot;Packet&quot;);
+        if (packetClass == null) throw new Exception(&quot;Couldn't get class &quot; + name + &quot;Packet&quot;);
+        /*		try {
+                    packetMap = protocolManager.Command(name);
+                } catch {
+                    throw new Exception(&quot;unkown packet &quot; + name);
+                } */
+
+
+        //FIXME: support variable blocks
+
+        FieldInfo blockField = packetClass.GetField(block);
+        if (blockField == null) throw new Exception(&quot;Couldn't get &quot; + name + &quot;Packet.&quot; + block);
+        Type blockClass = blockField.FieldType;
+        if (blockClass.IsArray) blockClass = blockClass.GetElementType();
+        Console.WriteLine(&quot;DEBUG: &quot; + blockClass.Name);
+
+        FieldInfo fieldField = blockClass.GetField(field); PropertyInfo fieldProp = null;
+        Type fieldClass = null;
+        if (fieldField == null)
+        {
+            fieldProp = blockClass.GetProperty(field);
+            if (fieldProp == null) throw new Exception(&quot;Couldn't get &quot; + name + &quot;Packet.&quot; + block + &quot;.&quot; + field);
+            fieldClass = fieldProp.PropertyType;
+        }
+        else
+        {
+            fieldClass = fieldField.FieldType;
+        }
+
+        try
+        {
+            if (fieldClass == typeof(byte))
+            {
+                return Convert.ToByte(value);
+            }
+            else if (fieldClass == typeof(ushort))
+            {
+                return Convert.ToUInt16(value);
+            }
+            else if (fieldClass == typeof(uint))
+            {
+                return Convert.ToUInt32(value);
+            }
+            else if (fieldClass == typeof(ulong))
+            {
+                return Convert.ToUInt64(value);
+            }
+            else if (fieldClass == typeof(sbyte))
+            {
+                return Convert.ToSByte(value);
+            }
+            else if (fieldClass == typeof(short))
+            {
+                return Convert.ToInt16(value);
+            }
+            else if (fieldClass == typeof(int))
+            {
+                return Convert.ToInt32(value);
+            }
+            else if (fieldClass == typeof(long))
+            {
+                return Convert.ToInt64(value);
+            }
+            else if (fieldClass == typeof(float))
+            {
+                return Convert.ToSingle(value);
+            }
+            else if (fieldClass == typeof(double))
+            {
+                return Convert.ToDouble(value);
+            }
+            else if (fieldClass == typeof(LLUUID))
+            {
+                return new LLUUID(value);
+            }
+            else if (fieldClass == typeof(bool))
+            {
+                if (value.ToLower() == &quot;true&quot;)
+                    return true;
+                else if (value.ToLower() == &quot;false&quot;)
+                    return false;
+                else
+                    throw new Exception();
+            }
+            else if (fieldClass == typeof(byte[]))
+            {
+                return Helpers.StringToField(value);
+            }
+            else if (fieldClass == typeof(LLVector3))
+            {
+                Match vector3Match = (new Regex(@&quot;&lt;\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*&gt;&quot;)).Match(value);
+                if (!vector3Match.Success)
+                    throw new Exception();
+                return new LLVector3
+                    (Convert.ToSingle(vector3Match.Groups[1].Captures[0].ToString())
+                    , Convert.ToSingle(vector3Match.Groups[2].Captures[0].ToString())
+                    , Convert.ToSingle(vector3Match.Groups[3].Captures[0].ToString())
+                    );
+            }
+            else if (fieldClass == typeof(LLVector3d))
+            {
+                Match vector3dMatch = (new Regex(@&quot;&lt;\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*&gt;&quot;)).Match(value);
+                if (!vector3dMatch.Success)
+                    throw new Exception();
+                return new LLVector3d
+                    (Convert.ToDouble(vector3dMatch.Groups[1].Captures[0].ToString())
+                    , Convert.ToDouble(vector3dMatch.Groups[2].Captures[0].ToString())
+                    , Convert.ToDouble(vector3dMatch.Groups[3].Captures[0].ToString())
+                    );
+            }
+            else if (fieldClass == typeof(LLVector4))
+            {
+                Match vector4Match = (new Regex(@&quot;&lt;\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*&gt;&quot;)).Match(value);
+                if (!vector4Match.Success)
+                    throw new Exception();
+                float vector4X = Convert.ToSingle(vector4Match.Groups[1].Captures[0].ToString());
+                float vector4Y = Convert.ToSingle(vector4Match.Groups[2].Captures[0].ToString());
+                float vector4Z = Convert.ToSingle(vector4Match.Groups[3].Captures[0].ToString());
+                float vector4S = Convert.ToSingle(vector4Match.Groups[4].Captures[0].ToString());
+                byte[] vector4Bytes = new byte[16];
+                Array.Copy(BitConverter.GetBytes(vector4X), 0, vector4Bytes, 0, 4);
+                Array.Copy(BitConverter.GetBytes(vector4Y), 0, vector4Bytes, 4, 4);
+                Array.Copy(BitConverter.GetBytes(vector4Z), 0, vector4Bytes, 8, 4);
+                Array.Copy(BitConverter.GetBytes(vector4S), 0, vector4Bytes, 12, 4);
+                return new LLVector4(vector4Bytes, 0);
+            }
+            else if (fieldClass == typeof(LLQuaternion))
+            {
+                Match quaternionMatch = (new Regex(@&quot;&lt;\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*&gt;&quot;)).Match(value);
+                if (!quaternionMatch.Success)
+                    throw new Exception();
+                return new LLQuaternion
+                    (Convert.ToSingle(quaternionMatch.Groups[1].Captures[0].ToString())
+                    , Convert.ToSingle(quaternionMatch.Groups[2].Captures[0].ToString())
+                    , Convert.ToSingle(quaternionMatch.Groups[3].Captures[0].ToString())
+                    );
+            }
+            else
+            {
+                throw new Exception(&quot;unsupported field type &quot; + fieldClass);
+            }
+        }
+        catch
+        {
+            throw new Exception(&quot;unable to interpret &quot; + value + &quot; as &quot; + fieldClass);
+        }
+        /*				try {
+                            switch (fieldMap.Type) {
+                                case FieldType.LLVector3:
+                                case FieldType.IPADDR:
+                                    return IPAddress.Parse(value);
+                                case FieldType.IPPORT:
+                                    return Convert.ToUInt16(value);
+                                case FieldType.Variable:
+                                    Match match = Regex.Match(value, @&quot;^0x([0-9a-fA-F]{2})*&quot;, RegexOptions.IgnoreCase);
+                                    if (match.Success) {
+                                        byte[] buf = new byte[match.Groups[1].Captures.Count];
+                                        int i = 0;
+                                        foreach (Capture capture in match.Groups[1].Captures)
+                                            buf[i++] = Byte.Parse(capture.ToString(), NumberStyles.AllowHexSpecifier);
+                                        return buf;
+                                    } else
+                                        return value;
+                            }
+                        } catch {
+                            throw new Exception(&quot;unable to interpret &quot; + value + &quot; as &quot; + fieldMap.Type);
+                        }
 
-using SLProxy;
-using libsecondlife;
-using Nwc.XmlRpc;
-using libsecondlife.Packets;
-using System.Reflection;
+                        throw new Exception(&quot;unsupported field type &quot; + fieldMap.Type);
+                    }
 
-using System;
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System.Net;
-using System.Text.RegularExpressions;
+                    throw new Exception(&quot;unknown field &quot; + name + &quot;.&quot; + block + &quot;.&quot; + field);
+                }
 
-public class Analyst {
-	private static Proxy proxy;
-	private static Hashtable commandDelegates = new Hashtable();
-	private static Hashtable loggedPackets = new Hashtable();
-	// private static string logGrep = null;
-	private static Hashtable modifiedPackets = new Hashtable();
-	private static LLUUID agentID;
-	private static LLUUID sessionID;
-	private static bool logLogin = false;
-	private static Assembly libslAssembly;
+                throw new Exception(&quot;unknown block &quot; + name + &quot;.&quot; + block); */
+    }
+
+    // AnalyzeIn: analyze an incoming packet
+    private static Packet AnalyzeIn(Packet packet, IPEndPoint endPoint)
+    {
+        return Analyze(packet, endPoint, Direction.Incoming);
+    }
+
+    // AnalyzeOut: analyze an outgoing packet
+    private static Packet AnalyzeOut(Packet packet, IPEndPoint endPoint)
+    {
+        return Analyze(packet, endPoint, Direction.Outgoing);
+    }
+
+    // Analyze: modify and/or log a pocket
+    private static Packet Analyze(Packet packet, IPEndPoint endPoint, Direction direction)
+    {
+        if (modifiedPackets.Contains(packet.Type))
+            try
+            {
+                Hashtable changes = (Hashtable)modifiedPackets[packet.Type];
+                Type packetClass = packet.GetType();
+
+                foreach (BlockField bf in changes.Keys)
+                {
+                    //FIXME: support variable blocks
+
+                    FieldInfo blockField = packetClass.GetField(bf.block);
+                    //Type blockClass = blockField.FieldType;
+                    object blockObject = blockField.GetValue(packet);
+                    MagicSetField(blockObject, bf.field, changes[blockField]);
+                }
+            }
+            catch (Exception e)
+            {
+                Console.WriteLine(&quot;failed to modify &quot; + packet.Type + &quot;: &quot; + e.Message);
+                Console.WriteLine(e.StackTrace);
+            }
+
+        if (loggedPackets.Contains(packet.Type))
+            LogPacket(packet, endPoint, direction);
+
+        return packet;
+    }
+
+    // LogAll: register logging delegates for all packets
+    private static void LogAll()
+    {
+        Type packetTypeType = typeof(PacketType);
+        System.Reflection.MemberInfo[] packetTypes = packetTypeType.GetMembers();
+
+        for (int i = 0; i &lt; packetTypes.Length; i++)
+        {
+            if (packetTypes[i].MemberType == System.Reflection.MemberTypes.Field &amp;&amp; packetTypes[i].DeclaringType == packetTypeType)
+            {
+                string name = packetTypes[i].Name;
+                PacketType pType;
+
+                try
+                {
+                    pType = packetTypeFromName(name);
+                }
+                catch (Exception)
+                {
+                    continue;
+                }
+
+                loggedPackets[pType] = null;
+
+                if (pType != PacketType.ChatFromViewer)
+                {
+                    proxy.AddDelegate(pType, Direction.Incoming, new PacketDelegate(AnalyzeIn));
+                    proxy.AddDelegate(pType, Direction.Outgoing, new PacketDelegate(AnalyzeOut));
+                }
+            }
+        }
+    }
+
+    // NoLogAll: unregister logging delegates for all packets
+    private static void NoLogAll()
+    {
+        Type packetTypeType = typeof(PacketType);
+        System.Reflection.MemberInfo[] packetTypes = packetTypeType.GetMembers();
+
+        for (int i = 0; i &lt; packetTypes.Length; i++)
+        {
+            if (packetTypes[i].MemberType == System.Reflection.MemberTypes.Field &amp;&amp; packetTypes[i].DeclaringType == packetTypeType)
+            {
+                string name = packetTypes[i].Name;
+                PacketType pType;
+
+                try
+                {
+                    pType = packetTypeFromName(name);
+                }
+                catch (Exception)
+                {
+                    continue;
+                }
+
+                loggedPackets.Remove(pType);
+
+                if (pType != PacketType.ChatFromViewer)
+                {
+                    proxy.RemoveDelegate(pType, Direction.Incoming);
+                    proxy.RemoveDelegate(pType, Direction.Outgoing);
+                }
+            }
+        }
+    }
+
+    // LogPacket: dump a packet to the console
+    private static void LogPacket(Packet packet, IPEndPoint endPoint, Direction direction)
+    {
+        /* if (logGrep != null) {
+            bool match = false;
+            foreach (Block block in packet.Blocks())
+                foreach (Field field in block.Fields) {
+                    string value;
+                    if (field.Layout.Type == FieldType.Variable)
+                        value = DataConvert.toChoppedString(field.Data);
+                    else
+                        value = field.Data.ToString();
+                    if (Regex.Match(packet.Layout.Name + &quot;.&quot; + block.Layout.Name + &quot;.&quot; + field.Layout.Name + &quot; = &quot; + value, logGrep, RegexOptions.IgnoreCase).Success) {
+                        match = true;
+                        break;
+                    }
 
-	public static void Main(string[] args) {
-		
-		libslAssembly = Assembly.Load(&quot;libsecondlife&quot;);
-		if(libslAssembly == null) throw new Exception(&quot;Assembly load exception&quot;);
-
-		ProxyConfig proxyConfig = new ProxyConfig(&quot;Analyst V2&quot;, &quot;Austin Jennings / Andrew Ortman&quot;, args);
-		proxy = new Proxy(proxyConfig);
-
-		// build the table of /command delegates
-		InitializeCommandDelegates();
-
-		// add delegates for login
-		proxy.SetLoginRequestDelegate(new XmlRpcRequestDelegate(LoginRequest));
-		proxy.SetLoginResponseDelegate(new XmlRpcResponseDelegate(LoginResponse));
-
-		// add a delegate for outgoing chat
-		proxy.AddDelegate(PacketType.ChatFromViewer, Direction.Incoming, new PacketDelegate(ChatFromViewerIn));
-		proxy.AddDelegate(PacketType.ChatFromViewer, Direction.Outgoing, new PacketDelegate(ChatFromViewerOut));
-
-		//  handle command line arguments
-		foreach (string arg in args)
-			if (arg == &quot;--log-all&quot;)
-				LogAll();
-			else if (arg == &quot;--log-login&quot;)
-				logLogin = true;
-
-		// start the proxy
-		proxy.Start();
-	}
-
-	// LoginRequest: dump a login request to the console
-	private static void LoginRequest(XmlRpcRequest request) {
-		if (logLogin) {
-			Console.WriteLine(&quot;==&gt; Login Request&quot;);
-			Console.WriteLine(request);
-		}
-	}
-
-	// Loginresponse: dump a login response to the console
-	private static void LoginResponse(XmlRpcResponse response) {
-		Hashtable values = (Hashtable)response.Value;
-		if (values.Contains(&quot;agent_id&quot;))
-			agentID = new LLUUID((string)values[&quot;agent_id&quot;]);
-		if (values.Contains(&quot;session_id&quot;))
-			sessionID = new LLUUID((string)values[&quot;session_id&quot;]);
-
-		if (logLogin) {
-			Console.WriteLine(&quot;&lt;== Login Response&quot;);
-			Console.WriteLine(response);
-		}
-	}
-
-	// ChatFromViewerIn: incoming ChatFromViewer delegate; shouldn't be possible, but just in case...
-	private static Packet ChatFromViewerIn(Packet packet, IPEndPoint sim) {
-		if (loggedPackets.Contains(PacketType.ChatFromViewer) || modifiedPackets.Contains(PacketType.ChatFromViewer))
-			// user has asked to log or modify this packet
-			return Analyze(packet, sim, Direction.Incoming);
-		else
-			// return the packet unmodified
-			return packet;
-	}
-
-	// ChatFromViewerOut: outgoing ChatFromViewer delegate; check for Analyst commands
-	private static Packet ChatFromViewerOut(Packet packet, IPEndPoint sim) {
-		// deconstruct the packet
-		ChatFromViewerPacket cpacket = (ChatFromViewerPacket) packet;
-		string message = System.Text.Encoding.UTF8.GetString(cpacket.ChatData.Message).Replace(&quot;\0&quot;, &quot;&quot;);
-
-		if (message.Length &gt; 1 &amp;&amp; message[0] == '/') {
-			string[] words = message.Split(' ');
-			if (commandDelegates.Contains(words[0])) {
-				// this is an Analyst command; act on it and drop the chat packet
-				((CommandDelegate)commandDelegates[words[0]])(words);
-				return null;
-			}
-		}
-
-		if (loggedPackets.Contains(PacketType.ChatFromViewer) || modifiedPackets.Contains(PacketType.ChatFromViewer))
-			// user has asked to log or modify this packet
-			return Analyze(packet, sim, Direction.Outgoing);
-		else
-			// return the packet unmodified
-			return packet;
-	}
-
-	// CommandDelegate: specifies a callback delegate for a /command
-	private delegate void CommandDelegate(string[] words);
-
-	// InitializeCommandDelegates: configure Analyst's commands
-	private static void InitializeCommandDelegates() {
-		commandDelegates[&quot;/log&quot;] = new CommandDelegate(CmdLog);
-		commandDelegates[&quot;/-log&quot;] = new CommandDelegate(CmdNoLog);
-		// commandDelegates[&quot;/grep&quot;] = new CommandDelegate(CmdGrep);
-		commandDelegates[&quot;/set&quot;] = new CommandDelegate(CmdSet);
-		commandDelegates[&quot;/-set&quot;] = new CommandDelegate(CmdNoSet);
-		commandDelegates[&quot;/inject&quot;] = new CommandDelegate(CmdInject);
-		commandDelegates[&quot;/in&quot;] = new CommandDelegate(CmdInject);
-	}
-
-	private static PacketType packetTypeFromName(string name) {
-		Type packetTypeType = typeof(PacketType);
-		System.Reflection.FieldInfo f = packetTypeType.GetField(name);
-		if(f == null) throw new ArgumentException(&quot;Bad packet type&quot;);
-		return (PacketType)Enum.ToObject(packetTypeType, (int)f.GetValue(packetTypeType));
-	}
-
-	// CmdLog: handle a /log command
-	private static void CmdLog(string[] words) {
-		if (words.Length != 2)
-			SayToUser(&quot;Usage: /log &lt;packet name&gt;&quot;);
-		else if (words[1] == &quot;*&quot;) {
-			LogAll();
-			SayToUser(&quot;logging all packets&quot;);
-		} else {
-			PacketType pType;
-			try {
-				pType = packetTypeFromName(words[1]);
-			} catch(ArgumentException e) {
-				SayToUser(&quot;Bad packet name: &quot;+words[1]);
-				return;
-			}
-			loggedPackets[pType] = null;
-			if (words[1] != &quot;ChatFromViewer&quot;) {
-				proxy.AddDelegate(pType, Direction.Incoming, new PacketDelegate(AnalyzeIn));
-				proxy.AddDelegate(pType, Direction.Outgoing, new PacketDelegate(AnalyzeOut));
-			}
-			SayToUser(&quot;logging &quot; + words[1]);
-		}
-	}
-
-	// CmdNoLog: handle a /-log command
-	private static void CmdNoLog(string[] words) {
-		if (words.Length != 2)
-			SayToUser(&quot;Usage: /-log &lt;packet name&gt;&quot;);
-		else if (words[1] == &quot;*&quot;) {
-			NoLogAll();
-			SayToUser(&quot;stopped logging all packets&quot;);
-		} else {
-			PacketType pType = packetTypeFromName(words[1]);
-			loggedPackets.Remove(pType);
-
-			if (!modifiedPackets.Contains(words[1])) {
-				if (words[1] != &quot;ChatFromViewer&quot;) {
-					proxy.RemoveDelegate(pType, Direction.Incoming);
-					proxy.RemoveDelegate(pType, Direction.Outgoing);
-				}
-			}
-
-			SayToUser(&quot;stopped logging &quot; + words[1]);
-		}
-	}
-
-/*	// CmdGrep: handle a /grep command
-	private static void CmdGrep(string[] words) {
-		if (words.Length == 1) {
-			logGrep = null;
-			SayToUser(&quot;stopped filtering logs&quot;);
-		} else {
-			string[] regexArray = new string[words.Length - 1];
-			Array.Copy(words, 1, regexArray, 0, words.Length - 1);
-			logGrep = String.Join(&quot; &quot;, regexArray);
-			SayToUser(&quot;filtering log with &quot; + logGrep);
-		}
-	} */
-
-	// CmdSet: handle a /set command
-	private static void CmdSet(string[] words) {
-		if (words.Length &lt; 5)
-			SayToUser(&quot;Usage: /set &lt;packet name&gt; &lt;block&gt; &lt;field&gt; &lt;value&gt;&quot;);
-		else {
-			PacketType pType;
-			try {
-				pType = packetTypeFromName(words[1]);
-			} catch(ArgumentException e) {
-				SayToUser(&quot;Bad packet name: &quot;+words[1]);
-				return;
-			}
-
-			string[] valueArray = new string[words.Length - 4];
-			Array.Copy(words, 4, valueArray, 0, words.Length - 4);
-			string valueString = String.Join(&quot; &quot;, valueArray);
-			object value;
-			try {
-				value = MagicCast(words[1], words[2], words[3], valueString);
-			} catch (Exception e) {
-				SayToUser(e.Message);
-				return;
-			}
-
-			Hashtable fields;
-			if (modifiedPackets.Contains(pType))
-				fields = (Hashtable)modifiedPackets[pType];
-			else
-				fields = new Hashtable();
-
-			fields[new BlockField(words[2], words[3])] = value;
-			modifiedPackets[pType] = fields;
-
-			if (words[1] != &quot;ChatFromViewer&quot;) {
-				proxy.AddDelegate(pType, Direction.Incoming, new PacketDelegate(AnalyzeIn));
-				proxy.AddDelegate(pType, Direction.Outgoing, new PacketDelegate(AnalyzeOut));
-			}
-
-			SayToUser(&quot;setting &quot; + words[1] + &quot;.&quot; + words[2] + &quot;.&quot; + words[3] + &quot; = &quot; + valueString);
-		}
-	}
-
-	// CmdNoSet: handle a /-set command
-	private static void CmdNoSet(string[] words) {
-		if (words.Length == 2 &amp;&amp; words[1] == &quot;*&quot;) {
-			foreach (PacketType pType in modifiedPackets.Keys)
-				if (!loggedPackets.Contains(pType) &amp;&amp; pType != PacketType.ChatFromViewer) {
-					proxy.RemoveDelegate(pType, Direction.Incoming);
-					proxy.RemoveDelegate(pType, Direction.Outgoing);
-				}
-			modifiedPackets = new Hashtable();
-
-			SayToUser(&quot;stopped setting all fields&quot;);
-		} else if (words.Length == 4) {
-			PacketType pType;
-			try {
-				pType = packetTypeFromName(words[1]);
-			} catch(ArgumentException e) {
-				SayToUser(&quot;Bad packet name: &quot;+words[1]);
-				return;
-			}
-
-
-			if (modifiedPackets.Contains(pType)) {
-				Hashtable fields = (Hashtable)modifiedPackets[pType];
-				fields.Remove(new BlockField(words[2], words[3]));
-
-				if (fields.Count == 0) {
-					modifiedPackets.Remove(pType);
-
-					if (!loggedPackets.Contains(pType)) {
-						if (words[1] != &quot;ChatFromViewer&quot;) {
-							proxy.RemoveDelegate(pType, Direction.Incoming);
-							proxy.RemoveDelegate(pType, Direction.Outgoing);
-						}
-					}
-				}
-			}
-
-			SayToUser(&quot;stopped setting &quot; + words[1] + &quot;.&quot; + words[2] + &quot;.&quot; + words[3]);
-		} else
-			SayToUser(&quot;Usage: /-set &lt;packet name&gt; &lt;block&gt; &lt;field&gt;&quot;);
-	} 
-
-
-	// CmdInject: handle an /inject command
-	private static void CmdInject(string[] words) {
-		if (words.Length &lt; 2)
-			SayToUser(&quot;Usage: /inject &lt;packet file&gt; [value]&quot;);
-		else {
-			string[] valueArray = new string[words.Length - 2];
-			Array.Copy(words, 2, valueArray, 0, words.Length - 2);
-			string value = String.Join(&quot; &quot;, valueArray);
-
-			FileStream fs = null;
-			StreamReader sr = null;
-			Direction direction = Direction.Incoming;
-			string name = null;
-			//Hashtable blocks = new Hashtable();
-			string block = null;
-			object blockObj = null;
-			//Hashtable fields = new Hashtable();
-			Type packetClass = null;
-			Packet packet = null;
-
-			try {
-				fs = File.OpenRead(words[1] + &quot;.packet&quot;);
-				sr = new StreamReader(fs);
-
-				string line;
-				while ((line = sr.ReadLine()) != null) {
-					Match match;
-
-					if (name == null) {
-						match = (new Regex(@&quot;^\s*(in|out)\s+(\w+)\s*$&quot;)).Match(line);
-						if (!match.Success) {
-							SayToUser(&quot;expecting direction and packet name, got: &quot; + line);
-							return;
-						}
-
-						string lineDir = match.Groups[1].Captures[0].ToString();
-						string lineName = match.Groups[2].Captures[0].ToString();
-
-						if (lineDir == &quot;in&quot;)
-							direction = Direction.Incoming;
-						else if (lineDir == &quot;out&quot;)
-							direction = Direction.Outgoing;
-						else {
-							SayToUser(&quot;expecting 'in' or 'out', got: &quot; + line);
-							return;
-						}
-
-						name = lineName;
-						packetClass = libslAssembly.GetType(&quot;libsecondlife.Packets.&quot;+name+&quot;Packet&quot;);
-						if(packetClass == null) throw new Exception(&quot;Couldn't get class &quot;+name+&quot;Packet&quot;);
-						ConstructorInfo ctr = packetClass.GetConstructor(new Type[] { });
-						if(ctr == null) throw new Exception(&quot;Couldn't get suitable constructor for &quot;+name+&quot;Packet&quot;);
-						packet = (Packet) ctr.Invoke(new object[] { });
-						Console.WriteLine(&quot;Created new &quot;+name+&quot;Packet&quot;);
-					} else {
-						match = (new Regex(@&quot;^\s*\[(\w+)\]\s*$&quot;)).Match(line);
-						if (match.Success) {
-							//FIXME: support variable blocks
-
-							block = match.Groups[1].Captures[0].ToString();
-							FieldInfo blockField = packetClass.GetField(block);
-							if(blockField == null) throw new Exception(&quot;Couldn't get &quot;+name+&quot;Packet.&quot;+block);
-							blockObj = blockField.GetValue(packet);
-							if(blockObj == null) throw new Exception(&quot;Got &quot;+name+&quot;Packet.&quot;+block+&quot; == null&quot;);
-							Console.WriteLine(&quot;Got block &quot;+name+&quot;Packet.&quot;+block);
-
-							continue;
-						}
-
-						if (block == null) {
-							SayToUser(&quot;expecting block name, got: &quot; + line);
-							return;
-						}
-
-						match = (new Regex(@&quot;^\s*(\w+)\s*=\s*(.*)$&quot;)).Match(line);
-						if (match.Success) {
-							string lineField = match.Groups[1].Captures[0].ToString();
-							string lineValue = match.Groups[2].Captures[0].ToString();
-							object fval;
-
-							//FIXME: use of MagicCast inefficient
-							if (lineValue == &quot;$Value&quot;)
-								fval = MagicCast(name, block, lineField, value);
-							else if (lineValue == &quot;$UUID&quot;)
-								fval = LLUUID.Random();
-							else if (lineValue == &quot;$AgentID&quot;)
-								fval = agentID;
-							else if (lineValue == &quot;$SessionID&quot;)
-								fval = sessionID;
-							else
-								fval = MagicCast(name, block, lineField, lineValue);
-
-							MagicSetField(blockObj,lineField,fval);
-							continue;
-						}
-
-						SayToUser(&quot;expecting block name or field, got: &quot; + line);
-						return;
-					}
-				}
-
-				if (name == null) {
-					SayToUser(&quot;expecting direction and packet name, got EOF&quot;);
-					return;
-				}
-
-				packet.Header.Flags |= Helpers.MSG_RELIABLE;
-				//if (protocolManager.Command(name).Encoded)
-				//	packet.Header.Flags |= Helpers.MSG_ZEROCODED;
-				proxy.InjectPacket(packet, direction);
-
-				SayToUser(&quot;injected &quot; + words[1]);
-			} catch (Exception e) {
-				SayToUser(&quot;failed to inject &quot; + words[1] + &quot;: &quot; + e.Message);
-				Console.WriteLine(&quot;failed to inject &quot; + words[1] + &quot;: &quot; + e.Message + &quot;\n&quot; + e.StackTrace);
-			} finally {
-				if (fs != null)
-					fs.Close();
-				if (sr != null)
-					sr.Close();
-			}
-		}
-	}
-
-	// SayToUser: send a message to the user as in-world chat
-	private static void SayToUser(string message) {
-		ChatFromSimulatorPacket packet = new ChatFromSimulatorPacket();
-		packet.ChatData.FromName = Helpers.StringToField(&quot;Analyst&quot;);
-		packet.ChatData.SourceID = LLUUID.Random();
-		packet.ChatData.OwnerID = agentID;
-		packet.ChatData.SourceType = (byte)2;
-		packet.ChatData.ChatType = (byte)1;
-		packet.ChatData.Audible = (byte)1;
-		packet.ChatData.Position = new LLVector3(0, 0, 0);
-		packet.ChatData.Message = Helpers.StringToField(message);
-		proxy.InjectPacket(packet, Direction.Incoming);
-	}
-
-	// BlockField: product type for a block name and field name
-	private struct BlockField {
-		public string block;
-		public string field;
-		
-
-		public BlockField(string block, string field) {
-			this.block = block;
-			this.field = field;
-		}
-	}
-
-	private static void MagicSetField(object obj, string field, object val) {
-		Type cls = obj.GetType();
-
-		FieldInfo fieldInf = cls.GetField(field);
-		if(fieldInf == null) {
-			PropertyInfo prop = cls.GetProperty(field);
-			if(prop == null) throw new Exception(&quot;Couldn't find field &quot;+cls.Name+&quot;.&quot;+field);
-			prop.SetValue(obj,val,null);
-			//throw new Exception(&quot;FIXME: can't set properties&quot;);
-		} else {
-			fieldInf.SetValue(obj,val);
-		}
-		
-	}
-
-	// MagicCast: given a packet/block/field name and a string, convert the string to a value of the appropriate type
-	private static object MagicCast(string name, string block, string field, string value) {
-		Type packetClass = libslAssembly.GetType(&quot;libsecondlife.Packets.&quot;+name+&quot;Packet&quot;);
-		if(packetClass == null) throw new Exception(&quot;Couldn't get class &quot;+name+&quot;Packet&quot;);
-/*		try {
-			packetMap = protocolManager.Command(name);
-		} catch {
-			throw new Exception(&quot;unkown packet &quot; + name);
-		} */
-
-
-		//FIXME: support variable blocks
-
-		FieldInfo blockField = packetClass.GetField(block);
-		if(blockField == null) throw new Exception(&quot;Couldn't get &quot;+name+&quot;Packet.&quot;+block);
-		Type blockClass = blockField.FieldType;
-		if(blockClass.IsArray) blockClass = blockClass.GetElementType();
-		Console.WriteLine(&quot;DEBUG: &quot;+blockClass.Name);
-
-		FieldInfo fieldField = blockClass.GetField(field); PropertyInfo fieldProp = null;
-		Type fieldClass = null;
-		if(fieldField == null) {
-			fieldProp = blockClass.GetProperty(field);
-			if(fieldProp == null) throw new Exception(&quot;Couldn't get &quot;+name+&quot;Packet.&quot;+block+&quot;.&quot;+field);
-			fieldClass = fieldProp.PropertyType;
-		} else {
-			fieldClass = fieldField.FieldType;
-		}
-		
-		try {
-			if(fieldClass == typeof(byte)) {
-				return Convert.ToByte(value);
-			} else if(fieldClass == typeof(ushort)) {
-				return Convert.ToUInt16(value);
-			} else if(fieldClass == typeof(uint)) {
-				return Convert.ToUInt32(value);
-			} else if(fieldClass == typeof(ulong)) {
-				return Convert.ToUInt64(value);
-			} else if(fieldClass == typeof(sbyte)) {
-				return Convert.ToSByte(value);
-			} else if(fieldClass == typeof(short)) {
-				return Convert.ToInt16(value);
-			} else if(fieldClass == typeof(int)) {
-				return Convert.ToInt32(value);
-			} else if(fieldClass == typeof(long)) {
-				return Convert.ToInt64(value);
-			} else if(fieldClass == typeof(float)) {
-				return Convert.ToSingle(value);
-			} else if(fieldClass == typeof(double)) {
-				return Convert.ToDouble(value);
-			} else if(fieldClass == typeof(LLUUID)) {
-				return new LLUUID(value);
-			} else if(fieldClass == typeof(bool)) {
-				if (value.ToLower() == &quot;true&quot;)
-					return true;
-				else if (value.ToLower() == &quot;false&quot;)
-					return false;
-				else
-					throw new Exception();
-			} else if(fieldClass == typeof(byte[])) {
-				return Helpers.StringToField(value);
-			} else if(fieldClass == typeof(LLVector3)) {
-				Match vector3Match = (new Regex(@&quot;&lt;\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*&gt;&quot;)).Match(value);
-				if (!vector3Match.Success)
-					throw new Exception();
-				return new LLVector3
-					(Convert.ToSingle(vector3Match.Groups[1].Captures[0].ToString())
-					,Convert.ToSingle(vector3Match.Groups[2].Captures[0].ToString())
-					,Convert.ToSingle(vector3Match.Groups[3].Captures[0].ToString())
-					);
-			} else if(fieldClass == typeof(LLVector3d)) {
-				Match vector3dMatch = (new Regex(@&quot;&lt;\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*&gt;&quot;)).Match(value);
-				if (!vector3dMatch.Success)
-					throw new Exception();
-				return new LLVector3d
-					(Convert.ToDouble(vector3dMatch.Groups[1].Captures[0].ToString())
-					,Convert.ToDouble(vector3dMatch.Groups[2].Captures[0].ToString())
-					,Convert.ToDouble(vector3dMatch.Groups[3].Captures[0].ToString())
-					);
-			} else if(fieldClass == typeof(LLVector4)) {
-				Match vector4Match = (new Regex(@&quot;&lt;\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*&gt;&quot;)).Match(value);
-				if (!vector4Match.Success)
-					throw new Exception();
-				float vector4X = Convert.ToSingle(vector4Match.Groups[1].Captures[0].ToString());
-				float vector4Y = Convert.ToSingle(vector4Match.Groups[2].Captures[0].ToString());
-				float vector4Z = Convert.ToSingle(vector4Match.Groups[3].Captures[0].ToString());
-				float vector4S = Convert.ToSingle(vector4Match.Groups[4].Captures[0].ToString());
-				byte[] vector4Bytes = new byte[16];
-				Array.Copy(BitConverter.GetBytes(vector4X), 0, vector4Bytes,  0, 4);
-				Array.Copy(BitConverter.GetBytes(vector4Y), 0, vector4Bytes,  4, 4);
-				Array.Copy(BitConverter.GetBytes(vector4Z), 0, vector4Bytes,  8, 4);
-				Array.Copy(BitConverter.GetBytes(vector4S), 0, vector4Bytes, 12, 4);
-				return new LLVector4(vector4Bytes, 0);
-			} else if(fieldClass == typeof(LLQuaternion)) {
-				Match quaternionMatch = (new Regex(@&quot;&lt;\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*,\s*(-?[0-9.]+)\s*&gt;&quot;)).Match(value);
-				if (!quaternionMatch.Success)
-					throw new Exception();
-				return new LLQuaternion
-					(Convert.ToSingle(quaternionMatch.Groups[1].Captures[0].ToString())
-					,Convert.ToSingle(quaternionMatch.Groups[2].Captures[0].ToString())
-					,Convert.ToSingle(quaternionMatch.Groups[3].Captures[0].ToString())
-					);
-			} else {
-				throw new Exception(&quot;unsupported field type &quot; + fieldClass);
-			}
-		} catch {
-			throw new Exception(&quot;unable to interpret &quot; + value + &quot; as &quot; + fieldClass);
-		}
-/*				try {
-					switch (fieldMap.Type) {
-						case FieldType.LLVector3:
-						case FieldType.IPADDR:
-							return IPAddress.Parse(value);
-						case FieldType.IPPORT:
-							return Convert.ToUInt16(value);
-						case FieldType.Variable:
-							Match match = Regex.Match(value, @&quot;^0x([0-9a-fA-F]{2})*&quot;, RegexOptions.IgnoreCase);
-							if (match.Success) {
-								byte[] buf = new byte[match.Groups[1].Captures.Count];
-								int i = 0;
-								foreach (Capture capture in match.Groups[1].Captures)
-									buf[i++] = Byte.Parse(capture.ToString(), NumberStyles.AllowHexSpecifier);
-								return buf;
-							} else
-								return value;
-					}
-				} catch {
-					throw new Exception(&quot;unable to interpret &quot; + value + &quot; as &quot; + fieldMap.Type);
-				}
-
-				throw new Exception(&quot;unsupported field type &quot; + fieldMap.Type);
-			}
-
-			throw new Exception(&quot;unknown field &quot; + name + &quot;.&quot; + block + &quot;.&quot; + field);
-		}
-
-		throw new Exception(&quot;unknown block &quot; + name + &quot;.&quot; + block); */
-	}
-
-	// AnalyzeIn: analyze an incoming packet
-	private static Packet AnalyzeIn(Packet packet, IPEndPoint endPoint) {
-		return Analyze(packet, endPoint, Direction.Incoming);
-	}
-
-	// AnalyzeOut: analyze an outgoing packet
-	private static Packet AnalyzeOut(Packet packet, IPEndPoint endPoint) {
-		return Analyze(packet, endPoint, Direction.Outgoing);
-	}
-
-	// Analyze: modify and/or log a pocket
-	private static Packet Analyze(Packet packet, IPEndPoint endPoint, Direction direction) {
-		if (modifiedPackets.Contains(packet.Type))
-			try {
-				Hashtable changes = (Hashtable)modifiedPackets[packet.Type];
-				Type packetClass = packet.GetType();
-	
-				foreach (BlockField bf in changes.Keys) {
-					//FIXME: support variable blocks
-
-					FieldInfo blockField = packetClass.GetField(bf.block);
-					//Type blockClass = blockField.FieldType;
-					object blockObject = blockField.GetValue(packet);
-					MagicSetField(blockObject,bf.field,changes[blockField]);
-				}
-			} catch (Exception e) {
-				Console.WriteLine(&quot;failed to modify &quot; + packet.Type + &quot;: &quot; + e.Message);
-				Console.WriteLine(e.StackTrace);
-			}
-
-		if (loggedPackets.Contains(packet.Type))
-			LogPacket(packet, endPoint, direction);
-
-		return packet;
-	}
-
-	// LogAll: register logging delegates for all packets
-	private static void LogAll() {
-		Type packetTypeType = typeof(PacketType);
-		System.Reflection.MemberInfo[] packetTypes =  packetTypeType.GetMembers();
-		
-		for(int i = 0; i &lt; packetTypes.Length; i++) {
-			if(packetTypes[i].MemberType == System.Reflection.MemberTypes.Field &amp;&amp; packetTypes[i].DeclaringType == packetTypeType) {
-				string name = packetTypes[i].Name;
-				PacketType pType = packetTypeFromName(name);
-				loggedPackets[pType] = null;
-				if (name != &quot;ChatFromViewer&quot;) {
-					proxy.AddDelegate(pType, Direction.Incoming, new PacketDelegate(AnalyzeIn));
-					proxy.AddDelegate(pType, Direction.Outgoing, new PacketDelegate(AnalyzeOut));
-				}
-			}
-		}
-	}
-
-	// NoLogAll: unregister logging delegates for all packets
-	private static void NoLogAll() {
-		Type packetTypeType = typeof(PacketType);
-		System.Reflection.MemberInfo[] packetTypes =  packetTypeType.GetMembers();
-		
-		for(int i = 0; i &lt; packetTypes.Length; i++) {
-			if(packetTypes[i].MemberType == System.Reflection.MemberTypes.Field  &amp;&amp; packetTypes[i].DeclaringType == packetTypeType) {
-				string name = packetTypes[i].Name;
-				PacketType pType = packetTypeFromName(name);
-				loggedPackets.Remove(pType);
-				if (name != &quot;ChatFromViewer&quot;) {
-					proxy.RemoveDelegate(pType, Direction.Incoming);
-					proxy.RemoveDelegate(pType, Direction.Outgoing);
-				}
-			}
-		}
-	}
-
-	// LogPacket: dump a packet to the console
-	private static void LogPacket(Packet packet, IPEndPoint endPoint, Direction direction) {
-		/* if (logGrep != null) {
-			bool match = false;
-			foreach (Block block in packet.Blocks())
-				foreach (Field field in block.Fields) {
-					string value;
-					if (field.Layout.Type == FieldType.Variable)
-						value = DataConvert.toChoppedString(field.Data);
-					else
-						value = field.Data.ToString();
-					if (Regex.Match(packet.Layout.Name + &quot;.&quot; + block.Layout.Name + &quot;.&quot; + field.Layout.Name + &quot; = &quot; + value, logGrep, RegexOptions.IgnoreCase).Success) {
-						match = true;
-						break;
-					}
-
-					// try matching variable fields in 0x notation
-					if (field.Layout.Type == FieldType.Variable) {
-						StringWriter sw = new StringWriter();
-						sw.Write(&quot;0x&quot;);
-						foreach (byte b in (byte[])field.Data)
-							sw.Write(&quot;{0:x2}&quot;, b);
-						if (Regex.Match(packet.Layout.Name + &quot;.&quot; + block.Layout.Name + &quot;.&quot; + field.Layout.Name + &quot; = &quot; + sw, logGrep, RegexOptions.IgnoreCase).Success) {
-							match = true;
-							break;
-						}
-					}
-				}
-			if (!match)
-				return;
-		} */
-
-		Console.WriteLine(&quot;{0} {1,21} {2,5} {3}{4}{5}&quot;
-				 ,direction == Direction.Incoming ? &quot;&lt;--&quot; : &quot;--&gt;&quot;
-				 ,endPoint
-				 ,packet.Header.Sequence
-				 ,InterpretOptions(packet.Header.Flags)
-				 ,Environment.NewLine
-				 ,packet
-				 );
-	}
-
-	// InterpretOptions: produce a string representing a packet's header options
-	private static string InterpretOptions(byte options) {
-		return &quot;[&quot;
-		     + ((options &amp; Helpers.MSG_APPENDED_ACKS) != 0 ? &quot;Ack&quot; : &quot;   &quot;)
-		     + &quot; &quot;
-		     + ((options &amp; Helpers.MSG_RESENT)        != 0 ? &quot;Res&quot; : &quot;   &quot;)
-		     + &quot; &quot;
-		     + ((options &amp; Helpers.MSG_RELIABLE)      != 0 ? &quot;Rel&quot; : &quot;   &quot;)
-		     + &quot; &quot;
-		     + ((options &amp; Helpers.MSG_ZEROCODED)     != 0 ? &quot;Zer&quot; : &quot;   &quot;)
-		     + &quot;]&quot;
-		     ;
-	}
-}
+                    // try matching variable fields in 0x notation
+                    if (field.Layout.Type == FieldType.Variable) {
+                        StringWriter sw = new StringWriter();
+                        sw.Write(&quot;0x&quot;);
+                        foreach (byte b in (byte[])field.Data)
+                            sw.Write(&quot;{0:x2}&quot;, b);
+                        if (Regex.Match(packet.Layout.Name + &quot;.&quot; + block.Layout.Name + &quot;.&quot; + field.Layout.Name + &quot; = &quot; + sw, logGrep, RegexOptions.IgnoreCase).Success) {
+                            match = true;
+                            break;
+                        }
+                    }
+                }
+            if (!match)
+                return;
+        } */
+
+        Console.WriteLine(&quot;{0} {1,21} {2,5} {3}{4}{5}&quot;
+                 , direction == Direction.Incoming ? &quot;&lt;--&quot; : &quot;--&gt;&quot;
+                 , endPoint
+                 , packet.Header.Sequence
+                 , InterpretOptions(packet.Header.Flags)
+                 , Environment.NewLine
+                 , packet
+                 );
+    }
+
+    // InterpretOptions: produce a string representing a packet's header options
+    private static string InterpretOptions(byte options)
+    {
+        return &quot;[&quot;
+             + ((options &amp; Helpers.MSG_APPENDED_ACKS) != 0 ? &quot;Ack&quot; : &quot;   &quot;)
+             + &quot; &quot;
+             + ((options &amp; Helpers.MSG_RESENT) != 0 ? &quot;Res&quot; : &quot;   &quot;)
+             + &quot; &quot;
+             + ((options &amp; Helpers.MSG_RELIABLE) != 0 ? &quot;Rel&quot; : &quot;   &quot;)
+             + &quot; &quot;
+             + ((options &amp; Helpers.MSG_ZEROCODED) != 0 ? &quot;Zer&quot; : &quot;   &quot;)
+             + &quot;]&quot;
+             ;
+    }
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000124.html">[Libsecondlife-commits] r756 - in trunk: . applications
</A></li>
	<LI>Next message: <A HREF="000127.html">[Libsecondlife-commits] r758 - trunk/SLProxy
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#126">[ date ]</a>
              <a href="thread.html#126">[ thread ]</a>
              <a href="subject.html#126">[ subject ]</a>
              <a href="author.html#126">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">More information about the Libsecondlife-commits
mailing list</a><br>
</body></html>
