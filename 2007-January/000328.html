<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Libsecondlife-commits] r902 - in trunk/libsecondlife-cs: .	InventorySystem examples/IA_SimpleInventory examples/Teleport	examples/TestClient examples/TestClient/Commands	examples/TestClient/Commands/Inventory libsecondlife.Tests	libsecondlife.Utilities
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/libsecondlife-commits/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r902%20-%20in%20trunk/libsecondlife-cs%3A%20.%0A%09InventorySystem%20examples/IA_SimpleInventory%20examples/Teleport%0A%09examples/TestClient%20examples/TestClient/Commands%0A%09examples/TestClient/Commands/Inventory%20libsecondlife.Tests%0A%09libsecondlife.Utilities&In-Reply-To=%3C20070125131002.EDE9CC1819B%40opensecondlife.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000327.html">
   <LINK REL="Next"  HREF="000329.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Libsecondlife-commits] r902 - in trunk/libsecondlife-cs: .	InventorySystem examples/IA_SimpleInventory examples/Teleport	examples/TestClient examples/TestClient/Commands	examples/TestClient/Commands/Inventory libsecondlife.Tests	libsecondlife.Utilities</H1>
    <B>jhurliman at libsecondlife.org</B> 
    <A HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r902%20-%20in%20trunk/libsecondlife-cs%3A%20.%0A%09InventorySystem%20examples/IA_SimpleInventory%20examples/Teleport%0A%09examples/TestClient%20examples/TestClient/Commands%0A%09examples/TestClient/Commands/Inventory%20libsecondlife.Tests%0A%09libsecondlife.Utilities&In-Reply-To=%3C20070125131002.EDE9CC1819B%40opensecondlife.org%3E"
       TITLE="[Libsecondlife-commits] r902 - in trunk/libsecondlife-cs: .	InventorySystem examples/IA_SimpleInventory examples/Teleport	examples/TestClient examples/TestClient/Commands	examples/TestClient/Commands/Inventory libsecondlife.Tests	libsecondlife.Utilities">jhurliman at libsecondlife.org
       </A><BR>
    <I>Thu Jan 25 14:02:20 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000327.html">[Libsecondlife-commits] r893 - trunk
</A></li>
        <LI>Next message: <A HREF="000329.html">[Libsecondlife-commits] r904 - branches/stable
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#328">[ date ]</a>
              <a href="thread.html#328">[ thread ]</a>
              <a href="subject.html#328">[ subject ]</a>
              <a href="author.html#328">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jhurliman
Date: 2007-01-25 05:02:20 -0800 (Thu, 25 Jan 2007)
New Revision: 902

Modified:
   trunk/libsecondlife-cs/AvatarManager.cs
   trunk/libsecondlife-cs/InventorySystem/InventoryManager.cs
   trunk/libsecondlife-cs/MainAvatar.cs
   trunk/libsecondlife-cs/NetworkManager.cs
   trunk/libsecondlife-cs/SecondLife.cs
   trunk/libsecondlife-cs/Settings.cs
   trunk/libsecondlife-cs/examples/IA_SimpleInventory/IA_SimpleInventory.cs
   trunk/libsecondlife-cs/examples/Teleport/Teleport.cs
   trunk/libsecondlife-cs/examples/TestClient/Commands/DebugCommand.cs
   trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/DeleteFolderCommand.cs
   trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/InventoryCommand.cs
   trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/WearCommand.cs
   trunk/libsecondlife-cs/examples/TestClient/TestClient.cs
   trunk/libsecondlife-cs/libsecondlife.Tests/NetworkTests.cs
   trunk/libsecondlife-cs/libsecondlife.Utilities/Appearance.cs
   trunk/libsecondlife-cs/libsecondlife.Utilities/Assets.cs
   trunk/libsecondlife-cs/libsecondlife.Utilities/Utilities.cs
   trunk/libsecondlife-cs/libsecondlife.sln
Log:
* Moved ViewerEffect handling to AvatarManager
* Reworked the teleport system to get rid of bad Tick and Sleep calls and clean up callback confusion
* Removed the DownloadInventory() command and replaced all usage of it with fixme notes as it was found to be potentially dangerous to simulators
* Updated the VS2005 solution file with openjpegnet and VisualParamGenerator
* Removed a Sleep call from NetworkManager
* Moved SecondLife.Debug boolean to SecondLife.Settings.Debug

Modified: trunk/libsecondlife-cs/AvatarManager.cs
===================================================================
--- trunk/libsecondlife-cs/AvatarManager.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/AvatarManager.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -118,6 +118,9 @@
             // Avatar group callback
             Client.Network.RegisterCallback(PacketType.AvatarGroupsReply, new NetworkManager.PacketCallback(AvatarGroupsHandler));
 
+            // Viewer effect callback
+            Client.Network.RegisterCallback(PacketType.ViewerEffect, new NetworkManager.PacketCallback(ViewerEffectHandler));
+
             // Other callbacks
             Client.Network.RegisterCallback(PacketType.UUIDNameReply, new NetworkManager.PacketCallback(AvatarNameHandler));
             Client.Network.RegisterCallback(PacketType.AvatarPickerReply, new NetworkManager.PacketCallback(AvatarPickerReplyHandler));
@@ -354,5 +357,117 @@
                 OnAvatarNameSearch(reply.AgentData.QueryID, avatars);
             }
         }
+
+        /// &lt;summary&gt;
+        /// Process an incoming effect
+        /// &lt;/summary&gt;
+        private void ViewerEffectHandler(Packet packet, Simulator simulator)
+        {
+            ViewerEffectPacket effect = (ViewerEffectPacket)packet;
+
+            foreach (ViewerEffectPacket.EffectBlock block in effect.Effect)
+            {
+                MainAvatar.EffectType type;
+
+                try
+                {
+                    type = (MainAvatar.EffectType)block.Type;
+                }
+                catch (Exception)
+                {
+                    Client.Log(&quot;Received a ViewerEffect block with an unknown type &quot; + block.Type,
+                        Helpers.LogLevel.Warning);
+                    continue;
+                }
+
+                //LLColor color;
+                //if (block.Color.Length == 4)
+                //{
+                //    color = new LLColor(block.Color, 0);
+                //}
+                //else
+                //{
+                //    Client.Log(&quot;Received a ViewerEffect.EffectBlock.Color array with &quot; + block.Color.Length + &quot; bytes&quot;,
+                //        Helpers.LogLevel.Warning);
+                //    color = new LLColor();
+                //}
+
+                // Each ViewerEffect type uses it's own custom binary format for additional data. Fun eh?
+                switch (type)
+                {
+                    case MainAvatar.EffectType.Text:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.Icon:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.Connector:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.FlexibleObject:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.AnimalControls:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.AnimationObject:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.Cloth:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.Beam:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.Glow:
+                        Client.Log(&quot;Received a Glow ViewerEffect which is not implemented yet&quot;,
+                            Helpers.LogLevel.Warning);
+                        break;
+                    case MainAvatar.EffectType.Point:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.Trail:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.Sphere:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.Spiral:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.Edit:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.LookAt:
+                        //Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case MainAvatar.EffectType.PointAt:
+                        if (block.TypeData.Length == 57)
+                        {
+                            LLUUID sourceAvatar = new LLUUID(block.TypeData, 0);
+                            LLUUID targetObject = new LLUUID(block.TypeData, 16);
+                            LLVector3d targetPos = new LLVector3d(block.TypeData, 32);
+                            MainAvatar.PointAtType pointAt;
+                            try
+                            {
+                                pointAt = (MainAvatar.PointAtType)block.TypeData[56];
+                            }
+                            catch (Exception)
+                            {
+                                Client.Log(&quot;Unrecognized PointAtType &quot; + block.TypeData[56], Helpers.LogLevel.Warning);
+                                pointAt = MainAvatar.PointAtType.Clear;
+                            }
+
+                            // TODO: Create a OnAvatarPointAt event and call it here
+                        }
+                        else
+                        {
+                            Client.Log(&quot;Received a PointAt ViewerEffect with an incorrect TypeData size of &quot; +
+                                block.TypeData.Length + &quot; bytes&quot;, Helpers.LogLevel.Warning);
+                        }
+                        break;
+                }
+            }
+        }
     }
 }

Modified: trunk/libsecondlife-cs/InventorySystem/InventoryManager.cs
===================================================================
--- trunk/libsecondlife-cs/InventorySystem/InventoryManager.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/InventorySystem/InventoryManager.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -656,77 +656,6 @@
             slClient.Network.SendPacket(packet);
         }
 
-        /// &lt;summary&gt;
-        /// Downloads your entire inventory structure.
-        /// &lt;/summary&gt;
-        /// &lt;remarks&gt;Not recommended!  This can take a long time for larger downloads and is subject to timeouts&lt;/remarks&gt;
-        [Obsolete(&quot;This is a big nasty evil blocking function that you shouldn't use any more.&quot;)]
-        public void DownloadInventory()
-        {
-            ClearState();
-
-            if (FolderDownloadStatus == null)
-            {
-                // Create status table
-                FolderDownloadStatus = new Dictionary&lt;LLUUID, DownloadRequest_Folder&gt;();
-            }
-            else
-            {
-                if (FolderDownloadStatus.Count != 0)
-                {
-                    throw new Exception(&quot;Inventory Download requested while previous download in progress.&quot;);
-                }
-            }
-
-            if (alFolderRequestQueue == null)
-            {
-                alFolderRequestQueue = new List&lt;DownloadRequest_Folder&gt;();
-            }
-
-            // Set last packet received to now, just so out time-out timer works
-            LastPacketRecievedAtTick = Environment.TickCount;
-
-            // Send Packet requesting the root Folder, 
-            // this should recurse through all folders
-            RequestFolder(new DownloadRequest_Folder(slClient.Self.InventoryRootFolderUUID, true, true, true));
-
-            while ((FolderDownloadStatus.Count &gt; 0) || (alFolderRequestQueue.Count &gt; 0))
-            {
-                if (FolderDownloadStatus.Count == 0)
-                {
-                    DownloadRequest_Folder dr = alFolderRequestQueue[0];
-                    alFolderRequestQueue.RemoveAt(0);
-                    RequestFolder(dr);
-                }
-
-                int curTick = Environment.TickCount;
-                if ((curTick - LastPacketRecievedAtTick) &gt; 10000)
-                {
-                    slClient.Log(&quot;Time-out while waiting for packets (&quot; +
-                        ((curTick - LastPacketRecievedAtTick) / 1000) + &quot; seconds since last packet)&quot;,
-                        Helpers.LogLevel.Warning);
-
-                    // have to make a seperate list otherwise we run into modifying the original array
-                    // while still enumerating it.
-                    List&lt;DownloadRequest_Folder&gt; alRestartList = new List&lt;DownloadRequest_Folder&gt;();
-
-
-                    foreach (DownloadRequest_Folder dr in FolderDownloadStatus.Values)
-                    {
-                        alRestartList.Add(dr);
-                    }
-
-                    LastPacketRecievedAtTick = Environment.TickCount;
-                    foreach (DownloadRequest_Folder dr in alRestartList)
-                    {
-                        RequestFolder(dr);
-                    }
-                }
-
-                slClient.Tick();
-            }
-        }
-
         protected void FireRequestDownloadFinishedEvent(object o, EventArgs e)
         {
             if (OnRequestDownloadFinishedEvent != null)

Modified: trunk/libsecondlife-cs/MainAvatar.cs
===================================================================
--- trunk/libsecondlife-cs/MainAvatar.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/MainAvatar.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -29,6 +29,7 @@
 using System.Net;
 using System.Collections;
 using System.Collections.Generic;
+using System.Threading;
 using System.Text;
 using libsecondlife.Packets;
 
@@ -313,10 +314,9 @@
         /// &lt;summary&gt;
         /// Triggered for any status updates of a teleport (progress, failed, succeeded)
         /// &lt;/summary&gt;
-        /// &lt;param name=&quot;currentSim&quot;&gt;The simulator the avatar is currently residing in&lt;/param&gt;
         /// &lt;param name=&quot;message&quot;&gt;A message about the current teleport status&lt;/param&gt;
         /// &lt;param name=&quot;status&quot;&gt;The current status of the teleport&lt;/param&gt;
-        public delegate void TeleportCallback(Simulator currentSim, string message, TeleportStatus status);
+        public delegate void TeleportCallback(string message, TeleportStatus status);
 
         /// &lt;summary&gt;
         /// Reply to a request to join a group, informs whether it was successful or not
@@ -427,13 +427,12 @@
         internal string teleportMessage = String.Empty;
 
         private SecondLife Client;
-        private TeleportStatus TeleportStat;
-        private Timer TeleportTimer;
-        private bool TeleportTimeout;
-        private uint HeightWidthGenCounter;
+        private TeleportStatus TeleportStat = TeleportStatus.None;
+        private ManualResetEvent TeleportEvent = new ManualResetEvent(false);
+        private uint HeightWidthGenCounter = 0;
         private float health = 0.0f;
         private int balance = 0;
-		private LLUUID activeGroup;
+		private LLUUID activeGroup = LLUUID.Zero;
 
         /// &lt;summary&gt;
         /// Constructor, setup callbacks for packets related to our avatar
@@ -465,11 +464,6 @@
             // Script dialog callback
             Client.Network.RegisterCallback(PacketType.ScriptDialog, new NetworkManager.PacketCallback(ScriptDialogHandler));
 
-            // Teleport timeout timer
-            TeleportTimer = new Timer(Client.Settings.TELEPORT_TIMEOUT);
-            TeleportTimer.Elapsed += new ElapsedEventHandler(TeleportTimerEvent);
-            TeleportTimeout = false;
-
             // Movement complete callback
             Client.Network.RegisterCallback(PacketType.AgentMovementComplete, new NetworkManager.PacketCallback(MovementCompleteHandler));
 
@@ -486,9 +480,6 @@
             Client.Network.RegisterCallback(PacketType.JoinGroupReply, new NetworkManager.PacketCallback(JoinGroupHandler));
             Client.Network.RegisterCallback(PacketType.LeaveGroupReply, new NetworkManager.PacketCallback(LeaveGroupHandler));
             Client.Network.RegisterCallback(PacketType.AgentDropGroup, new NetworkManager.PacketCallback(DropGroupHandler));
-
-            // Viewer effect callback
-            Client.Network.RegisterCallback(PacketType.ViewerEffect, new NetworkManager.PacketCallback(ViewerEffectHandler));
 			
 			//Agent Update Callback
 			Client.Network.RegisterCallback(PacketType.AgentDataUpdate, new NetworkManager.PacketCallback(AgentDataUpdateHandler));
@@ -942,33 +933,65 @@
         }
 
         /// &lt;summary&gt;
-        /// Start a teleport process
+        /// Attempt to look up a simulator name and teleport to the discovered
+        /// destination
         /// &lt;/summary&gt;
-        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
-        public void BeginTeleport(ulong regionHandle, LLVector3 position)
+        /// &lt;param name=&quot;simName&quot;&gt;Region name to look up&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;Position to teleport to&lt;/param&gt;
+        /// &lt;returns&gt;True if the lookup and teleport were successful, otherwise
+        /// false&lt;/returns&gt;
+        public bool Teleport(string simName, LLVector3 position)
         {
-            BeginTeleport(regionHandle, position, new LLVector3(position.X + 1.0f, position.Y, position.Z));
+            return Teleport(simName, position, new LLVector3(0, 1.0f, 0));
         }
 
         /// &lt;summary&gt;
-        /// Start a teleport process
+        /// Attempt to look up a simulator name and teleport to the discovered
+        /// destination
         /// &lt;/summary&gt;
-        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
+        /// &lt;param name=&quot;simName&quot;&gt;Region name to look up&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;Position to teleport to&lt;/param&gt;
         /// &lt;param name=&quot;lookAt&quot;&gt;Target to look at&lt;/param&gt;
-        public void BeginTeleport(ulong regionHandle, LLVector3 position, LLVector3 lookAt)
+        /// &lt;returns&gt;True if the lookup and teleport were successful, otherwise
+        /// false&lt;/returns&gt;
+        public bool Teleport(string simName, LLVector3 position, LLVector3 lookAt)
         {
-            TeleportLocationRequestPacket teleport = new TeleportLocationRequestPacket();
-            teleport.AgentData.AgentID = Client.Network.AgentID;
-            teleport.AgentData.SessionID = Client.Network.SessionID;
-            teleport.Info.LookAt = lookAt;
-            teleport.Info.Position = position;
-            teleport.Info.RegionHandle = regionHandle;
+            int attempts = 0;
+            TeleportStat = TeleportStatus.None;
 
-            Client.Log(&quot;Teleporting to region &quot; + regionHandle.ToString(), Helpers.LogLevel.Info);
+            simName = simName.ToLower();
 
-            Client.Network.SendPacket(teleport);
+            GridRegion region = Client.Grid.GetGridRegion(simName);
+
+            if (region != null)
+            {
+                return Teleport(region.RegionHandle, position, lookAt);
+            }
+            else
+            {
+                while (attempts++ &lt; 5)
+                {
+                    region = Client.Grid.GetGridRegion(simName);
+
+                    if (region != null)
+                    {
+                        return Teleport(region.RegionHandle, position, lookAt);
+                    }
+                    else
+                    {
+                        // Request the region info again
+                        Client.Grid.AddSim(simName);
+
+                        // FIXME: We shouldn't be sleeping in the library at all, hopefully this goes away soon
+                        System.Threading.Thread.Sleep(1000);
+                    }
+                }
+            }
+
+            teleportMessage = &quot;Unable to resolve name: &quot; + simName;
+            TeleportStat = TeleportStatus.Failed;
+
+            return false;
         }
 
         /// &lt;summary&gt;
@@ -992,107 +1015,51 @@
         public bool Teleport(ulong regionHandle, LLVector3 position, LLVector3 lookAt)
         {
             TeleportStat = TeleportStatus.None;
+            TeleportEvent.Reset();
 
-            TeleportLocationRequestPacket teleport = new TeleportLocationRequestPacket();
-            teleport.AgentData.AgentID = Client.Network.AgentID;
-            teleport.AgentData.SessionID = Client.Network.SessionID;
-            teleport.Info.LookAt = lookAt;
-            teleport.Info.Position = position;
+            RequestTeleport(regionHandle, position, lookAt);
 
-            teleport.Info.RegionHandle = regionHandle;
+            TeleportEvent.WaitOne(Client.Settings.TELEPORT_TIMEOUT, false);
 
-            Client.Log(&quot;Teleporting to region &quot; + regionHandle.ToString(), Helpers.LogLevel.Info);
-
-            // Start the timeout check
-            TeleportTimeout = false;
-            TeleportTimer.Start();
-
-            Client.Network.SendPacket(teleport);
-
-            // FIXME: Use a ManualResetEvent, Client.Tick() is bad
-            while (TeleportStat != TeleportStatus.Failed &amp;&amp; TeleportStat != TeleportStatus.Finished &amp;&amp; !TeleportTimeout)
+            if (TeleportStat == TeleportStatus.None ||
+                TeleportStat == TeleportStatus.Start ||
+                TeleportStat == TeleportStatus.Progress)
             {
-                Client.Tick();
-            }
-
-            TeleportTimer.Stop();
-
-            if (TeleportTimeout)
-            {
                 teleportMessage = &quot;Teleport timed out.&quot;;
                 TeleportStat = TeleportStatus.Failed;
-
-                if (OnTeleport != null) { OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat); }
             }
-            else
-            {
-                if (OnTeleport != null) { OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat); }
-            }
 
             return (TeleportStat == TeleportStatus.Finished);
         }
 
         /// &lt;summary&gt;
-        /// Generic Teleport Function
+        /// Start a teleport process
         /// &lt;/summary&gt;
-        /// &lt;param name=&quot;simName&quot;&gt;Region name&lt;/param&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-        public bool Teleport(string simName, LLVector3 position)
+        public void RequestTeleport(ulong regionHandle, LLVector3 position)
         {
-            //position.Z = 0; //why was this here?
-            return Teleport(simName, position, new LLVector3(0, 1.0F, 0));
+            RequestTeleport(regionHandle, position, new LLVector3(position.X + 1.0f, position.Y, position.Z));
         }
 
         /// &lt;summary&gt;
-        /// Teleport Function
+        /// Start a teleport process
         /// &lt;/summary&gt;
-        /// &lt;param name=&quot;simName&quot;&gt;Region name&lt;/param&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
         /// &lt;param name=&quot;lookAt&quot;&gt;Target to look at&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-        public bool Teleport(string simName, LLVector3 position, LLVector3 lookAt)
+        public void RequestTeleport(ulong regionHandle, LLVector3 position, LLVector3 lookAt)
         {
-            int attempts = 0;
-            TeleportStat = TeleportStatus.None;
+            TeleportLocationRequestPacket teleport = new TeleportLocationRequestPacket();
+            teleport.AgentData.AgentID = Client.Network.AgentID;
+            teleport.AgentData.SessionID = Client.Network.SessionID;
+            teleport.Info.LookAt = lookAt;
+            teleport.Info.Position = position;
+            teleport.Info.RegionHandle = regionHandle;
 
-            simName = simName.ToLower();
+            Client.Log(&quot;Teleporting to region &quot; + regionHandle.ToString(), Helpers.LogLevel.Info);
 
-            GridRegion region = Client.Grid.GetGridRegion(simName);
-
-            if (region != null)
-            {
-                return Teleport(region.RegionHandle, position, lookAt);
-            }
-            else
-            {
-                while (attempts++ &lt; 5)
-                {
-                    region = Client.Grid.GetGridRegion(simName);
-
-                    if (region != null)
-                    {
-                        return Teleport(region.RegionHandle, position, lookAt);
-                    }
-                    else
-                    {
-                        // Request the region info again
-                        Client.Grid.AddSim(simName);
-
-                        // FIXME: We shouldn't be sleeping in the library at all, hopefully this goes away soon
-                        System.Threading.Thread.Sleep(1000);
-                    }
-                }
-            }
-
-            if (OnTeleport != null)
-            {
-                teleportMessage = &quot;Unable to resolve name: &quot; + simName;
-                TeleportStat = TeleportStatus.Failed;
-                OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
-            }
-
-            return false;
+            Client.Network.SendPacket(teleport);
         }
 
         /// &lt;summary&gt;
@@ -1479,136 +1446,20 @@
 	    }
 
         /// &lt;summary&gt;
-        /// Process an incoming effect
-        /// &lt;/summary&gt;
-        private void ViewerEffectHandler(Packet packet, Simulator simulator)
-        {
-            ViewerEffectPacket effect = (ViewerEffectPacket)packet;
-
-            foreach (ViewerEffectPacket.EffectBlock block in effect.Effect)
-            {
-                EffectType type;
-
-                try
-                {
-                    type = (EffectType)block.Type;
-                }
-                catch (Exception)
-                {
-                    Client.Log(&quot;Received a ViewerEffect block with an unknown type &quot; + block.Type, 
-                        Helpers.LogLevel.Warning);
-                    continue;
-                }
-
-                //LLColor color;
-                //if (block.Color.Length == 4)
-                //{
-                //    color = new LLColor(block.Color, 0);
-                //}
-                //else
-                //{
-                //    Client.Log(&quot;Received a ViewerEffect.EffectBlock.Color array with &quot; + block.Color.Length + &quot; bytes&quot;,
-                //        Helpers.LogLevel.Warning);
-                //    color = new LLColor();
-                //}
-
-                // Each ViewerEffect type uses it's own custom binary format for additional data. Fun eh?
-                switch (type)
-                {
-                    case EffectType.Text:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Icon:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Connector:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.FlexibleObject:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.AnimalControls:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.AnimationObject:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Cloth:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Beam:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Glow:
-                        Client.Log(&quot;Received a Glow ViewerEffect which is not implemented yet&quot;,
-                            Helpers.LogLevel.Warning);
-                        break;
-		            case EffectType.Point:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Trail:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Sphere:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Spiral:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Edit:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.LookAt:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-                    case EffectType.PointAt:
-                        if (block.TypeData.Length == 57)
-                        {
-                            LLUUID sourceAvatar = new LLUUID(block.TypeData, 0);
-                            LLUUID targetObject = new LLUUID(block.TypeData, 16);
-                            LLVector3d targetPos = new LLVector3d(block.TypeData, 32);
-                            PointAtType pointAt;
-                            try
-                            {
-                                pointAt = (PointAtType)block.TypeData[56];
-                            }
-                            catch (Exception)
-                            {
-                                Client.Log(&quot;Unrecognized PointAtType &quot; + block.TypeData[56], Helpers.LogLevel.Warning);
-                                pointAt = PointAtType.Clear;
-                            }
-
-                            // TODO: Create OnAvatarPointAt event and call it here
-                        }
-                        else
-                        {
-                            Client.Log(&quot;Received a PointAt ViewerEffect with an incorrect TypeData size of &quot; +
-                                block.TypeData.Length + &quot; bytes&quot;, Helpers.LogLevel.Warning);
-                        }
-                        break;
-                }
-            }
-        }
-
-        /// &lt;summary&gt;
         /// Handler for teleport Requests
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;packet&quot;&gt;Incoming TeleportHandler packet&lt;/param&gt;
         /// &lt;param name=&quot;simulator&quot;&gt;Simulator sending teleport information&lt;/param&gt;
         private void TeleportHandler(Packet packet, Simulator simulator)
         {
+            bool tpFinished = false;
+
             if (packet.Type == PacketType.TeleportStart)
             {
                 Client.DebugLog(&quot;TeleportStart received from &quot; + simulator.ToString());
 
                 teleportMessage = &quot;Teleport started&quot;;
                 TeleportStat = TeleportStatus.Start;
-
-                if (OnTeleport != null)
-                {
-                    try { OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat); }
-                    catch (Exception e) { Client.Log(e.ToString(), Helpers.LogLevel.Error); }
-                }
             }
             else if (packet.Type == PacketType.TeleportProgress)
             {
@@ -1616,12 +1467,6 @@
 
                 teleportMessage = Helpers.FieldToString(((TeleportProgressPacket)packet).Info.Message);
                 TeleportStat = TeleportStatus.Progress;
-
-                if (OnTeleport != null)
-                {
-                    try { OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat); }
-                    catch (Exception e) { Client.Log(e.ToString(), Helpers.LogLevel.Error); }
-                }
             }
             else if (packet.Type == PacketType.TeleportFailed)
             {
@@ -1630,11 +1475,7 @@
                 teleportMessage = Helpers.FieldToString(((TeleportFailedPacket)packet).Info.Reason);
                 TeleportStat = TeleportStatus.Failed;
 
-                if (OnTeleport != null)
-                {
-                    try { OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat); }
-                    catch (Exception e) { Client.Log(e.ToString(), Helpers.LogLevel.Error); }
-                }
+                tpFinished = true;
             }
             else if (packet.Type == PacketType.TeleportFinish)
             {
@@ -1643,12 +1484,12 @@
                 TeleportFinishPacket finish = (TeleportFinishPacket)packet;
                 Simulator previousSim = Client.Network.CurrentSim;
 
+                if (Client.Network.CurrentCaps != null) Client.Network.CurrentCaps.Dead = true;
+
                 // Connect to the new sim
                 string seedcaps = Helpers.FieldToUTF8String(finish.Info.SeedCapability);
                 IPAddress simIP = new IPAddress(finish.Info.SimIP);
 
-                if (Client.Network.CurrentCaps != null) Client.Network.CurrentCaps.Dead = true;
-				
                 Simulator sim = Client.Network.Connect(simIP, finish.Info.SimPort,
                     simulator.CircuitCode, true, seedcaps);
 
@@ -1658,55 +1499,33 @@
                     TeleportStat = TeleportStatus.Finished;
 
                     // Move the avatar in to the new sim
-                    CompleteAgentMovementPacket move = new CompleteAgentMovementPacket();
-                    move.AgentData.AgentID = Client.Network.AgentID;
-                    move.AgentData.SessionID = Client.Network.SessionID;
-                    move.AgentData.CircuitCode = simulator.CircuitCode;
-                    Client.Network.SendPacket(move, sim);
+                    Client.Self.CompleteAgentMovement(sim);
 
                     // Disconnect from the previous sim
                     Client.Network.DisconnectSim(previousSim);
 
                     Client.Log(&quot;Moved to new sim &quot; + sim.ToString(), Helpers.LogLevel.Info);
-
-                    if (OnTeleport != null)
-                    {
-                        try { OnTeleport(sim, teleportMessage, TeleportStat); }
-                        catch (Exception e) { Client.Log(e.ToString(), Helpers.LogLevel.Error); }
-                    }
-                    else
-                    {
-                        // Sleep a little while so we can collect parcel information
-                        // NOTE: This doesn't belong in libsecondlife
-                        // System.Threading.Thread.Sleep(1000);
-                    }
                 }
                 else
                 {
                     teleportMessage = &quot;Failed to connect to the new sim after a teleport&quot;;
                     TeleportStat = TeleportStatus.Failed;
 
-                    // FIXME: Set the previous CurrentSim to the current simulator again
+                    // Re-enable the previous simulator
+                    Client.Network.CurrentSim = previousSim;
+                    // FIXME: How do we re-enable Caps?
 
                     Client.Log(teleportMessage, Helpers.LogLevel.Warning);
-
-                    if (OnTeleport != null)
-                    {
-                        try { OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat); }
-                        catch (Exception e) { Client.Log(e.ToString(), Helpers.LogLevel.Error); }
-                    }
                 }
             }
-        }
 
-        /// &lt;summary&gt;
-        /// Teleport Timer Event Handler. Used for enforcing timeouts.
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;ea&quot;&gt;&lt;/param&gt;
-        private void TeleportTimerEvent(object source, System.Timers.ElapsedEventArgs ea)
-        {
-            TeleportTimeout = true;
+            if (OnTeleport != null)
+            {
+                try { OnTeleport(teleportMessage, TeleportStat); }
+                catch (Exception e) { Client.Log(e.ToString(), Helpers.LogLevel.Error); }
+            }
+
+            if (tpFinished) TeleportEvent.Set();
         }
     }
 }

Modified: trunk/libsecondlife-cs/NetworkManager.cs
===================================================================
--- trunk/libsecondlife-cs/NetworkManager.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/NetworkManager.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -272,6 +272,7 @@
         private IPEndPoint ipEndPoint;
         private EndPoint endPoint;
         private System.Timers.Timer AckTimer;
+        private ManualResetEvent ConnectedEvent = new ManualResetEvent(false);
 
         /// &lt;summary&gt;
         /// Constructor for Simulator
@@ -321,17 +322,8 @@
                 // Send the initial packet out
                 SendPacket(use, true);
 
-                // Track the current time for timeout purposes
-                int start = Environment.TickCount;
-
-                while (true)
-                {
-                    if (connected || Environment.TickCount - start &gt; Client.Settings.SIMULATOR_TIMEOUT)
-                    {
-                        return;
-                    }
-                    System.Threading.Thread.Sleep(10);
-                }
+                ConnectedEvent.Reset();
+                ConnectedEvent.WaitOne(Client.Settings.SIMULATOR_TIMEOUT, false);
             }
             catch (Exception e)
             {
@@ -606,6 +598,7 @@
 
             // If we're receiving data the sim connection is open
             connected = true;
+            ConnectedEvent.Set();
 
             // Update the disconnect flag so this sim doesn't time out
             DisconnectCandidate = false;
@@ -685,6 +678,7 @@
                 while (Inbox.Count &gt;= Client.Settings.INBOX_SIZE)
                 {
                     Inbox.Dequeue();
+                    Inbox.Dequeue();
                 }
                 Inbox.Enqueue(packet.Header.Sequence);
             }

Modified: trunk/libsecondlife-cs/SecondLife.cs
===================================================================
--- trunk/libsecondlife-cs/SecondLife.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/SecondLife.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -82,8 +82,6 @@
         /// If this is left null, log messages will go to 
         /// the console&lt;/summary&gt;
         public event LogCallback OnLogMessage;
-        /// &lt;summary&gt;Whether to log debug messages&lt;/summary&gt;
-        public bool Debug = true;
 
         /// &lt;summary&gt;
         /// Default constructor
@@ -130,11 +128,12 @@
         /// &lt;param name=&quot;level&quot;&gt;The severity of the log entry&lt;/param&gt;
         public void Log(string message, Helpers.LogLevel level)
         {
-            if (level == Helpers.LogLevel.Debug &amp;&amp; !Debug) return;
+            if (level == Helpers.LogLevel.Debug &amp;&amp; !Settings.DEBUG) return;
 
             if (OnLogMessage != null)
             {
-                OnLogMessage(message, level);
+                try { OnLogMessage(message, level); }
+                catch (Exception e) { Console.WriteLine(e.ToString()); }
             }
             else
             {
@@ -151,11 +150,12 @@
         [System.Diagnostics.Conditional(&quot;DEBUG&quot;)]
         public void DebugLog(string message)
         {
-            if (Debug)
+            if (Settings.DEBUG)
             {
                 if (OnLogMessage != null)
                 {
-                    OnLogMessage(message, Helpers.LogLevel.Debug);
+                    try { OnLogMessage(message, Helpers.LogLevel.Debug); }
+                    catch (Exception e) { Console.WriteLine(e.ToString()); }
                 }
                 else
                 {

Modified: trunk/libsecondlife-cs/Settings.cs
===================================================================
--- trunk/libsecondlife-cs/Settings.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/Settings.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -69,7 +69,9 @@
         /// &lt;summary&gt;Maximum number of ACKs to append to a packet&lt;/summary&gt;
         public int MAX_APPENDED_ACKS = 10;
         /// &lt;summary&gt;Cost of uploading an asset&lt;/summary&gt;
-        public int UPLOAD_COST { get { return priceUpload; } }
+        public int UPLOAD_COST { get { return priceUpload; } }
+        /// &lt;summary&gt;Enable/disable debugging log messages&lt;/summary&gt;
+        public bool DEBUG = true;
 
         private SecondLife Client;
         private int priceUpload = 0;

Modified: trunk/libsecondlife-cs/examples/IA_SimpleInventory/IA_SimpleInventory.cs
===================================================================
--- trunk/libsecondlife-cs/examples/IA_SimpleInventory/IA_SimpleInventory.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/examples/IA_SimpleInventory/IA_SimpleInventory.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -114,20 +114,22 @@
 
         protected void doStuff()
         {
+            Console.WriteLine(&quot;Broken until someone fixes me&quot;);
+
             // and request an inventory download
-            Console.WriteLine(&quot;Downloading Inventory.&quot;);
-            client.Inventory.DownloadInventory();
+            //Console.WriteLine(&quot;Downloading Inventory.&quot;);
+            //client.Inventory.DownloadInventory();
 
 
-            Console.WriteLine(&quot;Dumping a copy of &quot; + client.Self.FirstName + &quot;'s inventory to the console.&quot;);
-            Console.WriteLine();
+            //Console.WriteLine(&quot;Dumping a copy of &quot; + client.Self.FirstName + &quot;'s inventory to the console.&quot;);
+            //Console.WriteLine();
 
-            InventoryFolder root = client.Inventory.GetRootFolder();
+            //InventoryFolder root = client.Inventory.GetRootFolder();
 
-            if (root != null)
-            {
-                Console.WriteLine(root.toXML(false));
-            }
+            //if (root != null)
+            //{
+            //    Console.WriteLine(root.toXML(false));
+            //}
         }
     }
 }

Modified: trunk/libsecondlife-cs/examples/Teleport/Teleport.cs
===================================================================
--- trunk/libsecondlife-cs/examples/Teleport/Teleport.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/examples/Teleport/Teleport.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -147,7 +147,7 @@
             }
         }
 
-        void Self_OnTeleport(Simulator currentSim, string message, MainAvatar.TeleportStatus status)
+        void Self_OnTeleport(string message, MainAvatar.TeleportStatus status)
         {
             Console.WriteLine(message);
 

Modified: trunk/libsecondlife-cs/examples/TestClient/Commands/DebugCommand.cs
===================================================================
--- trunk/libsecondlife-cs/examples/TestClient/Commands/DebugCommand.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/examples/TestClient/Commands/DebugCommand.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -20,12 +20,12 @@
 
             if (args[0].ToLower() == &quot;on&quot;)
             {
-                Client.Debug = true;
+                Client.Settings.DEBUG = true;
                 return &quot;Debug logging is on&quot;;
             }
             else if (args[0].ToLower() == &quot;off&quot;)
             {
-                Client.Debug = false;
+                Client.Settings.DEBUG = false;
                 return &quot;Debug logging is off&quot;;
             }
             else

Modified: trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/DeleteFolderCommand.cs
===================================================================
--- trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/DeleteFolderCommand.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/DeleteFolderCommand.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -22,20 +22,22 @@
 
         public override string Execute(string[] args, LLUUID fromAgentID)
         {
-			string target = String.Empty;
-			for (int ct = 0; ct &lt; args.Length; ct++)
-				target = target + args[ct] + &quot; &quot;;
-			target = target.TrimEnd();
+            return &quot;Broken until someone fixes me&quot;;
 
-			Client.Inventory.DownloadInventory();
-			InventoryFolder folder = Client.Inventory.getFolder(target);
-			if (folder != null)
-			{
-				folder.Delete();
-				return &quot;Folder &quot; + target + &quot; deleted.&quot;;
-			}
+            //string target = String.Empty;
+            //for (int ct = 0; ct &lt; args.Length; ct++)
+            //    target = target + args[ct] + &quot; &quot;;
+            //target = target.TrimEnd();
 
-			return &quot;Unable to find: &quot; + target;
+            //Client.Inventory.DownloadInventory();
+            //InventoryFolder folder = Client.Inventory.getFolder(target);
+            //if (folder != null)
+            //{
+            //    folder.Delete();
+            //    return &quot;Folder &quot; + target + &quot; deleted.&quot;;
+            //}
+
+            //return &quot;Unable to find: &quot; + target;
 		}
 	}
 }
\ No newline at end of file

Modified: trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/InventoryCommand.cs
===================================================================
--- trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/InventoryCommand.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/InventoryCommand.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -22,39 +22,41 @@
 
         public override string Execute(string[] args, LLUUID fromAgentID)
         {
-			Client.Inventory.DownloadInventory();
-			StringBuilder result = new StringBuilder();
-			PrintFolder(Client.Inventory.GetRootFolder(), result, 0);
-            return result.ToString();
+            return &quot;Broken until someone fixes me&quot;;
+
+            //Client.Inventory.DownloadInventory();
+            //StringBuilder result = new StringBuilder();
+            //PrintFolder(Client.Inventory.GetRootFolder(), result, 0);
+            //return result.ToString();
         }
 
-		void PrintFolder(InventoryFolder folder, StringBuilder output, int indenting)
-		{
-			Indent(output, indenting);
-			output.Append(folder.Name);
-			output.Append(&quot;\n&quot;);
-			foreach (InventoryBase b in folder.GetContents())
-			{
-				InventoryItem item = b as InventoryItem;
-				if (item != null)
-				{
-					Indent(output, indenting + 1);
-					output.Append(item.Name);
-					output.Append(&quot;\n&quot;);
-					continue;
-				}
-				InventoryFolder subFolder = b as InventoryFolder;
-				if (subFolder != null)
-					PrintFolder(subFolder, output, indenting + 1);
-			}
-		}
+        //void PrintFolder(InventoryFolder folder, StringBuilder output, int indenting)
+        //{
+        //    Indent(output, indenting);
+        //    output.Append(folder.Name);
+        //    output.Append(&quot;\n&quot;);
+        //    foreach (InventoryBase b in folder.GetContents())
+        //    {
+        //        InventoryItem item = b as InventoryItem;
+        //        if (item != null)
+        //        {
+        //            Indent(output, indenting + 1);
+        //            output.Append(item.Name);
+        //            output.Append(&quot;\n&quot;);
+        //            continue;
+        //        }
+        //        InventoryFolder subFolder = b as InventoryFolder;
+        //        if (subFolder != null)
+        //            PrintFolder(subFolder, output, indenting + 1);
+        //    }
+        //}
 
-		void Indent(StringBuilder output, int indenting)
-		{
-			for (int count = 0; count &lt; indenting; count++)
-			{
-				output.Append(&quot;  &quot;);
-			}
-		}
+        //void Indent(StringBuilder output, int indenting)
+        //{
+        //    for (int count = 0; count &lt; indenting; count++)
+        //    {
+        //        output.Append(&quot;  &quot;);
+        //    }
+        //}
 	}
 }
\ No newline at end of file

Modified: trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/WearCommand.cs
===================================================================
--- trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/WearCommand.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/examples/TestClient/Commands/Inventory/WearCommand.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -22,20 +22,22 @@
 
         public override string Execute(string[] args, LLUUID fromAgentID)
         {
-			string target = String.Empty;
-			for (int ct = 0; ct &lt; args.Length; ct++)
-				target = target + args[ct] + &quot; &quot;;
-			target = target.TrimEnd();
+            return &quot;Broken until someone fixes me&quot;;
 
-			Client.Inventory.DownloadInventory();
-			InventoryFolder folder = Client.Inventory.getFolder(target);
-			if (folder != null)
-			{
-				Client.Appearance.WearOutfit(folder);
-				return &quot;Outfit &quot; + target + &quot; worn.&quot;;
-			}
+            //string target = String.Empty;
+            //for (int ct = 0; ct &lt; args.Length; ct++)
+            //    target = target + args[ct] + &quot; &quot;;
+            //target = target.TrimEnd();
 
-			return &quot;Unable to find: &quot; + target;
+            //Client.Inventory.DownloadInventory();
+            //InventoryFolder folder = Client.Inventory.getFolder(target);
+            //if (folder != null)
+            //{
+            //    Client.Appearance.WearOutfit(folder);
+            //    return &quot;Outfit &quot; + target + &quot; worn.&quot;;
+            //}
+
+            //return &quot;Unable to find: &quot; + target;
         }
 	}
 }
\ No newline at end of file

Modified: trunk/libsecondlife-cs/examples/TestClient/TestClient.cs
===================================================================
--- trunk/libsecondlife-cs/examples/TestClient/TestClient.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/examples/TestClient/TestClient.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -49,7 +49,7 @@
 
             RegisterAllCommands(Assembly.GetExecutingAssembly());
 
-            Debug = false;
+            Settings.DEBUG = false;
 
             Network.RegisterCallback(PacketType.AgentDataUpdate, new NetworkManager.PacketCallback(AgentDataUpdateHandler));
 

Modified: trunk/libsecondlife-cs/libsecondlife.Tests/NetworkTests.cs
===================================================================
--- trunk/libsecondlife-cs/libsecondlife.Tests/NetworkTests.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/libsecondlife.Tests/NetworkTests.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -193,7 +193,7 @@
             CurrentRegionHandle = update.RegionData.RegionHandle;
         }
 
-        private void OnTeleportHandler(Simulator currentSim, string message, MainAvatar.TeleportStatus status)
+        private void OnTeleportHandler(string message, MainAvatar.TeleportStatus status)
         {
             switch (status)
             {

Modified: trunk/libsecondlife-cs/libsecondlife.Utilities/Appearance.cs
===================================================================
--- trunk/libsecondlife-cs/libsecondlife.Utilities/Appearance.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/libsecondlife.Utilities/Appearance.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -74,7 +74,249 @@
         Invalid = 255
     };
 
+    public enum ForSale
+    {
+        Not = 0,
+        Original = 1,
+        Copy = 2,
+        Contents = 3
+    }
 
+
+    public class Wearable
+    {
+        public string Name = String.Empty;
+        public string Description = String.Empty;
+        public WearableType Type = WearableType.Shape;
+        public ForSale ForSale = ForSale.Not;
+        public int SalePrice = 0;
+        public LLUUID Creator = LLUUID.Zero;
+        public LLUUID Owner = LLUUID.Zero;
+        public LLUUID LastOwner = LLUUID.Zero;
+        public LLUUID Group = LLUUID.Zero;
+        public bool GroupOwned = false;
+        public Helpers.PermissionType BasePermissions;
+        public Helpers.PermissionType EveryonePermissions;
+        public Helpers.PermissionType OwnerPermissions;
+        public Helpers.PermissionType NextOwnerPermissions;
+        public Helpers.PermissionType GroupPermissions;
+        public Dictionary&lt;int, float&gt; Params = new Dictionary&lt;int, float&gt;();
+        public Dictionary&lt;int, LLUUID&gt; Textures = new Dictionary&lt;int, LLUUID&gt;();
+
+
+        private SecondLife Client;
+        private string[] ForSaleNames = new string[]
+        {
+            &quot;not&quot;,
+            &quot;orig&quot;,
+            &quot;copy&quot;,
+            &quot;cntn&quot;
+        };
+
+
+        public Wearable(SecondLife client)
+        {
+            Client = client;
+        }
+
+        public bool ImportAsset(string data)
+        {
+            int version = -1;
+            int n = -1;
+
+            try
+            {
+                n = data.IndexOf('\n');
+                version = Int32.Parse(data.Substring(19, n + 1));
+                data = data.Remove(0, n);
+
+                if (version != 22)
+                {
+                    Client.Log(&quot;Wearable asset has unrecognized version &quot; + version, Helpers.LogLevel.Warning);
+                    return false;
+                }
+
+                
+                n = data.IndexOf('\n');
+                Name = data.Substring(0, n);
+                data = data.Remove(0, n);
+
+                n = data.IndexOf('\n');
+                Description = data.Substring(0, n);
+                data = data.Remove(0, n);
+
+                // Split in to an upper and lower half
+                string[] parts = data.Split(new string[] { &quot;parameters&quot; }, StringSplitOptions.None);
+                parts[1] = &quot;parameters&quot; + parts[1];
+
+                // Parse the upper half
+                string[] lines = parts[0].Split('\n');
+                foreach (string thisline in lines)
+                {
+                    string line = thisline.Trim();
+                    string[] fields = line.Split('\t');
+
+                    if (fields.Length == 2)
+                    {
+                        if (fields[0] == &quot;creator_mask&quot;)
+                        {
+                            // Deprecated, apply this as the base mask
+                            BasePermissions = (Helpers.PermissionType)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                        }
+                        else if (fields[0] == &quot;base_mask&quot;)
+                        {
+                            BasePermissions = (Helpers.PermissionType)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                        }
+                        else if (fields[0] == &quot;owner_mask&quot;)
+                        {
+                            OwnerPermissions = (Helpers.PermissionType)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                        }
+                        else if (fields[0] == &quot;group_mask&quot;)
+                        {
+                            GroupPermissions = (Helpers.PermissionType)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                        }
+                        else if (fields[0] == &quot;everyone_mask&quot;)
+                        {
+                            EveryonePermissions = (Helpers.PermissionType)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                        }
+                        else if (fields[0] == &quot;next_owner_mask&quot;)
+                        {
+                            NextOwnerPermissions = (Helpers.PermissionType)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                        }
+                        else if (fields[0] == &quot;creator_id&quot;)
+                        {
+                            Creator = new LLUUID(fields[1]);
+                        }
+                        else if (fields[0] == &quot;owner_id&quot;)
+                        {
+                            Owner = new LLUUID(fields[1]);
+                        }
+                        else if (fields[0] == &quot;last_owner_id&quot;)
+                        {
+                            LastOwner = new LLUUID(fields[1]);
+                        }
+                        else if (fields[0] == &quot;group_id&quot;)
+                        {
+                            Group = new LLUUID(fields[1]);
+                        }
+                        else if (fields[0] == &quot;group_owned&quot;)
+                        {
+                            GroupOwned = (Int32.Parse(fields[1]) != 0);
+                        }
+                        else if (fields[0] == &quot;sale_type&quot;)
+                        {
+                            for (int i = 0; i &lt; ForSaleNames.Length; i++)
+                            {
+                                if (fields[1] == ForSaleNames[i])
+                                {
+                                    ForSale = (ForSale)i;
+                                    break;
+                                }
+                            }
+                        }
+                        else if (fields[0] == &quot;sale_price&quot;)
+                        {
+                            SalePrice = Int32.Parse(fields[1]);
+                        }
+                        else if (fields[0] == &quot;perm_mask&quot;)
+                        {
+                            Client.Log(&quot;Wearable asset has deprecated perm_mask field, ignoring&quot;, Helpers.LogLevel.Warning);
+                        }
+                    }
+                    else if (line.StartsWith(&quot;type &quot;))
+                    {
+                        Type = (WearableType)Int32.Parse(line.Substring(5));
+                        break;
+                    }
+                }
+
+                // Break up the lower half in to parameters and textures
+                string[] lowerparts = parts[1].Split(new string[] { &quot;textures&quot; }, StringSplitOptions.None);
+                lowerparts[1] = &quot;textures&quot; + lowerparts[1];
+
+                // Parse the parameters
+                lines = lowerparts[0].Split('\n');
+                foreach (string line in lines)
+                {
+                    string[] fields = line.Split(' ');
+
+                    // Use exception handling to deal with all the lines we aren't interested in
+                    try
+                    {
+                        int id = Int32.Parse(fields[0]);
+                        float weight = Single.Parse(fields[1]);
+
+                        Params[id] = weight;
+                    }
+                    catch (Exception)
+                    {
+                    }
+                }
+
+                // Parse the textures
+                lines = lowerparts[1].Split('\n');
+                foreach (string line in lines)
+                {
+                    string[] fields = line.Split(' ');
+
+                    // Use exception handling to deal with all the lines we aren't interested in
+                    try
+                    {
+                        int id = Int32.Parse(fields[0]);
+                        LLUUID texture = LLUUID.Parse(fields[1]);
+
+                        Textures[id] = texture;
+                    }
+                    catch (Exception)
+                    {
+                    }
+                }
+
+                return true;
+            }
+            catch (Exception e)
+            {
+                Client.Log(&quot;Failed to parse wearable asset: &quot; + e.ToString(), Helpers.LogLevel.Warning);
+            }
+
+            return false;
+        }
+
+        public string ExportAsset()
+        {
+            string data = &quot;LLWearable version 22\n&quot;;
+            data += Name + &quot;\n\n&quot;;
+            data += &quot;\tpermissions 0\n\t{\n&quot;;
+            data += &quot;\t\tbase_mask\t&quot; + Helpers.UIntToHexString((uint)BasePermissions) + &quot;\n&quot;;
+            data += &quot;\t\towner_mask\t&quot; + Helpers.UIntToHexString((uint)OwnerPermissions) + &quot;\n&quot;;
+            data += &quot;\t\tgroup_mask\t&quot; + Helpers.UIntToHexString((uint)GroupPermissions) + &quot;\n&quot;;
+            data += &quot;\t\teveryone_mask\t&quot; + Helpers.UIntToHexString((uint)EveryonePermissions) + &quot;\n&quot;;
+            data += &quot;\t\tnext_owner_mask\t&quot; + Helpers.UIntToHexString((uint)NextOwnerPermissions) + &quot;\n&quot;;
+            data += &quot;\t\tcreator_id\t&quot; + Creator.ToStringHyphenated() + &quot;\n&quot;;
+            data += &quot;\t\towner_id\t&quot; + Owner.ToStringHyphenated() + &quot;\n&quot;;
+            data += &quot;\t\tlast_owner_id\t&quot; + LastOwner.ToStringHyphenated() + &quot;\n&quot;;
+            data += &quot;\t\tgroup_id\t&quot; + Group.ToStringHyphenated() + &quot;\n&quot;;
+            if (GroupOwned) data += &quot;\t\tgroup_owned\t1\n&quot;;
+            data += &quot;\t}\n&quot;;
+            data += &quot;\tsale_info\t0\n&quot;;
+            data += &quot;\t{\n&quot;;
+            data += &quot;\t\tsale_type\t&quot; + ForSaleNames[(int)ForSale] + &quot;\n&quot;;
+            data += &quot;\t\tsale_price\t&quot; + SalePrice + &quot;\n&quot;;
+            data += &quot;\t}\n&quot;;
+            data += &quot;type &quot; + (int)Type + &quot;\n&quot;;
+
+            data += &quot;parameters &quot; + Params.Count + &quot;\n&quot;;
+            foreach (KeyValuePair&lt;int, float&gt; param in Params)
+                data += param.Key + &quot; &quot; + Helpers.FloatToTerseString(param.Value) + &quot;\n&quot;;
+
+            data += &quot;textures &quot; + Textures.Count + &quot;\n&quot;;
+            foreach (KeyValuePair&lt;int, LLUUID&gt; texture in Textures)
+                data += texture.Key + &quot; &quot; + texture.Value.ToStringHyphenated() + &quot;\n&quot;;
+
+            return data;
+        }
+    }
+
     /// &lt;summary&gt;
     /// 
     /// &lt;/summary&gt;
@@ -128,6 +370,7 @@
 
         private SecondLife Client;
         private AssetManager Assets;
+        private bool DownloadWearables = false;
 
 
         /// &lt;summary&gt;
@@ -149,14 +392,20 @@
         /// &lt;returns&gt;&lt;/returns&gt;
         public bool SetCurrentAppearance()
         {
+            AssetManager.AssetReceivedCallback callback = new AssetManager.AssetReceivedCallback(Assets_OnAssetReceived);
+            Assets.OnAssetReceived += callback;
+
             return false;
         }
 
         /// &lt;summary&gt;
         /// 
         /// &lt;/summary&gt;
-        public void RequestAgentWearables()
+        /// &lt;param name=&quot;autoDownload&quot;&gt;&lt;/param&gt;
+        public void RequestAgentWearables(bool autoDownload)
         {
+            DownloadWearables = autoDownload;
+
             AgentWearablesRequestPacket request = new AgentWearablesRequestPacket();
             request.AgentData.AgentID = Client.Network.AgentID;
             request.AgentData.SessionID = Client.Network.SessionID;
@@ -211,6 +460,10 @@
                         KeyValuePair&lt;LLUUID, LLUUID&gt; ids = new KeyValuePair&lt;LLUUID, LLUUID&gt;(block.AssetID, block.ItemID);
                         WearableType type = (WearableType)block.WearableType;
                         wearables[type] = ids;
+
+                        //FIXME: Convert WearableType to AssetType
+                        //if (DownloadWearables)
+                        //    Assets.RequestAsset(block.AssetID, (WearableType)block.WearableType, true);
                     }
 
                     try { OnAgentWearables(wearables); }
@@ -218,5 +471,10 @@
                 }
             }
         }
+
+        void Assets_OnAssetReceived(AssetTransfer asset)
+        {
+            // Check if this is a wearable we were waiting on
+        }
     }
 }

Modified: trunk/libsecondlife-cs/libsecondlife.Utilities/Assets.cs
===================================================================
--- trunk/libsecondlife-cs/libsecondlife.Utilities/Assets.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/libsecondlife.Utilities/Assets.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -217,12 +217,12 @@
         /// &lt;param name=&quot;assetID&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
         /// &lt;param name=&quot;priority&quot;&gt;&lt;/param&gt;
-        public void RequestAsset(LLUUID assetID, AssetType type, float priority)
+        public void RequestAsset(LLUUID assetID, AssetType type, bool priority)
         {
             AssetTransfer transfer = new AssetTransfer();
             transfer.ID = LLUUID.Random();
             transfer.AssetID = assetID;
-            transfer.Priority = priority;
+            transfer.Priority = 100.0f + (priority ? 1.0f : 0.0f);
             transfer.Channel = ChannelType.Asset;
             transfer.Source = SourceType.Asset;
 
@@ -232,7 +232,7 @@
             // Build the request packet and send it
             TransferRequestPacket request = new TransferRequestPacket();
             request.TransferInfo.ChannelType = (int)transfer.Channel;
-            request.TransferInfo.Priority = priority;
+            request.TransferInfo.Priority = transfer.Priority;
             request.TransferInfo.SourceType = (int)transfer.Source;
             request.TransferInfo.TransferID = transfer.ID;
 
@@ -254,14 +254,14 @@
         /// asset from an object inventory&lt;/param&gt;
         /// &lt;param name=&quot;ownerID&quot;&gt;The owner of this asset&lt;/param&gt;
         /// &lt;param name=&quot;type&quot;&gt;Asset type&lt;/param&gt;
-        /// &lt;param name=&quot;priority&quot;&gt;Try 101.0f&lt;/param&gt;
+        /// &lt;param name=&quot;priority&quot;&gt;Whether to prioritize this asset download or not&lt;/param&gt;
         public void RequestInventoryAsset(LLUUID assetID, LLUUID itemID, LLUUID taskID, LLUUID ownerID, AssetType type,
-            float priority)
+            bool priority)
         {
             AssetTransfer transfer = new AssetTransfer();
             transfer.ID = LLUUID.Random();
             transfer.AssetID = assetID;
-            transfer.Priority = priority;
+            transfer.Priority = 100.0f + (priority ? 1.0f : 0.0f);
             transfer.Channel = ChannelType.Asset;
             transfer.Source = SourceType.SimInventoryItem;
 
@@ -271,7 +271,7 @@
             // Build the request packet and send it
             TransferRequestPacket request = new TransferRequestPacket();
             request.TransferInfo.ChannelType = (int)transfer.Channel;
-            request.TransferInfo.Priority = priority;
+            request.TransferInfo.Priority = transfer.Priority;
             request.TransferInfo.SourceType = (int)transfer.Source;
             request.TransferInfo.TransferID = transfer.ID;
 

Modified: trunk/libsecondlife-cs/libsecondlife.Utilities/Utilities.cs
===================================================================
--- trunk/libsecondlife-cs/libsecondlife.Utilities/Utilities.cs	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/libsecondlife.Utilities/Utilities.cs	2007-01-25 13:02:20 UTC (rev 902)
@@ -8,7 +8,7 @@
 {
     public static class Realism
     {
-        public static LLUUID TypingAnimation = new LLUUID(&quot;c541c47f-e0c0-058b-ad1a-d6ae3a4584d9&quot;);
+        public readonly static LLUUID TypingAnimation = new LLUUID(&quot;c541c47f-e0c0-058b-ad1a-d6ae3a4584d9&quot;);
 
         /// &lt;summary&gt;
         ///  A psuedo-realistic chat function that uses the typing sound and
@@ -75,6 +75,43 @@
         }
     }
 
+    public class Connection
+    {
+        private SecondLife Client;
+        private ulong SimHandle = 0;
+        private LLVector3 Position = LLVector3.Zero;
+        private LLUUID Seat = LLUUID.Zero;
+        private System.Timers.Timer CheckTimer;
+
+        public Connection(SecondLife client, int timerFrequency)
+        {
+            Client = client;
+
+            CheckTimer = new System.Timers.Timer(timerFrequency);
+            CheckTimer.Elapsed += new System.Timers.ElapsedEventHandler(CheckTimer_Elapsed);
+        }
+
+        void CheckTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
+        {
+            if (SimHandle != 0)
+            {
+                if (Client.Network.CurrentSim.Region.Handle != 0 &amp;&amp;
+                    Client.Network.CurrentSim.Region.Handle != SimHandle)
+                {
+                    // Attempt to move to our target sim
+                    Client.Self.Teleport(SimHandle, Position);
+                }
+            }
+        }
+
+        public void StayInSim(ulong handle, LLVector3 desiredPosition)
+        {
+            SimHandle = handle;
+            Position = desiredPosition;
+            CheckTimer.Start();
+        }
+    }
+
     /// &lt;summary&gt;
     /// Keeps an up to date inventory of the currently seen objects in each
     /// simulator

Modified: trunk/libsecondlife-cs/libsecondlife.sln
===================================================================
--- trunk/libsecondlife-cs/libsecondlife.sln	2007-01-25 12:48:23 UTC (rev 901)
+++ trunk/libsecondlife-cs/libsecondlife.sln	2007-01-25 13:02:20 UTC (rev 902)
@@ -1,5 +1,5 @@
 Microsoft Visual Studio Solution File, Format Version 9.00
-# Visual C# Express 2005
+# Visual Studio 2005
 Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;libsecondlife&quot;, &quot;libsecondlife.csproj&quot;, &quot;{D9CDEDFB-8169-4B03-B57F-0DF638F044EC}&quot;
 EndProject
 Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;sldump&quot;, &quot;examples\sldump\sldump.csproj&quot;, &quot;{F6258A68-C624-46A0-BA73-B55D21BB0A3B}&quot;
@@ -28,10 +28,6 @@
 EndProject
 Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;AnimationSample&quot;, &quot;examples\AnimationSample\AnimationSample.csproj&quot;, &quot;{4EF98AD4-B3B3-42B0-9273-13A614A823F7}&quot;
 EndProject
-Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;libjaspernet&quot;, &quot;..\libjaspernet\libjaspernet.csproj&quot;, &quot;{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}&quot;
-EndProject
-Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;BodyPartMorphGenerator&quot;, &quot;examples\BodyPartMorphGenerator\BodyPartMorphGenerator.csproj&quot;, &quot;{98C44481-3F15-4305-840D-037EA0D9C221}&quot;
-EndProject
 Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;TestClient&quot;, &quot;examples\TestClient\TestClient.csproj&quot;, &quot;{B87682F6-B2D7-4C4D-A529-400C24FD4880}&quot;
 EndProject
 Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;libsecondlife.Utilities&quot;, &quot;libsecondlife.Utilities\libsecondlife.Utilities.csproj&quot;, &quot;{CE5E06C2-2428-416B-ADC1-F1FE16A0FB27}&quot;
@@ -48,6 +44,10 @@
 EndProject
 Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Proxy&quot;, &quot;..\applications\SLProxy\Proxy.csproj&quot;, &quot;{0516E1A7-D062-4830-859C-6FD0E4F84E75}&quot;
 EndProject
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;VisualParamGenerator&quot;, &quot;VisualParamGenerator\VisualParamGenerator.csproj&quot;, &quot;{D2A514C5-5590-4789-9032-6E5B4C297B80}&quot;
+EndProject
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;openjpegnet&quot;, &quot;..\openjpegnet\openjpegnet.csproj&quot;, &quot;{D0DCFDCB-71FA-4343-A8D1-24D4665A94A4}&quot;
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|.NET 1.1 = Debug|.NET 1.1
@@ -142,18 +142,6 @@
 		{4EF98AD4-B3B3-42B0-9273-13A614A823F7}.Release|.NET 1.1.ActiveCfg = Release|Any CPU
 		{4EF98AD4-B3B3-42B0-9273-13A614A823F7}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{4EF98AD4-B3B3-42B0-9273-13A614A823F7}.Release|Any CPU.Build.0 = Release|Any CPU
-		{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}.Debug|.NET 1.1.ActiveCfg = Debug|Any CPU
-		{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}.Release|.NET 1.1.ActiveCfg = Release|Any CPU
-		{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{7D4C4807-7705-48A7-9D82-F6689FBBCC8B}.Release|Any CPU.Build.0 = Release|Any CPU
-		{98C44481-3F15-4305-840D-037EA0D9C221}.Debug|.NET 1.1.ActiveCfg = Debug|Any CPU
-		{98C44481-3F15-4305-840D-037EA0D9C221}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{98C44481-3F15-4305-840D-037EA0D9C221}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{98C44481-3F15-4305-840D-037EA0D9C221}.Release|.NET 1.1.ActiveCfg = Release|Any CPU
-		{98C44481-3F15-4305-840D-037EA0D9C221}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{98C44481-3F15-4305-840D-037EA0D9C221}.Release|Any CPU.Build.0 = Release|Any CPU
 		{B87682F6-B2D7-4C4D-A529-400C24FD4880}.Debug|.NET 1.1.ActiveCfg = Debug|Any CPU
 		{B87682F6-B2D7-4C4D-A529-400C24FD4880}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{B87682F6-B2D7-4C4D-A529-400C24FD4880}.Debug|Any CPU.Build.0 = Debug|Any CPU
@@ -202,6 +190,18 @@
 		{0516E1A7-D062-4830-859C-6FD0E4F84E75}.Release|.NET 1.1.ActiveCfg = Release|Any CPU
 		{0516E1A7-D062-4830-859C-6FD0E4F84E75}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{0516E1A7-D062-4830-859C-6FD0E4F84E75}.Release|Any CPU.Build.0 = Release|Any CPU
+		{D2A514C5-5590-4789-9032-6E5B4C297B80}.Debug|.NET 1.1.ActiveCfg = Debug|Any CPU
+		{D2A514C5-5590-4789-9032-6E5B4C297B80}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{D2A514C5-5590-4789-9032-6E5B4C297B80}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{D2A514C5-5590-4789-9032-6E5B4C297B80}.Release|.NET 1.1.ActiveCfg = Release|Any CPU
+		{D2A514C5-5590-4789-9032-6E5B4C297B80}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{D2A514C5-5590-4789-9032-6E5B4C297B80}.Release|Any CPU.Build.0 = Release|Any CPU
+		{D0DCFDCB-71FA-4343-A8D1-24D4665A94A4}.Debug|.NET 1.1.ActiveCfg = Debug|Any CPU
+		{D0DCFDCB-71FA-4343-A8D1-24D4665A94A4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{D0DCFDCB-71FA-4343-A8D1-24D4665A94A4}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{D0DCFDCB-71FA-4343-A8D1-24D4665A94A4}.Release|.NET 1.1.ActiveCfg = Release|Any CPU
+		{D0DCFDCB-71FA-4343-A8D1-24D4665A94A4}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{D0DCFDCB-71FA-4343-A8D1-24D4665A94A4}.Release|Any CPU.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000327.html">[Libsecondlife-commits] r893 - trunk
</A></li>
	<LI>Next message: <A HREF="000329.html">[Libsecondlife-commits] r904 - branches/stable
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#328">[ date ]</a>
              <a href="thread.html#328">[ thread ]</a>
              <a href="subject.html#328">[ subject ]</a>
              <a href="author.html#328">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">More information about the Libsecondlife-commits
mailing list</a><br>
</body></html>
