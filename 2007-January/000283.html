<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Libsecondlife-commits] r860 - in trunk/libsecondlife-cs: .	examples/TestClient
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/libsecondlife-commits/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r860%20-%20in%20trunk/libsecondlife-cs%3A%20.%0A%09examples/TestClient&In-Reply-To=%3C200701191334.l0JDY1OW030638%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000282.html">
   <LINK REL="Next"  HREF="000284.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Libsecondlife-commits] r860 - in trunk/libsecondlife-cs: .	examples/TestClient</H1>
    <B>jhurliman at BerliOS</B> 
    <A HREF="mailto:libsecondlife-commits%40lists.berlios.de?Subject=Re%3A%20%5BLibsecondlife-commits%5D%20r860%20-%20in%20trunk/libsecondlife-cs%3A%20.%0A%09examples/TestClient&In-Reply-To=%3C200701191334.l0JDY1OW030638%40sheep.berlios.de%3E"
       TITLE="[Libsecondlife-commits] r860 - in trunk/libsecondlife-cs: .	examples/TestClient">jhurliman at mail.berlios.de
       </A><BR>
    <I>Fri Jan 19 14:34:01 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000282.html">[Libsecondlife-commits] r859 - in trunk: data libsecondlife-cs	libsecondlife-cs/examples/ParcelDownload	libsecondlife-cs/libsecondlife.Utilities
</A></li>
        <LI>Next message: <A HREF="000284.html">[Libsecondlife-commits] [Patch #1840] Patch for endianness of IP	address in TeleportFinish
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#283">[ date ]</a>
              <a href="thread.html#283">[ thread ]</a>
              <a href="subject.html#283">[ subject ]</a>
              <a href="author.html#283">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jhurliman
Date: 2007-01-19 14:30:56 +0100 (Fri, 19 Jan 2007)
New Revision: 860

Modified:
   trunk/libsecondlife-cs/MainAvatar.cs
   trunk/libsecondlife-cs/NetworkManager.cs
   trunk/libsecondlife-cs/examples/TestClient/TestClient.cs
   trunk/libsecondlife-cs/examples/TestClient/TestClient.csproj
Log:
Fixed the TestClient project in VS2005 and more cleanup on Caps

Modified: trunk/libsecondlife-cs/MainAvatar.cs
===================================================================
--- trunk/libsecondlife-cs/MainAvatar.cs	2007-01-19 13:15:12 UTC (rev 859)
+++ trunk/libsecondlife-cs/MainAvatar.cs	2007-01-19 13:30:56 UTC (rev 860)
@@ -1,1703 +1,1703 @@
-/*
- * Copyright (c) 2006, Second Life Reverse Engineering Team
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the Second Life Reverse Engineering Team nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Timers;
-using System.Net;
-using System.Collections;
-using System.Collections.Generic;
-using System.Text;
-using libsecondlife.Packets;
-
-namespace libsecondlife
-{
-    /// &lt;summary&gt;
-    /// Class to hold Client Avatar's data
-    /// &lt;/summary&gt;
-    public partial class MainAvatar
-    {
-        /// &lt;summary&gt;
-        /// Current teleport status
-        /// &lt;/summary&gt;
-        public enum TeleportStatus
-        {
-            /// &lt;summary&gt;&lt;/summary&gt;
-            None,
-            /// &lt;summary&gt;Teleport Start&lt;/summary&gt;
-            Start,
-            /// &lt;summary&gt;Teleport in Progress&lt;/summary&gt;
-            Progress,
-            /// &lt;summary&gt;Teleport Failed&lt;/summary&gt;
-            Failed,
-            /// &lt;summary&gt;Teleport Completed&lt;/summary&gt;
-            Finished
-        }
-
-        /// &lt;summary&gt;
-        /// Special commands used in Instant Messages
-        /// &lt;/summary&gt;
-        public enum InstantMessageDialog : byte
-        {
-            /// &lt;summary&gt;Indicates a regular IM from another agent&lt;/summary&gt;
-            MessageFromAgent = 0,
-			/// &lt;summary&gt;Simple notification box with an OK button.&lt;/summary&gt;
-			MessageBox = 1,
-			/// &lt;summary&gt;You've been invited to join a group.&lt;/summary&gt;
-			GroupInvitation = 3,
-            /// &lt;summary&gt;Indicates that someone has given the user an object&lt;/summary&gt;
-            /// &lt;remarks&gt;Soon to be deprecated&lt;/remarks&gt;
-            GiveInventory = 4,
-			/// &lt;summary&gt;Inventory offer&lt;/summary&gt;
-			InventoryOffered = 4,
-            /// &lt;summary&gt;An avatar has accepted your inventory offer&lt;/summary&gt;
-			InventoryAccepted = 5,
-            /// &lt;summary&gt;An avatar has declined your inventory offer&lt;/summary&gt;
-			InventoryDeclined = 6,
-			/// &lt;summary&gt;Group vote&lt;/summary&gt;
-			GroupVote = 7,
-            /// &lt;summary&gt;Indicates that someone has given us a notecard&lt;/summary&gt;
-            GiveNotecard = 9,
-			/// &lt;summary&gt;Unknown&lt;/summary&gt;
-			TaskInventoryOffered = 9,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-			TaskInventoryAccepted = 10,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-			TaskInventoryDeclined = 11,
-			/// &lt;summary&gt;Unknown&lt;/summary&gt;
-			NewUserDefault = 12,
-			/// &lt;summary&gt;Start a session, or add users to a session&lt;/summary&gt;
-			SessionAdd = 13,
-			/// &lt;summary&gt;Start a session, but don't prune offline users&lt;/summary&gt;
-			SessionOfflineAdd = 14,
-			/// &lt;summary&gt;Start a session with your group&lt;/summary&gt;
-			SessionGroupStart = 15,
-			/// &lt;summary&gt;Start a session without a calling card (finder or objects)&lt;/summary&gt;
-			SessionCardlessStart = 16,
-			/// &lt;summary&gt;Send a message to a session&lt;/summary&gt;
-			SessionSend = 17,
-			/// &lt;summary&gt;Leave a session&lt;/summary&gt;
-			SessionDrop = 18,
-            /// &lt;summary&gt;Indicates that the IM is from an object&lt;/summary&gt;
-            MessageFromObject = 19,
-			/// &lt;summary&gt;sent an IM to a busy user, this is the auto response&lt;/summary&gt;
-			BusyAutoResponse = 20,
-			/// &lt;summary&gt;Shows the message in the console and chat history&lt;/summary&gt;
-			ConsoleAndChatHistory = 21,
-			/// &lt;summary&gt;IM Types used for luring your friends&lt;/summary&gt;
-            RequestTeleport = 22,
-            /// &lt;summary&gt;Response sent to the agent which inititiated a teleport invitation&lt;/summary&gt;
-            AcceptTeleport = 23,
-            /// &lt;summary&gt;Response sent to the agent which inititiated a teleport invitation&lt;/summary&gt;
-            DenyTeleport = 24,
-            /// &lt;summary&gt;Only useful if you have Linden permissions&lt;/summary&gt;
-            GodLikeRequestTeleport = 25,
-			/// &lt;summary&gt;IM to tell the user to go to an URL&lt;/summary&gt;
-			GotoUrl = 28,
-			/// &lt;summary&gt;IM for help&lt;/summary&gt;
-			Session911Start = 29,
-			/// &lt;summary&gt;IM sent automatically on call for help, sends a lure 
-            /// to each Helper reached&lt;/summary&gt;
-			Lure911 = 30,
-			/// &lt;summary&gt;Like an IM but won't go to email&lt;/summary&gt;
-			FromTaskAsAlert = 31,
-			/// &lt;summary&gt;IM from a group officer to all group members&lt;/summary&gt;
-			GroupNotice = 32,
-			/// &lt;summary&gt;Unknown&lt;/summary&gt;
-			GroupNoticeInventoryAccepted = 33,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-			GroupNoticeInventoryDeclined = 34,
-			/// &lt;summary&gt;Accept a group invitation&lt;/summary&gt;
-			GroupInvitationAccept = 35,
-			/// &lt;summary&gt;Decline a group invitation&lt;/summary&gt;
-			GroupInvitationDecline = 36,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-			GroupNoticeRequested = 37,
-			/// &lt;summary&gt;An avatar is offering you friendship&lt;/summary&gt;
-			FriendshipOffered = 38,
-			/// &lt;summary&gt;An avatar has accepted your friendship offer&lt;/summary&gt;
-			FriendshipAccepted = 39,
-			/// &lt;summary&gt;An avatar has declined your friendship offer&lt;/summary&gt;
-			FriendshipDeclined = 40,
-            /// &lt;summary&gt;Indicates that a user has started typing&lt;/summary&gt;
-            StartTyping = 41,
-            /// &lt;summary&gt;Indicates that a user has stopped typing&lt;/summary&gt;
-            StopTyping = 42
-        }
-
-        /// &lt;summary&gt;
-        /// Conversion type to denote Chat Packet types in an easier-to-understand format
-        /// &lt;/summary&gt;
-        public enum ChatType : byte
-        {
-            /// &lt;summary&gt;Whispers (5m radius)&lt;/summary&gt;
-            Whisper = 0,
-            /// &lt;summary&gt;Normal chat (10/20m radius), what the official viewer typically sends&lt;/summary&gt;
-            Normal = 1,
-            /// &lt;summary&gt;Shouting! (100m radius)&lt;/summary&gt;
-            Shout = 2,
-            /// &lt;summary&gt;Say chat (10/20m radius) - The official viewer will 
-            /// print &quot;[4:15] You say, hey&quot; instead of &quot;[4:15] You: hey&quot;&lt;/summary&gt;
-            Say = 3,
-            /// &lt;summary&gt;Event message when an Avatar has begun to type&lt;/summary&gt;
-            StartTyping = 4,
-            /// &lt;summary&gt;Event message when an Avatar has stopped typing&lt;/summary&gt;
-            StopTyping = 5
-        }
-
-        /// &lt;summary&gt;
-        /// Effect type used in ViewerEffect packets
-        /// &lt;/summary&gt;
-        public enum EffectType : byte
-	    {
-            /// &lt;summary&gt;Place floating text above an object&lt;/summary&gt;
-		    Text = 0,
-            /// &lt;summary&gt;Unknown, probably places an icon above an object&lt;/summary&gt;
-		    Icon,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-		    Connector,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-		    FlexibleObject,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-		    AnimalControls,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-		    AnimationObject,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-		    Cloth,
-            /// &lt;summary&gt;Project a beam from a source to a destination, such as
-            /// the one used when editing an object&lt;/summary&gt;
-		    Beam,
-            /// &lt;summary&gt;Not implemented yet&lt;/summary&gt;
-		    Glow,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-		    Point,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-		    Trail,
-            /// &lt;summary&gt;Create a swirl of particles around an object&lt;/summary&gt;
-		    Sphere,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-		    Spiral,
-            /// &lt;summary&gt;Unknown&lt;/summary&gt;
-		    Edit,
-            /// &lt;summary&gt;Cause an avatar to look at an object&lt;/summary&gt;
-		    LookAt,
-            /// &lt;summary&gt;Cause an avatar to point at an object&lt;/summary&gt;
-		    PointAt
-	    }
-
-        /// &lt;summary&gt;
-        /// The action an avatar is doing when looking at something, used in 
-        /// ViewerEffect packets for the LookAt effect
-        /// &lt;/summary&gt;
-        public enum LookAtTarget : byte
-        {
-            /// &lt;summary&gt;&lt;/summary&gt;
-	        None,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            Idle,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            AutoListen,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            FreeLook,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            Respond,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            Hover,
-            /// &lt;summary&gt;Deprecated&lt;/summary&gt;
-            Conversation,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            Select,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            Focus,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            Mouselook,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            Clear
-        }
-
-        /// &lt;summary&gt;
-        /// The action an avatar is doing when pointing at something, used in
-        /// ViewerEffect packets for the PointAt effect
-        /// &lt;/summary&gt;
-        public enum PointAtType : byte
-        {
-            /// &lt;summary&gt;&lt;/summary&gt;
-            None,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            Select,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            Grab,
-            /// &lt;summary&gt;&lt;/summary&gt;
-            Clear
-        }
-
-
-        /// &lt;summary&gt;
-        /// Triggered on incoming chat messages
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;Message&quot;&gt;Text of chat message&lt;/param&gt;
-        /// &lt;param name=&quot;Audible&quot;&gt;Is this normal audible chat or not.&lt;/param&gt;
-        /// &lt;param name=&quot;Type&quot;&gt;Type of chat (whisper,shout,status,etc)&lt;/param&gt;
-        /// &lt;param name=&quot;Sourcetype&quot;&gt;Type of source (Agent / Object / ???)&lt;/param&gt;
-        /// &lt;param name=&quot;FromName&quot;&gt;Text name of sending Avatar/Object&lt;/param&gt;
-        /// &lt;param name=&quot;ID&quot;&gt;&lt;/param&gt;
-        public delegate void ChatCallback(string message, byte audible, byte type, byte sourcetype,
-            string fromName, LLUUID id, LLUUID ownerid, LLVector3 position);
-
-        /// &lt;summary&gt;
-        /// Triggered when a script pops up a dialog box
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;message&quot;&gt;The dialog box message&lt;/param&gt;
-        /// &lt;param name=&quot;objectName&quot;&gt;Name of the object that sent the dialog&lt;/param&gt;
-        /// &lt;param name=&quot;imageID&quot;&gt;Image to be displayed in the dialog&lt;/param&gt;
-        /// &lt;param name=&quot;objectID&quot;&gt;ID of the object that sent the dialog&lt;/param&gt;
-        /// &lt;param name=&quot;firstName&quot;&gt;First name of the object owner&lt;/param&gt;
-        /// &lt;param name=&quot;lastName&quot;&gt;Last name of the object owner&lt;/param&gt;
-        /// &lt;param name=&quot;chatChannel&quot;&gt;Chat channel that the object is communicating on&lt;/param&gt;
-        /// &lt;param name=&quot;buttons&quot;&gt;List of button labels&lt;/param&gt;
-        public delegate void ScriptDialogCallback(string message, string objectName, LLUUID imageID,
-            LLUUID objectID, string firstName, string lastName, int chatChannel, List&lt;string&gt; buttons);
-
-        /// &lt;summary&gt;
-        /// Triggered when the L$ account balance for this avatar changes
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;balance&quot;&gt;The new account balance&lt;/param&gt;
-        public delegate void BalanceCallback(int balance);
-
-        /// &lt;summary&gt;
-        /// Tiggered on incoming instant messages
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;fromAgentID&quot;&gt;Key of sender&lt;/param&gt;
-        /// &lt;param name=&quot;fromAgentName&quot;&gt;Name of sender&lt;/param&gt;
-        /// &lt;param name=&quot;toAgentID&quot;&gt;Key of destination Avatar&lt;/param&gt;
-        /// &lt;param name=&quot;parentEstateID&quot;&gt;ID of originating Estate&lt;/param&gt;
-        /// &lt;param name=&quot;regionID&quot;&gt;Key of originating Region&lt;/param&gt;
-        /// &lt;param name=&quot;position&quot;&gt;Coordinates in originating Region&lt;/param&gt;
-        /// &lt;param name=&quot;dialog&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;groupIM&quot;&gt;Group IM session toggle&lt;/param&gt;
-        /// &lt;param name=&quot;imSessionID&quot;&gt;Key of IM Session&lt;/param&gt;
-        /// &lt;param name=&quot;timestamp&quot;&gt;Timestamp of message&lt;/param&gt;
-        /// &lt;param name=&quot;message&quot;&gt;Text of message&lt;/param&gt;
-        /// &lt;param name=&quot;offline&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;binaryBucket&quot;&gt;&lt;/param&gt;
-        public delegate void InstantMessageCallback(LLUUID fromAgentID, string fromAgentName,
-            LLUUID toAgentID, uint parentEstateID, LLUUID regionID, LLVector3 position,
-            byte dialog, bool groupIM, LLUUID imSessionID, DateTime timestamp, string message,
-            byte offline, byte[] binaryBucket);
-
-        /// &lt;summary&gt;
-        /// Triggered for any status updates of a teleport (progress, failed, succeeded)
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;currentSim&quot;&gt;The simulator the avatar is currently residing in&lt;/param&gt;
-        /// &lt;param name=&quot;message&quot;&gt;A message about the current teleport status&lt;/param&gt;
-        /// &lt;param name=&quot;status&quot;&gt;The current status of the teleport&lt;/param&gt;
-        public delegate void TeleportCallback(Simulator currentSim, string message, TeleportStatus status);
-
-        /// &lt;summary&gt;
-        /// Reply to a request to join a group, informs whether it was successful or not
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;groupID&quot;&gt;The group we attempted to join&lt;/param&gt;
-        /// &lt;param name=&quot;success&quot;&gt;Whether we joined the group or not&lt;/param&gt;
-        public delegate void JoinGroupCallback(LLUUID groupID, bool success);
-
-        /// &lt;summary&gt;
-        /// Reply to a request to leave a group, informs whether it was successful or not
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;groupID&quot;&gt;The group we attempted to leave&lt;/param&gt;
-        /// &lt;param name=&quot;success&quot;&gt;Whether we left the group or not&lt;/param&gt;
-        public delegate void LeaveGroupCallback(LLUUID groupID, bool success);
-
-        /// &lt;summary&gt;
-        /// Informs the avatar that it is no longer a member of a group
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;groupID&quot;&gt;The group we are no longer a member of&lt;/param&gt;
-        public delegate void GroupDroppedCallback(LLUUID groupID);
-
-
-        /// &lt;summary&gt;Callback for incoming chat packets&lt;/summary&gt;
-        public event ChatCallback OnChat;
-        /// &lt;summary&gt;Callback for pop-up dialogs from scripts&lt;/summary&gt;
-        public event ScriptDialogCallback OnScriptDialog;
-        /// &lt;summary&gt;Callback for incoming IMs&lt;/summary&gt;
-        public event InstantMessageCallback OnInstantMessage;
-        /// &lt;summary&gt;Callback for Teleport request update&lt;/summary&gt;
-        public event TeleportCallback OnTeleport;
-        /// &lt;summary&gt;Callback for incoming change in L$ balance&lt;/summary&gt;
-        public event BalanceCallback OnBalanceUpdated;
-        /// &lt;summary&gt;Callback reply for an attempt to join a group&lt;/summary&gt;
-        public event JoinGroupCallback OnJoinGroup;
-        /// &lt;summary&gt;Callback reply for an attempt to leave a group&lt;/summary&gt;
-        public event LeaveGroupCallback OnLeaveGroup;
-        /// &lt;summary&gt;Callback for informing the avatar that it is no longer a member of a group&lt;/summary&gt;
-        public event GroupDroppedCallback OnGroupDropped;
-
-        /// &lt;summary&gt;Your (client) Avatar UUID, asset server&lt;/summary&gt;
-        public LLUUID ID = LLUUID.Zero;
-        /// &lt;summary&gt;Your (client) Avatar ID, local to Region/sim&lt;/summary&gt;
-        public uint LocalID;
-        /// &lt;summary&gt;Avatar First Name (i.e. Philip)&lt;/summary&gt;
-        public string FirstName = String.Empty;
-        /// &lt;summary&gt;Avatar Last Name (i.e. Linden)&lt;/summary&gt;
-        public string LastName = String.Empty;
-        /// &lt;summary&gt;Positive and negative ratings&lt;/summary&gt;
-        /// &lt;remarks&gt;This information is read-only and any changes will not be
-        /// reflected on the server&lt;/remarks&gt;
-        public Avatar.Statistics ProfileStatistics = new Avatar.Statistics();
-        /// &lt;summary&gt;Avatar properties including about text, profile URL, image IDs and 
-        /// publishing settings&lt;/summary&gt;
-        /// &lt;remarks&gt;If you change fields in this struct, the changes will not
-        /// be reflected on the server until you call SetAvatarInformation&lt;/remarks&gt;
-        public Avatar.Properties ProfileProperties = new Avatar.Properties();
-        /// &lt;summary&gt;Avatar interests including spoken languages, skills, and &quot;want to&quot;
-        /// choices&lt;/summary&gt;
-        /// &lt;remarks&gt;If you change fields in this struct, the changes will not
-        /// be reflected on the server until you call SetAvatarInformation&lt;/remarks&gt;
-        public Avatar.Interests ProfileInterests = new Avatar.Interests();
-        /// &lt;summary&gt;Current position of avatar&lt;/summary&gt;
-        public LLVector3 Position = LLVector3.Zero;
-        /// &lt;summary&gt;Current rotation of avatar&lt;/summary&gt;
-        public LLQuaternion Rotation = LLQuaternion.Identity;
-        /// &lt;summary&gt;The point the avatar is currently looking at
-        /// (may not stay updated)&lt;/summary&gt;
-        public LLVector3 LookAt = LLVector3.Zero;
-        /// &lt;summary&gt;Position avatar client will goto when login to 'home' or during
-        /// teleport request to 'home' region.&lt;/summary&gt;
-        public LLVector3 HomePosition = LLVector3.Zero;
-        /// &lt;summary&gt;LookAt point saved/restored with HomePosition&lt;/summary&gt;
-        public LLVector3 HomeLookAt = LLVector3.Zero;
-        /// &lt;summary&gt;Used for camera and control key state tracking&lt;/summary&gt;
-        public MainAvatarStatus Status;
-        /// &lt;summary&gt;The UUID of your root inventory folder&lt;/summary&gt;
-        public LLUUID InventoryRootFolderUUID;
-
-        
-        /// &lt;summary&gt;Gets the health of the agent&lt;/summary&gt;
-        public float Health
-        {
-            get { return health; }
-        }
-        
-        /// &lt;summary&gt;Gets the current balance of the agent&lt;/summary&gt;
-        public int Balance
-        {
-            get { return balance; }
-        }
-
-        /// &lt;summary&gt;Gets the local ID of the prim the avatar is sitting on,
-        /// zero if the avatar is not currently sitting&lt;/summary&gt;
-        public uint SittingOn
-        {
-            get { return sittingOn; }
-        }
-		
-		/// &lt;summary&gt;Gets the UUID of the active group.&lt;/summary&gt;
-		public LLUUID ActiveGroup
-		{
-			get { return activeGroup; }
-		}
-
-        internal uint sittingOn = 0;
-        internal string teleportMessage = String.Empty;
-
-        private SecondLife Client;
-        private TeleportCallback OnBeginTeleport;
-        private TeleportStatus TeleportStat;
-        private Timer TeleportTimer;
-        private bool TeleportTimeout;
-        private uint HeightWidthGenCounter;
-        private float health = 0.0f;
-        private int balance = 0;
-		private LLUUID activeGroup;
-
-        /// &lt;summary&gt;
-        /// Constructor, setup callbacks for packets related to our avatar
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
-        public MainAvatar(SecondLife client)
-        {
-            NetworkManager.PacketCallback callback;
-            Client = client;
-
-            Status = new MainAvatarStatus(Client);
-
-            // Coarse location callback
-            Client.Network.RegisterCallback(PacketType.CoarseLocationUpdate, new NetworkManager.PacketCallback(CoarseLocationHandler));
-
-            // Teleport callbacks
-            callback = new NetworkManager.PacketCallback(TeleportHandler);
-            Client.Network.RegisterCallback(PacketType.TeleportStart, callback);
-            Client.Network.RegisterCallback(PacketType.TeleportProgress, callback);
-            Client.Network.RegisterCallback(PacketType.TeleportFailed, callback);
-            Client.Network.RegisterCallback(PacketType.TeleportFinish, callback);
-
-            // Instant Message callback
-            Client.Network.RegisterCallback(PacketType.ImprovedInstantMessage, new NetworkManager.PacketCallback(InstantMessageHandler));
-
-            // Chat callback
-            Client.Network.RegisterCallback(PacketType.ChatFromSimulator, new NetworkManager.PacketCallback(ChatHandler));
-
-            // Script dialog callback
-            Client.Network.RegisterCallback(PacketType.ScriptDialog, new NetworkManager.PacketCallback(ScriptDialogHandler));
-
-            // Teleport timeout timer
-            TeleportTimer = new Timer(Client.Settings.TELEPORT_TIMEOUT);
-            TeleportTimer.Elapsed += new ElapsedEventHandler(TeleportTimerEvent);
-            TeleportTimeout = false;
-
-            // Movement complete callback
-            Client.Network.RegisterCallback(PacketType.AgentMovementComplete, new NetworkManager.PacketCallback(MovementCompleteHandler));
-
-            // Health callback
-            Client.Network.RegisterCallback(PacketType.HealthMessage, new NetworkManager.PacketCallback(HealthHandler));
-
-            // Money callbacks
-            callback = new NetworkManager.PacketCallback(BalanceHandler);
-            Client.Network.RegisterCallback(PacketType.MoneyBalanceReply, callback);
-            Client.Network.RegisterCallback(PacketType.MoneySummaryReply, callback);
-            Client.Network.RegisterCallback(PacketType.AdjustBalance, callback);
-
-            // Group callbacks
-            Client.Network.RegisterCallback(PacketType.JoinGroupReply, new NetworkManager.PacketCallback(JoinGroupHandler));
-            Client.Network.RegisterCallback(PacketType.LeaveGroupReply, new NetworkManager.PacketCallback(LeaveGroupHandler));
-            Client.Network.RegisterCallback(PacketType.AgentDropGroup, new NetworkManager.PacketCallback(DropGroupHandler));
-
-            // Viewer effect callback
-            Client.Network.RegisterCallback(PacketType.ViewerEffect, new NetworkManager.PacketCallback(ViewerEffectHandler));
-			
-			//Agent Update Callback
-			Client.Network.RegisterCallback(PacketType.AgentDataUpdate, new NetworkManager.PacketCallback(AgentDataUpdateHandler));
-
-	        // Event queue callback (used for Caps teleports currently)
-	        Client.Network.RegisterEventCallback(new NetworkManager.EventQueueCallback(EventQueueHandler));
-        }
-
-        /// &lt;summary&gt;
-        /// Send an Instant Message
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
-        /// &lt;param name=&quot;message&quot;&gt;Text Message being sent.&lt;/param&gt;
-        public void InstantMessage(LLUUID target, string message)
-        {
-            InstantMessage(FirstName + &quot; &quot; + LastName, LLUUID.Random(), target, message, null, LLUUID.Random());
-        }
-
-		/// &lt;summary&gt;
-		/// Send an Instant Message, used for dialog responses.
-		/// &lt;/summary&gt;
-		/// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
-		/// &lt;param name=&quot;dialog&quot;&gt;Dialog code to be sent.&lt;/param&gt;
-		public void InstantMessage(LLUUID target, InstantMessageDialog dialog)
-		{
-			InstantMessage(FirstName + &quot; &quot; + LastName, LLUUID.Random(), target, String.Empty, null, LLUUID.Random(), dialog);
-		}
-
-        /// &lt;summary&gt;
-        /// Send an Instant Message
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
-        /// &lt;param name=&quot;message&quot;&gt;Text Message being sent.&lt;/param&gt;
-        /// &lt;param name=&quot;IMSessionID&quot;&gt;IM Session ID&lt;/param&gt;
-        public void InstantMessage(LLUUID target, string message, LLUUID IMSessionID)
-        {
-            InstantMessage(FirstName + &quot; &quot; + LastName, LLUUID.Random(), target, message, null, IMSessionID);
-        }
-
-        /// &lt;summary&gt;
-        /// Send an Instant Message
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;fromName&quot;&gt;Client's Avatar&lt;/param&gt;
-        /// &lt;param name=&quot;sessionID&quot;&gt;SessionID of current connection to grid&lt;/param&gt;
-        /// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
-        /// &lt;param name=&quot;message&quot;&gt;Text Message being sent.&lt;/param&gt;
-        /// &lt;param name=&quot;conferenceIDs&quot;&gt;&lt;/param&gt;
-        public void InstantMessage(string fromName, LLUUID sessionID, LLUUID target, string message, LLUUID[] conferenceIDs)
-        {
-            InstantMessage(fromName, sessionID, target, message, conferenceIDs, LLUUID.Random());
-        }
-
-        /// &lt;summary&gt;
-        /// Send an Instant Message
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;fromName&quot;&gt;The name this IM will show up as being from&lt;/param&gt;
-        /// &lt;param name=&quot;sessionID&quot;&gt;Session ID of current connection to grid&lt;/param&gt;
-        /// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
-        /// &lt;param name=&quot;message&quot;&gt;Text message being sent&lt;/param&gt;
-        /// &lt;param name=&quot;conferenceIDs&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;IMSessionID&quot;&gt;IM session ID (to differentiate between IM windows)&lt;/param&gt;
-		public void InstantMessage(string fromName, LLUUID sessionID, LLUUID target, string message,
-			LLUUID[] conferenceIDs, LLUUID IMSessionID)
-		{
-			InstantMessage(fromName, sessionID, target, message, conferenceIDs, IMSessionID, InstantMessageDialog.MessageFromAgent);
-		}
-
-        /// &lt;summary&gt;
-        /// Send an Instant Message
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;fromName&quot;&gt;The name this IM will show up as being from&lt;/param&gt;
-        /// &lt;param name=&quot;sessionID&quot;&gt;Session ID of current connection to grid&lt;/param&gt;
-        /// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
-        /// &lt;param name=&quot;message&quot;&gt;Text message being sent&lt;/param&gt;
-        /// &lt;param name=&quot;conferenceIDs&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;IMSessionID&quot;&gt;IM session ID (to differentiate between IM windows)&lt;/param&gt;
-        public void InstantMessage(string fromName, LLUUID sessionID, LLUUID target, string message,
-            LLUUID[] conferenceIDs, LLUUID IMSessionID, InstantMessageDialog dialog)
-        {
-            ImprovedInstantMessagePacket im = new ImprovedInstantMessagePacket();
-            im.AgentData.AgentID = this.ID;
-            im.AgentData.SessionID = Client.Network.SessionID;
-            im.MessageBlock.Dialog = (byte)dialog;
-            im.MessageBlock.FromAgentName = Helpers.StringToField(fromName);
-            im.MessageBlock.FromGroup = false;
-            im.MessageBlock.ID = IMSessionID;
-            im.MessageBlock.Message = Helpers.StringToField(message);
-            im.MessageBlock.Offline = 1;
-            im.MessageBlock.ToAgentID = target;
-            if (conferenceIDs != null &amp;&amp; conferenceIDs.Length &gt; 0)
-            {
-                im.MessageBlock.BinaryBucket = new byte[16 * conferenceIDs.Length];
-
-                for (int i = 0; i &lt; conferenceIDs.Length; ++i)
-                {
-                    Array.Copy(conferenceIDs[i].Data, 0, im.MessageBlock.BinaryBucket, i * 16, 16);
-                }
-            }
-            else
-            {
-                im.MessageBlock.BinaryBucket = new byte[0];
-            }
-
-            // These fields are mandatory, even if we don't have valid values for them
-            im.MessageBlock.Position = LLVector3.Zero;
-            //TODO: Allow region id to be correctly set by caller or fetched from Client.*
-            im.MessageBlock.RegionID = LLUUID.Zero;
-
-            // Send the message
-            Client.Network.SendPacket(im);
-        }
-
-        /// &lt;summary&gt;
-        /// 
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;sourceAvatar&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;targetObject&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;globalOffset&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
-        public void PointAtEffect(LLUUID sourceAvatar, LLUUID targetObject, LLVector3d globalOffset, PointAtType type)
-        {
-            ViewerEffectPacket effect = new ViewerEffectPacket();
-            effect.Effect = new ViewerEffectPacket.EffectBlock[1];
-            effect.Effect[0] = new ViewerEffectPacket.EffectBlock();
-            effect.Effect[0].Color = LLColor.Black.GetBytes();
-            effect.Effect[0].Duration = (type == PointAtType.Clear) ? 0.0f : Single.MaxValue / 4.0f;
-            effect.Effect[0].ID = LLUUID.Random();
-            effect.Effect[0].Type = (byte)EffectType.PointAt;
-
-            byte[] typeData = new byte[57];
-            if (sourceAvatar != null)
-                Array.Copy(sourceAvatar.GetBytes(), typeData, 16);
-            if (targetObject != null)
-                Array.Copy(targetObject.GetBytes(), 0, typeData, 16, 16);
-            Array.Copy(globalOffset.GetBytes(), 0, typeData, 32, 24);
-            typeData[56] = (byte)type;
-
-            effect.Effect[0].TypeData = typeData;
-
-            Client.Network.SendPacket(effect);
-        }
-
-        /// &lt;summary&gt;
-        /// 
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;sourceAvatar&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;targetObject&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;globalOffset&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;color&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;duration&quot;&gt;&lt;/param&gt;
-        public void BeamEffect(LLUUID sourceAvatar, LLUUID targetObject, LLVector3d globalOffset, LLColor color, 
-            float duration)
-        {
-            ViewerEffectPacket effect = new ViewerEffectPacket();
-            effect.Effect = new ViewerEffectPacket.EffectBlock[1];
-            effect.Effect[0] = new ViewerEffectPacket.EffectBlock();
-            effect.Effect[0].Color = color.GetBytes();
-            effect.Effect[0].Duration = duration;
-            effect.Effect[0].ID = LLUUID.Random();
-            effect.Effect[0].Type = (byte)EffectType.Beam;
-
-            byte[] typeData = new byte[56];
-            if (sourceAvatar != null)
-                Array.Copy(sourceAvatar.GetBytes(), 0, typeData, 0, 16);
-            if (targetObject != null)
-                Array.Copy(targetObject.GetBytes(), 0, typeData, 16, 16);
-            Array.Copy(globalOffset.GetBytes(), 0, typeData, 32, 24);
-
-            effect.Effect[0].TypeData = typeData;
-
-            Client.Network.SendPacket(effect);
-        }
-
-        /// &lt;summary&gt;
-        /// 
-        /// &lt;/summary&gt;
-        public void LookAtEffect()
-        {
-        }
-
-        /// &lt;summary&gt;
-        /// Synchronize the local profile and interests information to the server
-        /// &lt;/summary&gt;
-        public void SetAvatarInformation()
-        {
-            // Basic profile properties
-            AvatarPropertiesUpdatePacket apup = new AvatarPropertiesUpdatePacket();
-
-            apup.AgentData.AgentID = this.ID;
-            apup.AgentData.SessionID = Client.Network.SessionID;
-            apup.PropertiesData.AboutText = Helpers.StringToField(this.ProfileProperties.AboutText);
-            apup.PropertiesData.AllowPublish = this.ProfileProperties.AllowPublish;
-            apup.PropertiesData.FLAboutText = Helpers.StringToField(this.ProfileProperties.FirstLifeText);
-            apup.PropertiesData.FLImageID = this.ProfileProperties.FirstLifeImage;
-            apup.PropertiesData.ImageID = this.ProfileProperties.ProfileImage;
-            apup.PropertiesData.MaturePublish = this.ProfileProperties.MaturePublish;
-            apup.PropertiesData.ProfileURL = Helpers.StringToField(this.ProfileProperties.ProfileURL);
-
-            // Interests
-            AvatarInterestsUpdatePacket aiup = new AvatarInterestsUpdatePacket();
-
-            aiup.AgentData.AgentID = this.ID;
-            aiup.AgentData.SessionID = Client.Network.SessionID;
-            aiup.PropertiesData.LanguagesText = Helpers.StringToField(this.ProfileInterests.LanguagesText);
-            aiup.PropertiesData.SkillsMask = this.ProfileInterests.SkillsMask;
-            aiup.PropertiesData.SkillsText = Helpers.StringToField(this.ProfileInterests.SkillsText);
-            aiup.PropertiesData.WantToMask = this.ProfileInterests.WantToMask;
-            aiup.PropertiesData.WantToText = Helpers.StringToField(this.ProfileInterests.WantToText);
-
-            //Send packets
-            Client.Network.SendPacket(apup);
-            Client.Network.SendPacket(aiup);
-        }
-
-        /// &lt;summary&gt;
-        /// Send a chat message
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;message&quot;&gt;The Message you're sending out.&lt;/param&gt;
-        /// &lt;param name=&quot;channel&quot;&gt;Channel number (0 would be default 'Say' message, other numbers 
-        /// denote the equivalent of /# in normal client).&lt;/param&gt;
-        /// &lt;param name=&quot;type&quot;&gt;Chat Type, see above.&lt;/param&gt;
-        public void Chat(string message, int channel, ChatType type)
-        {
-            ChatFromViewerPacket chat = new ChatFromViewerPacket();
-            chat.AgentData.AgentID = this.ID;
-            chat.AgentData.SessionID = Client.Network.SessionID;
-            chat.ChatData.Channel = channel;
-            chat.ChatData.Message = Helpers.StringToField(message);
-            chat.ChatData.Type = (byte)type;
-
-            Client.Network.SendPacket(chat);
-        }
-
-        /// &lt;summary&gt;
-        /// Set the height and the width of the client window. This is used
-        /// by the server to build a virtual camera frustum for our avatar
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;height&quot;&gt;New height of the viewer window&lt;/param&gt;
-        /// &lt;param name=&quot;width&quot;&gt;New width of the viewer window&lt;/param&gt;
-        public void SetHeightWidth(ushort height, ushort width)
-        {
-            AgentHeightWidthPacket heightwidth = new AgentHeightWidthPacket();
-            heightwidth.AgentData.AgentID = Client.Network.AgentID;
-            heightwidth.AgentData.SessionID = Client.Network.SessionID;
-            heightwidth.AgentData.CircuitCode = Client.Network.CurrentSim.CircuitCode;
-            heightwidth.HeightWidthBlock.Height = height;
-            heightwidth.HeightWidthBlock.Width = width;
-            heightwidth.HeightWidthBlock.GenCounter = HeightWidthGenCounter++;
-
-            Client.Network.SendPacket(heightwidth);
-        }
-
-        /// &lt;summary&gt;
-        /// Sends a request to sit on the specified object
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;targetID&quot;&gt;LLUUID of the object to sit on&lt;/param&gt;
-        /// &lt;param name=&quot;offset&quot;&gt;Sit at offset&lt;/param&gt;
-        public void RequestSit(LLUUID targetID, LLVector3 offset)
-        {
-            AgentRequestSitPacket requestSit = new AgentRequestSitPacket();
-            requestSit.AgentData.AgentID = Client.Network.AgentID;
-            requestSit.AgentData.SessionID = Client.Network.SessionID;
-            requestSit.TargetObject.TargetID = targetID;
-            requestSit.TargetObject.Offset = offset;
-            Client.Network.SendPacket(requestSit);
-        }
-
-        /// &lt;summary&gt;
-        /// Request the list of muted things for this avatar
-        /// &lt;/summary&gt;
-        public void RequestMuteList()
-        {
-            MuteListRequestPacket mute = new MuteListRequestPacket();
-            mute.AgentData.AgentID = Client.Network.AgentID;
-            mute.AgentData.SessionID = Client.Network.SessionID;
-            mute.MuteData.MuteCRC = 0;
-
-            Client.Network.SendPacket(mute);
-        }
-
-        /// &lt;summary&gt;
-        /// Request the current L$ balance
-        /// &lt;/summary&gt;
-        public void RequestBalance()
-        {
-            MoneyBalanceRequestPacket money = new MoneyBalanceRequestPacket();
-            money.AgentData.AgentID = Client.Network.AgentID;
-            money.AgentData.SessionID = Client.Network.SessionID;
-            money.MoneyData.TransactionID = LLUUID.Zero;
-
-            Client.Network.SendPacket(money);
-        }
-
-        /// &lt;summary&gt;
-        /// Set the always running toggle on the server
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;alwaysRun&quot;&gt;Whether the avatar should always run or not&lt;/param&gt;
-        public void SetAlwaysRun(bool alwaysRun)
-        {
-            SetAlwaysRunPacket run = new SetAlwaysRunPacket();
-            run.AgentData.AgentID = Client.Network.AgentID;
-            run.AgentData.SessionID = Client.Network.SessionID;
-            run.AgentData.AlwaysRun = alwaysRun;
-
-            Client.Network.SendPacket(run);
-        }
-
-        /// &lt;summary&gt;
-        /// Follows a call to RequestSit() to actually sit on the object
-        /// &lt;/summary&gt;
-        public void Sit()
-        {
-            AgentSitPacket sit = new AgentSitPacket();
-            sit.AgentData.AgentID = Client.Network.AgentID;
-            sit.AgentData.SessionID = Client.Network.SessionID;
-            Client.Network.SendPacket(sit);
-        }
-
-        /// &lt;summary&gt;
-        /// Give Money to destination Avatar
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;target&quot;&gt;UUID of the Target Avatar&lt;/param&gt;
-        /// &lt;param name=&quot;amount&quot;&gt;Amount in L$&lt;/param&gt;
-        /// &lt;param name=&quot;description&quot;&gt;Reason (optional normally)&lt;/param&gt;
-        public void GiveMoney(LLUUID target, int amount, string description)
-        {
-            // 5001 - transaction type for av to av money transfers
-            if (amount &gt; 0)
-                GiveMoney(target, amount, description, 5001);
-            else
-                Client.Log(&quot;Attempted to pay zero or negative value &quot; + amount, Helpers.LogLevel.Warning);
-        }
-
-        /// &lt;summary&gt;
-        /// Give Money to destionation Object or Avatar
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;target&quot;&gt;UUID of the Target Object/Avatar&lt;/param&gt;
-        /// &lt;param name=&quot;amount&quot;&gt;Amount in L$&lt;/param&gt;
-        /// &lt;param name=&quot;description&quot;&gt;Reason (Optional normally)&lt;/param&gt;
-        /// &lt;param name=&quot;transactiontype&quot;&gt;The type of transaction.  Currently only 5001 is
-        /// documented for Av-&gt;Av money transfers.&lt;/param&gt;
-        public void GiveMoney(LLUUID target, int amount, string description, int transactiontype)
-        {
-            MoneyTransferRequestPacket money = new MoneyTransferRequestPacket();
-            money.AgentData.AgentID = this.ID;
-            money.AgentData.SessionID = Client.Network.SessionID;
-            money.MoneyData.Description = Helpers.StringToField(description);
-            money.MoneyData.DestID = target;
-            money.MoneyData.SourceID = this.ID;
-            money.MoneyData.TransactionType = transactiontype;
-            money.MoneyData.AggregatePermInventory = 0; //TODO: whats this?
-            money.MoneyData.AggregatePermNextOwner = 0; //TODO: whats this?
-            money.MoneyData.Flags = 0; //TODO: whats this?
-            money.MoneyData.Amount = amount;
-
-            Client.Network.SendPacket(money);
-        }
-
-        /// &lt;summary&gt;
-        /// Send an AgentAnimation packet that toggles a single animation on
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;animation&quot;&gt;The animation to start playing&lt;/param&gt;
-        public void AnimationStart(LLUUID animation)
-        {
-            Dictionary&lt;LLUUID, bool&gt; animations = new Dictionary&lt;LLUUID, bool&gt;();
-            animations[animation] = true;
-
-            Animate(animations);
-        }
-
-        /// &lt;summary&gt;
-        /// Send an AgentAnimation packet that toggles a single animation off
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;animation&quot;&gt;The animation to stop playing&lt;/param&gt;
-        public void AnimationStop(LLUUID animation)
-        {
-            Dictionary&lt;LLUUID, bool&gt; animations = new Dictionary&lt;LLUUID, bool&gt;();
-            animations[animation] = false;
-
-            Animate(animations);
-        }
-
-        /// &lt;summary&gt;
-        /// Send an AgentAnimation packet that will toggle animations on or off
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;animations&quot;&gt;A list of animation UUIDs, and whether to
-        /// turn that animation on or off&lt;/param&gt;
-        public void Animate(Dictionary&lt;LLUUID, bool&gt; animations)
-        {
-            AgentAnimationPacket animate = new AgentAnimationPacket();
-
-            animate.AgentData.AgentID = Client.Network.AgentID;
-            animate.AgentData.SessionID = Client.Network.SessionID;
-            animate.AnimationList = new AgentAnimationPacket.AnimationListBlock[animations.Count];
-            int i = 0;
-
-            foreach (KeyValuePair&lt;LLUUID, bool&gt; animation in animations)
-            {
-                animate.AnimationList[i] = new AgentAnimationPacket.AnimationListBlock();
-                animate.AnimationList[i].AnimID = animation.Key;
-                animate.AnimationList[i].StartAnim = animation.Value;
-
-                i++;
-            }
-
-            Client.Network.SendPacket(animate);
-        }
-
-        /// &lt;summary&gt;
-        /// Use the autopilot sim function to move the avatar to a new position
-        /// &lt;/summary&gt;
-        /// &lt;remarks&gt;The z value is currently not handled properly by the simulator&lt;/remarks&gt;
-        /// &lt;param name=&quot;globalX&quot;&gt;Integer value for the global X coordinate to move to&lt;/param&gt;
-        /// &lt;param name=&quot;globalY&quot;&gt;Integer value for the global Y coordinate to move to&lt;/param&gt;
-        /// &lt;param name=&quot;z&quot;&gt;Floating-point value for the Z coordinate to move to&lt;/param&gt;
-        /// &lt;example&gt;AutoPilot(252620, 247078, 20.2674);&lt;/example&gt;
-        public void AutoPilot(ulong globalX, ulong globalY, float z)
-        {
-            GenericMessagePacket autopilot = new GenericMessagePacket();
-
-            autopilot.AgentData.AgentID = Client.Network.AgentID;
-            autopilot.AgentData.SessionID = Client.Network.SessionID;
-            autopilot.MethodData.Invoice = LLUUID.Zero;
-            autopilot.MethodData.Method = Helpers.StringToField(&quot;autopilot&quot;);
-            autopilot.ParamList = new GenericMessagePacket.ParamListBlock[3];
-            autopilot.ParamList[0] = new GenericMessagePacket.ParamListBlock();
-            autopilot.ParamList[0].Parameter = Helpers.StringToField(globalX.ToString());
-            autopilot.ParamList[1] = new GenericMessagePacket.ParamListBlock();
-            autopilot.ParamList[1].Parameter = Helpers.StringToField(globalY.ToString());
-            autopilot.ParamList[2] = new GenericMessagePacket.ParamListBlock();
-            // TODO: Do we need to prevent z coordinates from being sent in 1.4827e-18 notation?
-            autopilot.ParamList[2].Parameter = Helpers.StringToField(z.ToString());
-
-            Client.Network.SendPacket(autopilot);
-        }
-
-        /// &lt;summary&gt;
-        /// Use the autopilot sim function to move the avatar to a new position
-        /// &lt;/summary&gt;
-        /// &lt;remarks&gt;The z value is currently not handled properly by the simulator&lt;/remarks&gt;
-        /// &lt;param name=&quot;localX&quot;&gt;Integer value for the local X coordinate to move to&lt;/param&gt;
-        /// &lt;param name=&quot;localY&quot;&gt;Integer value for the local Y coordinate to move to&lt;/param&gt;
-        /// &lt;param name=&quot;z&quot;&gt;Floating-point value for the Z coordinate to move to&lt;/param&gt;
-        /// &lt;example&gt;AutoPilot(252620, 247078, 20.2674);&lt;/example&gt;
-        public void AutoPilotLocal(int localX, int localY, float z)
-        {
-            uint x, y;
-            Helpers.LongToUInts(Client.Network.CurrentSim.Region.Handle, out x, out y);
-            AutoPilot((ulong)(x + localX), (ulong)(y + localY), z);
-        }
-
-        /// &lt;summary&gt;
-        /// Start a teleport process
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
-        /// &lt;param name=&quot;tc&quot;&gt;Callback ID&lt;/param&gt;
-        public void BeginTeleport(ulong regionHandle, LLVector3 position, TeleportCallback tc)
-        {
-            BeginTeleport(regionHandle, position, new LLVector3(position.X + 1.0f, position.Y, position.Z), tc);
-        }
-
-        /// &lt;summary&gt;
-        /// Start a teleport process
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
-        /// &lt;param name=&quot;lookAt&quot;&gt;Target to look at&lt;/param&gt;
-        /// &lt;param name=&quot;tc&quot;&gt;Callback ID&lt;/param&gt;
-        public void BeginTeleport(ulong regionHandle, LLVector3 position, LLVector3 lookAt, TeleportCallback tc)
-        {
-            OnBeginTeleport = tc;
-
-            TeleportLocationRequestPacket teleport = new TeleportLocationRequestPacket();
-            teleport.AgentData.AgentID = Client.Network.AgentID;
-            teleport.AgentData.SessionID = Client.Network.SessionID;
-            teleport.Info.LookAt = lookAt;
-            teleport.Info.Position = position;
-            teleport.Info.RegionHandle = regionHandle;
-
-            Client.Log(&quot;Teleporting to region &quot; + regionHandle.ToString(), Helpers.LogLevel.Info);
-
-            Client.Network.SendPacket(teleport);
-        }
-
-        /// &lt;summary&gt;
-        /// Start a teleport process
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-        public bool Teleport(ulong regionHandle, LLVector3 position)
-        {
-            return Teleport(regionHandle, position, new LLVector3(position.X + 1.0f, position.Y, position.Z));
-        }
-
-        /// &lt;summary&gt;
-        /// Start a teleport process
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
-        /// &lt;param name=&quot;lookAt&quot;&gt;Target to look at&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-        public bool Teleport(ulong regionHandle, LLVector3 position, LLVector3 lookAt)
-        {
-            TeleportStat = TeleportStatus.None;
-
-            TeleportLocationRequestPacket teleport = new TeleportLocationRequestPacket();
-            teleport.AgentData.AgentID = Client.Network.AgentID;
-            teleport.AgentData.SessionID = Client.Network.SessionID;
-            teleport.Info.LookAt = lookAt;
-            teleport.Info.Position = position;
-
-            teleport.Info.RegionHandle = regionHandle;
-
-            Client.Log(&quot;Teleporting to region &quot; + regionHandle.ToString(), Helpers.LogLevel.Info);
-
-            // Start the timeout check
-            TeleportTimeout = false;
-            TeleportTimer.Start();
-
-            Client.Network.SendPacket(teleport);
-
-            // FIXME: Use a ManualResetEvent, Client.Tick() is bad
-            while (TeleportStat != TeleportStatus.Failed &amp;&amp; TeleportStat != TeleportStatus.Finished &amp;&amp; !TeleportTimeout)
-            {
-                Client.Tick();
-            }
-
-            TeleportTimer.Stop();
-
-            if (TeleportTimeout)
-            {
-                teleportMessage = &quot;Teleport timed out.&quot;;
-                TeleportStat = TeleportStatus.Failed;
-
-                if (OnTeleport != null) { OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat); }
-            }
-            else
-            {
-                if (OnTeleport != null) { OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat); }
-            }
-
-            return (TeleportStat == TeleportStatus.Finished);
-        }
-
-        /// &lt;summary&gt;
-        /// Generic Teleport Function
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;simName&quot;&gt;Region name&lt;/param&gt;
-        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-        public bool Teleport(string simName, LLVector3 position)
-        {
-            //position.Z = 0; //why was this here?
-            return Teleport(simName, position, new LLVector3(0, 1.0F, 0));
-        }
-
-        /// &lt;summary&gt;
-        /// Teleport Function
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;simName&quot;&gt;Region name&lt;/param&gt;
-        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
-        /// &lt;param name=&quot;lookAt&quot;&gt;Target to look at&lt;/param&gt;
-        /// &lt;returns&gt;&lt;/returns&gt;
-        public bool Teleport(string simName, LLVector3 position, LLVector3 lookAt)
-        {
-            int attempts = 0;
-            TeleportStat = TeleportStatus.None;
-
-            simName = simName.ToLower();
-
-            GridRegion region = Client.Grid.GetGridRegion(simName);
-
-            if (region != null)
-            {
-                return Teleport(region.RegionHandle, position, lookAt);
-            }
-            else
-            {
-                while (attempts++ &lt; 5)
-                {
-                    region = Client.Grid.GetGridRegion(simName);
-
-                    if (region != null)
-                    {
-                        return Teleport(region.RegionHandle, position, lookAt);
-                    }
-                    else
-                    {
-                        // Request the region info again
-                        Client.Grid.AddSim(simName);
-
-                        // FIXME: We shouldn't be sleeping in the library at all, hopefully this goes away soon
-                        System.Threading.Thread.Sleep(1000);
-                    }
-                }
-            }
-
-            if (OnTeleport != null)
-            {
-                teleportMessage = &quot;Unable to resolve name: &quot; + simName;
-                TeleportStat = TeleportStatus.Failed;
-                OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
-            }
-
-            return false;
-        }
-
-        /// &lt;summary&gt;
-        /// Respond to a teleport lure by either accepting it and initiating 
-        /// the teleport, or denying it
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;requesterID&quot;&gt;UUID of the avatar requesting the teleport&lt;/param&gt;
-        /// &lt;param name=&quot;accept&quot;&gt;Accept the teleport request or deny it&lt;/param&gt;
-        public void TeleportLureRespond(LLUUID requesterID, bool accept)
-        {
-			InstantMessage(requesterID, accept ? InstantMessageDialog.AcceptTeleport : InstantMessageDialog.DenyTeleport);
-
-            if (accept)
-            {
-                TeleportLureRequestPacket lure = new TeleportLureRequestPacket();
-
-                lure.Info.AgentID = Client.Network.AgentID;
-                lure.Info.SessionID = Client.Network.SessionID;
-                lure.Info.LureID = Client.Network.AgentID;
-                lure.Info.TeleportFlags = 4; // TODO: What does this mean?
-
-                Client.Network.SendPacket(lure);
-            }
-        }
-
-        /// &lt;summary&gt;
-        /// Grabs an object
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;objectLocalID&quot;&gt;Local ID of Object to grab&lt;/param&gt;
-        public void Grab(uint objectLocalID)
-        {
-            ObjectGrabPacket grab = new ObjectGrabPacket();
-            grab.AgentData.AgentID = Client.Network.AgentID;
-            grab.AgentData.SessionID = Client.Network.SessionID;
-            grab.ObjectData.LocalID = objectLocalID;
-            grab.ObjectData.GrabOffset = new LLVector3(0, 0, 0);
-            Client.Network.SendPacket(grab);
-        }
-
-        /// &lt;summary&gt;
-        /// Drags on an object
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;objectID&quot;&gt;Strangely, LLUID instead of local ID&lt;/param&gt;
-        /// &lt;param name=&quot;grabPosition&quot;&gt;Drag target in region coordinates&lt;/param&gt;
-        public void GrabUpdate(LLUUID objectID, LLVector3 grabPosition)
-        {
-            ObjectGrabUpdatePacket grab = new ObjectGrabUpdatePacket();
-            grab.AgentData.AgentID = Client.Network.AgentID;
-            grab.AgentData.SessionID = Client.Network.SessionID;
-            grab.ObjectData.ObjectID = objectID;
-            grab.ObjectData.GrabOffsetInitial = new LLVector3(0, 0, 0);
-            grab.ObjectData.GrabPosition = grabPosition;
-            grab.ObjectData.TimeSinceLast = 0;
-            Client.Network.SendPacket(grab);
-        }
-
-        /// &lt;summary&gt;
-        /// Releases a grabbed object
-        /// &lt;/summary&gt;
-        public void DeGrab(uint objectLocalID)
-        {
-            ObjectDeGrabPacket degrab = new ObjectDeGrabPacket();
-            degrab.AgentData.AgentID = Client.Network.AgentID;
-            degrab.AgentData.SessionID = Client.Network.SessionID;
-            degrab.ObjectData.LocalID = objectLocalID;
-            Client.Network.SendPacket(degrab);
-        }
-
-        /// &lt;summary&gt;
-        /// Touches an object
-        /// &lt;/summary&gt;
-        public void Touch(uint objectLocalID)
-        {
-            Client.Self.Grab(objectLocalID);
-            Client.Self.DeGrab(objectLocalID);
-        }
-
-        /// &lt;summary&gt;
-        /// Request to join a group. If there is an enrollment fee it will 
-        /// automatically be deducted from your balance
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;groupID&quot;&gt;The group to attempt to join&lt;/param&gt;
-        public void RequestJoinGroup(LLUUID groupID)
-        {
-            JoinGroupRequestPacket join = new JoinGroupRequestPacket();
-
-            join.AgentData.AgentID = Client.Network.AgentID;
-            join.AgentData.SessionID = Client.Network.SessionID;
-            join.GroupData.GroupID = groupID;
-
-            Client.Network.SendPacket(join);
-        }
-
-        /// &lt;summary&gt;
-        /// Request to leave a group
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;groupID&quot;&gt;The group to attempt to leave&lt;/param&gt;
-        public void RequestLeaveGroup(LLUUID groupID)
-        {
-            LeaveGroupRequestPacket leave = new LeaveGroupRequestPacket();
-
-            leave.AgentData.AgentID = Client.Network.AgentID;
-            leave.AgentData.SessionID = Client.Network.SessionID;
-            leave.GroupData.GroupID = groupID;
-
-            Client.Network.SendPacket(leave);
-        }
-
-        /// &lt;summary&gt;
-        /// Set our current active group
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;groupID&quot;&gt;The group we are a member of that we want to 
-        /// activate&lt;/param&gt;
-        public void ActivateGroup(LLUUID groupID)
-        {
-            ActivateGroupPacket activate = new ActivateGroupPacket();
-
-            activate.AgentData.AgentID = Client.Network.AgentID;
-            activate.AgentData.SessionID = Client.Network.SessionID;
-            activate.AgentData.GroupID = groupID;
-
-            Client.Network.SendPacket(activate);
-        }
-
-        /// &lt;summary&gt;
-        /// Move an agent in to a simulator. This packet is the last packet
-        /// needed to complete the transition in to a new simulator
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
-        public void CompleteAgentMovement(Simulator simulator)
-        {
-            CompleteAgentMovementPacket move = new CompleteAgentMovementPacket();
-
-            move.AgentData.AgentID = Client.Network.AgentID;
-            move.AgentData.SessionID = Client.Network.SessionID;
-            move.AgentData.CircuitCode = simulator.CircuitCode;
-
-            Client.Network.SendPacket(move, simulator);
-        }
-
-        /// &lt;summary&gt;
-        /// Sends camera and action updates to the server including the 
-        /// position and orientation of our camera, and a ControlFlags field
-        /// specifying our current movement actions
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;reliable&quot;&gt;Whether to ensure this packet makes it to the server&lt;/param&gt;
-        public void UpdateCamera(Avatar.AgentUpdateFlags controlFlags, LLVector3 position, LLVector3 forwardAxis,
-            LLVector3 leftAxis, LLVector3 upAxis, LLQuaternion bodyRotation, LLQuaternion headRotation, float farClip,
-            bool reliable)
-        {
-            AgentUpdatePacket update = new AgentUpdatePacket();
-
-            update.AgentData.AgentID = Client.Network.AgentID;
-            update.AgentData.SessionID = Client.Network.SessionID;
-            update.AgentData.State = 0;
-            update.AgentData.BodyRotation = bodyRotation;
-            update.AgentData.HeadRotation = headRotation;
-            update.AgentData.CameraCenter = position;
-            update.AgentData.CameraAtAxis = forwardAxis;
-            update.AgentData.CameraLeftAxis = leftAxis;
-            update.AgentData.CameraUpAxis = upAxis;
-            update.AgentData.Far = farClip;
-            update.AgentData.ControlFlags = (uint)controlFlags;
-            update.AgentData.Flags = 0;
-            update.Header.Reliable = reliable;
-
-            Client.Network.SendPacket(update);
-        }
-
-        /// &lt;summary&gt;
-        /// [UNUSED - for now]
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;packet&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
-        private void CoarseLocationHandler(Packet packet, Simulator simulator)
-        {
-            if (packet.Type == PacketType.CoarseLocationUpdate)
-	    {
-                CoarseLocationUpdatePacket p = (CoarseLocationUpdatePacket) packet;
-
-                if (p.Index.You &lt; 0 || p.Index.You &gt;= p.Location.Length) return;
-                /* 1.5 and 6 represent a 50% fudge factor (hysteresis) -- bushing */
-                if (Math.Abs(Position.X-p.Location[p.Index.You].X) &gt; 1.5) Position.X=p.Location[p.Index.You].X;
-                if (Math.Abs(Position.Y-p.Location[p.Index.You].Y) &gt; 1.5) Position.Y=p.Location[p.Index.You].Y;
-                if (Math.Abs(Position.Z-(p.Location[p.Index.You].Z*4)) &gt; 6) Position.Z=p.Location[p.Index.You].Z*4;
-            }
-        }
-
-        /// &lt;summary&gt;
-        /// Take an incoming ImprovedInstantMessage packet, auto-parse, and if
-        ///   OnInstantMessage is defined call that with the appropriate arguments.
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;packet&quot;&gt;Incoming ImprovedInstantMessagePacket&lt;/param&gt;
-        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
-        private void InstantMessageHandler(Packet packet, Simulator simulator)
-        {
-            if (packet.Type == PacketType.ImprovedInstantMessage)
-            {
-                ImprovedInstantMessagePacket im = (ImprovedInstantMessagePacket)packet;
-
-                if (OnInstantMessage != null)
-                {
-                    OnInstantMessage(
-                        im.AgentData.AgentID
-                        , Helpers.FieldToString(im.MessageBlock.FromAgentName),
-                        im.MessageBlock.ToAgentID
-                        , im.MessageBlock.ParentEstateID
-                        , im.MessageBlock.RegionID
-                        , im.MessageBlock.Position
-                        , im.MessageBlock.Dialog
-                        , im.MessageBlock.FromGroup
-                        , im.MessageBlock.ID
-                        , new DateTime(im.MessageBlock.Timestamp)
-                        , Helpers.FieldToString(im.MessageBlock.Message)
-                        , im.MessageBlock.Offline
-                        , im.MessageBlock.BinaryBucket
-                        );
-                }
-            }
-        }
-
-        /// &lt;summary&gt;
-        /// Take an incoming Chat packet, auto-parse, and if OnChat is defined call 
-        ///   that with the appropriate arguments.
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;packet&quot;&gt;Incoming ChatFromSimulatorPacket&lt;/param&gt;
-        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
-        private void ChatHandler(Packet packet, Simulator simulator)
-        {
-            if (OnChat != null)
-            {
-                ChatFromSimulatorPacket chat = (ChatFromSimulatorPacket)packet;
-
-                OnChat(Helpers.FieldToFilteredString(chat.ChatData.Message, new char())
-                    , chat.ChatData.Audible
-                    , chat.ChatData.ChatType
-                    , chat.ChatData.SourceType
-                    , Helpers.FieldToString(chat.ChatData.FromName)
-                    , chat.ChatData.SourceID
-                    , chat.ChatData.OwnerID
-                    , chat.ChatData.Position
-                    );
-            }
-        }
-
-        /// &lt;summary&gt;
-        /// Used for parsing llDialog's
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;packet&quot;&gt;Incoming ScriptDialog packet&lt;/param&gt;
-        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
-        private void ScriptDialogHandler(Packet packet, Simulator simulator)
-        {
-            if (OnScriptDialog != null)
-            {
-                ScriptDialogPacket dialog = (ScriptDialogPacket)packet;
-                List&lt;string&gt; buttons = new List&lt;string&gt;();
-
-                foreach (ScriptDialogPacket.ButtonsBlock button in dialog.Buttons)
-                {
-                    buttons.Add(Helpers.FieldToString(button.ButtonLabel));
-                }
-
-                OnScriptDialog(Helpers.FieldToString(dialog.Data.Message),
-                    Helpers.FieldToString(dialog.Data.ObjectName),
-                    dialog.Data.ImageID,
-                    dialog.Data.ObjectID,
-                    Helpers.FieldToString(dialog.Data.FirstName),
-                    Helpers.FieldToString(dialog.Data.LastName),
-                    dialog.Data.ChatChannel,
-                    buttons);
-            }
-        }
-
-        /// &lt;summary&gt;
-        /// Update client's Position, LookAt and region handle from incoming packet
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;packet&quot;&gt;Incoming AgentMovementCompletePacket&lt;/param&gt;
-        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
-        private void MovementCompleteHandler(Packet packet, Simulator simulator)
-        {
-            AgentMovementCompletePacket movement = (AgentMovementCompletePacket)packet;
-
-            this.Position = movement.Data.Position;
-            this.LookAt = movement.Data.LookAt;
-            simulator.Region.Handle = movement.Data.RegionHandle;
-        }
-
-        /// &lt;summary&gt;
-        /// Update Client Avatar's health via incoming packet
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;packet&quot;&gt;Incoming HealthMessagePacket&lt;/param&gt;
-        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
-        private void HealthHandler(Packet packet, Simulator simulator)
-        {
-            health = ((HealthMessagePacket)packet).HealthData.Health;
-        }
-
-        private void JoinGroupHandler(Packet packet, Simulator simulator)
-        {
-            if (OnJoinGroup != null)
-            {
-                JoinGroupReplyPacket reply = (JoinGroupReplyPacket)packet;
-
-                OnJoinGroup(reply.GroupData.GroupID, reply.GroupData.Success);
-            }
-        }
-
-        private void LeaveGroupHandler(Packet packet, Simulator simulator)
-        {
-            if (OnLeaveGroup != null)
-            {
-                LeaveGroupReplyPacket reply = (LeaveGroupReplyPacket)packet;
-
-                OnLeaveGroup(reply.GroupData.GroupID, reply.GroupData.Success);
-            }
-        }
-
-        public void AgentDataUpdateHandler(Packet packet, Simulator simulator)
-        {
-            AgentDataUpdatePacket p = (AgentDataUpdatePacket)packet;
-            if (p.AgentData.AgentID == simulator.Client.Network.AgentID) {
-                activeGroup = p.AgentData.ActiveGroupID;
-            }
-        }
-		
-        private void DropGroupHandler(Packet packet, Simulator simulator)
-        {
-            if (OnGroupDropped != null)
-            {
-                OnGroupDropped(((AgentDropGroupPacket)packet).AgentData.GroupID);
-            }
-        }
-
-        /// &lt;summary&gt;
-        /// Update Client Avatar's L$ balance from incoming packet
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;packet&quot;&gt;Incoming MoneyBalanceReplyPacket&lt;/param&gt;
-        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
-        private void BalanceHandler(Packet packet, Simulator simulator)
-        {
-            if (packet.Type == PacketType.MoneyBalanceReply)
-            {
-                balance = ((MoneyBalanceReplyPacket)packet).MoneyData.MoneyBalance;
-            }
-            else if (packet.Type == PacketType.MoneySummaryReply)
-            {
-                balance = ((MoneySummaryReplyPacket)packet).MoneyData.Balance;
-            }
-            else if (packet.Type == PacketType.AdjustBalance)
-            {
-                balance += ((AdjustBalancePacket)packet).AgentData.Delta;
-            }
-
-            if (OnBalanceUpdated != null)
-            {
-                OnBalanceUpdated(balance);
-            }
-        }
-
-	    private void EventQueueHandler(string message, object body)
-        {
-	        if(message == &quot;TeleportFinish&quot;)
-            {
-		        Hashtable tpt = (Hashtable)body;
-		        Hashtable info = (Hashtable)tpt[&quot;Info&quot;];
-
-		        // FIXME: quick and dirty hack
-		        TeleportFinishPacket packet = new TeleportFinishPacket();
-
-		        packet.Info.SimIP = Helpers.BytesToUInt((byte[])info[&quot;SimIP&quot;]);
-                packet.Info.LocationID = Helpers.BytesToUInt((byte[])info[&quot;LocationID&quot;]);
-                packet.Info.TeleportFlags = Helpers.BytesToUInt((byte[])info[&quot;TeleportFlags&quot;]);
-		        packet.Info.AgentID = (LLUUID)info[&quot;AgentID&quot;];
-                packet.Info.RegionHandle = Helpers.BytesToUInt64((byte[])info[&quot;RegionHandle&quot;]);
-		        packet.Info.SeedCapability = Helpers.StringToField((string)info[&quot;SeedCapability&quot;]);
-		        packet.Info.SimPort = (ushort)(long)info[&quot;SimPort&quot;];
-		        packet.Info.SimAccess = (byte)(long)info[&quot;SimAccess&quot;];
-
-		        TeleportHandler(packet,Client.Network.CurrentSim);
-	        }
-	    }
-
-        /// &lt;summary&gt;
-        /// Process an incoming effect
-        /// &lt;/summary&gt;
-        private void ViewerEffectHandler(Packet packet, Simulator simulator)
-        {
-            ViewerEffectPacket effect = (ViewerEffectPacket)packet;
-
-            foreach (ViewerEffectPacket.EffectBlock block in effect.Effect)
-            {
-                EffectType type;
-
-                try
-                {
-                    type = (EffectType)block.Type;
-                }
-                catch (Exception)
-                {
-                    Client.Log(&quot;Received a ViewerEffect block with an unknown type &quot; + block.Type, 
-                        Helpers.LogLevel.Warning);
-                    continue;
-                }
-
-                //LLColor color;
-                //if (block.Color.Length == 4)
-                //{
-                //    color = new LLColor(block.Color, 0);
-                //}
-                //else
-                //{
-                //    Client.Log(&quot;Received a ViewerEffect.EffectBlock.Color array with &quot; + block.Color.Length + &quot; bytes&quot;,
-                //        Helpers.LogLevel.Warning);
-                //    color = new LLColor();
-                //}
-
-                // Each ViewerEffect type uses it's own custom binary format for additional data. Fun eh?
-                switch (type)
-                {
-                    case EffectType.Text:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Icon:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Connector:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.FlexibleObject:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.AnimalControls:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.AnimationObject:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Cloth:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Beam:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Glow:
-                        Client.Log(&quot;Received a Glow ViewerEffect which is not implemented yet&quot;,
-                            Helpers.LogLevel.Warning);
-                        break;
-		            case EffectType.Point:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Trail:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Sphere:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Spiral:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.Edit:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-		            case EffectType.LookAt:
-                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
-                        break;
-                    case EffectType.PointAt:
-                        if (block.TypeData.Length == 57)
-                        {
-                            LLUUID sourceAvatar = new LLUUID(block.TypeData, 0);
-                            LLUUID targetObject = new LLUUID(block.TypeData, 16);
-                            LLVector3d targetPos = new LLVector3d(block.TypeData, 32);
-                            PointAtType pointAt;
-                            try
-                            {
-                                pointAt = (PointAtType)block.TypeData[56];
-                            }
-                            catch (Exception)
-                            {
-                                Client.Log(&quot;Unrecognized PointAtType &quot; + block.TypeData[56], Helpers.LogLevel.Warning);
-                                pointAt = PointAtType.Clear;
-                            }
-
-                            // TODO: Create OnAvatarPointAt event and call it here
-                        }
-                        else
-                        {
-                            Client.Log(&quot;Received a PointAt ViewerEffect with an incorrect TypeData size of &quot; +
-                                block.TypeData.Length + &quot; bytes&quot;, Helpers.LogLevel.Warning);
-                        }
-                        break;
-                }
-            }
-        }
-
-        /// &lt;summary&gt;
-        /// Handler for teleport Requests
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;packet&quot;&gt;Incoming TeleportHandler packet&lt;/param&gt;
-        /// &lt;param name=&quot;simulator&quot;&gt;Simulator sending teleport information&lt;/param&gt;
-        private void TeleportHandler(Packet packet, Simulator simulator)
-        {
-            if (packet.Type == PacketType.TeleportStart)
-            {
-                Client.DebugLog(&quot;TeleportStart received from &quot; + simulator.ToString());
-
-                teleportMessage = &quot;Teleport started&quot;;
-                TeleportStat = TeleportStatus.Start;
-
-                if (OnBeginTeleport != null)
-                {
-                    OnBeginTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
-                }
-            }
-            else if (packet.Type == PacketType.TeleportProgress)
-            {
-                Client.DebugLog(&quot;TeleportProgress received from &quot; + simulator.ToString());
-
-                teleportMessage = Helpers.FieldToString(((TeleportProgressPacket)packet).Info.Message);
-                TeleportStat = TeleportStatus.Progress;
-
-                if (OnBeginTeleport != null)
-                {
-                    OnBeginTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
-                }
-            }
-            else if (packet.Type == PacketType.TeleportFailed)
-            {
-                Client.DebugLog(&quot;TeleportFailed received from &quot; + simulator.ToString());
-
-                teleportMessage = Helpers.FieldToString(((TeleportFailedPacket)packet).Info.Reason);
-                TeleportStat = TeleportStatus.Failed;
-
-                if (OnBeginTeleport != null)
-                {
-                    OnBeginTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
-                }
-
-                OnBeginTeleport = null;
-            }
-            else if (packet.Type == PacketType.TeleportFinish)
-            {
-                Client.DebugLog(&quot;TeleportFinish received from &quot; + simulator.ToString());
-
-                TeleportFinishPacket finish = (TeleportFinishPacket)packet;
-                Simulator previousSim = Client.Network.CurrentSim;
-
-                // Connect to the new sim
-				String seedcaps = Encoding.UTF8.GetString(finish.Info.SeedCapability).Replace(&quot;\x00&quot;,&quot;&quot;);
-                Simulator sim = Client.Network.Connect(new IPAddress((long)finish.Info.SimIP), finish.Info.SimPort,
-                    simulator.CircuitCode, true, seedcaps);
-
-                if (sim != null)
-                {
-                    teleportMessage = &quot;Teleport finished&quot;;
-                    TeleportStat = TeleportStatus.Finished;
-
-                    // Move the avatar in to the new sim
-                    CompleteAgentMovementPacket move = new CompleteAgentMovementPacket();
-                    move.AgentData.AgentID = Client.Network.AgentID;
-                    move.AgentData.SessionID = Client.Network.SessionID;
-                    move.AgentData.CircuitCode = simulator.CircuitCode;
-                    Client.Network.SendPacket(move, sim);
-
-                    // Disconnect from the previous sim
-                    Client.Network.DisconnectSim(previousSim);
-
-                    Client.Log(&quot;Moved to new sim &quot; + sim.ToString(), Helpers.LogLevel.Info);
-
-                    if (OnBeginTeleport != null)
-                    {
-                        OnBeginTeleport(sim, teleportMessage, TeleportStat);
-                    }
-                    else
-                    {
-                        // Sleep a little while so we can collect parcel information
-                        // NOTE: This doesn't belong in libsecondlife
-                        // System.Threading.Thread.Sleep(1000);
-                    }
-                }
-                else
-                {
-                    teleportMessage = &quot;Failed to connect to the new sim after a teleport&quot;;
-                    TeleportStat = TeleportStatus.Failed;
-
-                    // FIXME: Set the previous CurrentSim to the current simulator again
-
-                    Client.Log(teleportMessage, Helpers.LogLevel.Warning);
-
-                    if (OnBeginTeleport != null)
-                    {
-                        OnBeginTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
-                    }
-                }
-
-                OnBeginTeleport = null;
-            }
-        }
-
-        /// &lt;summary&gt;
-        /// Teleport Timer Event Handler. Used for enforcing timeouts.
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;ea&quot;&gt;&lt;/param&gt;
-        private void TeleportTimerEvent(object source, System.Timers.ElapsedEventArgs ea)
-        {
-            TeleportTimeout = true;
-        }
-    }
-}
+/*
+ * Copyright (c) 2006, Second Life Reverse Engineering Team
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the Second Life Reverse Engineering Team nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Timers;
+using System.Net;
+using System.Collections;
+using System.Collections.Generic;
+using System.Text;
+using libsecondlife.Packets;
+
+namespace libsecondlife
+{
+    /// &lt;summary&gt;
+    /// Class to hold Client Avatar's data
+    /// &lt;/summary&gt;
+    public partial class MainAvatar
+    {
+        /// &lt;summary&gt;
+        /// Current teleport status
+        /// &lt;/summary&gt;
+        public enum TeleportStatus
+        {
+            /// &lt;summary&gt;&lt;/summary&gt;
+            None,
+            /// &lt;summary&gt;Teleport Start&lt;/summary&gt;
+            Start,
+            /// &lt;summary&gt;Teleport in Progress&lt;/summary&gt;
+            Progress,
+            /// &lt;summary&gt;Teleport Failed&lt;/summary&gt;
+            Failed,
+            /// &lt;summary&gt;Teleport Completed&lt;/summary&gt;
+            Finished
+        }
+
+        /// &lt;summary&gt;
+        /// Special commands used in Instant Messages
+        /// &lt;/summary&gt;
+        public enum InstantMessageDialog : byte
+        {
+            /// &lt;summary&gt;Indicates a regular IM from another agent&lt;/summary&gt;
+            MessageFromAgent = 0,
+			/// &lt;summary&gt;Simple notification box with an OK button.&lt;/summary&gt;
+			MessageBox = 1,
+			/// &lt;summary&gt;You've been invited to join a group.&lt;/summary&gt;
+			GroupInvitation = 3,
+            /// &lt;summary&gt;Indicates that someone has given the user an object&lt;/summary&gt;
+            /// &lt;remarks&gt;Soon to be deprecated&lt;/remarks&gt;
+            GiveInventory = 4,
+			/// &lt;summary&gt;Inventory offer&lt;/summary&gt;
+			InventoryOffered = 4,
+            /// &lt;summary&gt;An avatar has accepted your inventory offer&lt;/summary&gt;
+			InventoryAccepted = 5,
+            /// &lt;summary&gt;An avatar has declined your inventory offer&lt;/summary&gt;
+			InventoryDeclined = 6,
+			/// &lt;summary&gt;Group vote&lt;/summary&gt;
+			GroupVote = 7,
+            /// &lt;summary&gt;Indicates that someone has given us a notecard&lt;/summary&gt;
+            GiveNotecard = 9,
+			/// &lt;summary&gt;Unknown&lt;/summary&gt;
+			TaskInventoryOffered = 9,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+			TaskInventoryAccepted = 10,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+			TaskInventoryDeclined = 11,
+			/// &lt;summary&gt;Unknown&lt;/summary&gt;
+			NewUserDefault = 12,
+			/// &lt;summary&gt;Start a session, or add users to a session&lt;/summary&gt;
+			SessionAdd = 13,
+			/// &lt;summary&gt;Start a session, but don't prune offline users&lt;/summary&gt;
+			SessionOfflineAdd = 14,
+			/// &lt;summary&gt;Start a session with your group&lt;/summary&gt;
+			SessionGroupStart = 15,
+			/// &lt;summary&gt;Start a session without a calling card (finder or objects)&lt;/summary&gt;
+			SessionCardlessStart = 16,
+			/// &lt;summary&gt;Send a message to a session&lt;/summary&gt;
+			SessionSend = 17,
+			/// &lt;summary&gt;Leave a session&lt;/summary&gt;
+			SessionDrop = 18,
+            /// &lt;summary&gt;Indicates that the IM is from an object&lt;/summary&gt;
+            MessageFromObject = 19,
+			/// &lt;summary&gt;sent an IM to a busy user, this is the auto response&lt;/summary&gt;
+			BusyAutoResponse = 20,
+			/// &lt;summary&gt;Shows the message in the console and chat history&lt;/summary&gt;
+			ConsoleAndChatHistory = 21,
+			/// &lt;summary&gt;IM Types used for luring your friends&lt;/summary&gt;
+            RequestTeleport = 22,
+            /// &lt;summary&gt;Response sent to the agent which inititiated a teleport invitation&lt;/summary&gt;
+            AcceptTeleport = 23,
+            /// &lt;summary&gt;Response sent to the agent which inititiated a teleport invitation&lt;/summary&gt;
+            DenyTeleport = 24,
+            /// &lt;summary&gt;Only useful if you have Linden permissions&lt;/summary&gt;
+            GodLikeRequestTeleport = 25,
+			/// &lt;summary&gt;IM to tell the user to go to an URL&lt;/summary&gt;
+			GotoUrl = 28,
+			/// &lt;summary&gt;IM for help&lt;/summary&gt;
+			Session911Start = 29,
+			/// &lt;summary&gt;IM sent automatically on call for help, sends a lure 
+            /// to each Helper reached&lt;/summary&gt;
+			Lure911 = 30,
+			/// &lt;summary&gt;Like an IM but won't go to email&lt;/summary&gt;
+			FromTaskAsAlert = 31,
+			/// &lt;summary&gt;IM from a group officer to all group members&lt;/summary&gt;
+			GroupNotice = 32,
+			/// &lt;summary&gt;Unknown&lt;/summary&gt;
+			GroupNoticeInventoryAccepted = 33,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+			GroupNoticeInventoryDeclined = 34,
+			/// &lt;summary&gt;Accept a group invitation&lt;/summary&gt;
+			GroupInvitationAccept = 35,
+			/// &lt;summary&gt;Decline a group invitation&lt;/summary&gt;
+			GroupInvitationDecline = 36,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+			GroupNoticeRequested = 37,
+			/// &lt;summary&gt;An avatar is offering you friendship&lt;/summary&gt;
+			FriendshipOffered = 38,
+			/// &lt;summary&gt;An avatar has accepted your friendship offer&lt;/summary&gt;
+			FriendshipAccepted = 39,
+			/// &lt;summary&gt;An avatar has declined your friendship offer&lt;/summary&gt;
+			FriendshipDeclined = 40,
+            /// &lt;summary&gt;Indicates that a user has started typing&lt;/summary&gt;
+            StartTyping = 41,
+            /// &lt;summary&gt;Indicates that a user has stopped typing&lt;/summary&gt;
+            StopTyping = 42
+        }
+
+        /// &lt;summary&gt;
+        /// Conversion type to denote Chat Packet types in an easier-to-understand format
+        /// &lt;/summary&gt;
+        public enum ChatType : byte
+        {
+            /// &lt;summary&gt;Whispers (5m radius)&lt;/summary&gt;
+            Whisper = 0,
+            /// &lt;summary&gt;Normal chat (10/20m radius), what the official viewer typically sends&lt;/summary&gt;
+            Normal = 1,
+            /// &lt;summary&gt;Shouting! (100m radius)&lt;/summary&gt;
+            Shout = 2,
+            /// &lt;summary&gt;Say chat (10/20m radius) - The official viewer will 
+            /// print &quot;[4:15] You say, hey&quot; instead of &quot;[4:15] You: hey&quot;&lt;/summary&gt;
+            Say = 3,
+            /// &lt;summary&gt;Event message when an Avatar has begun to type&lt;/summary&gt;
+            StartTyping = 4,
+            /// &lt;summary&gt;Event message when an Avatar has stopped typing&lt;/summary&gt;
+            StopTyping = 5
+        }
+
+        /// &lt;summary&gt;
+        /// Effect type used in ViewerEffect packets
+        /// &lt;/summary&gt;
+        public enum EffectType : byte
+	    {
+            /// &lt;summary&gt;Place floating text above an object&lt;/summary&gt;
+		    Text = 0,
+            /// &lt;summary&gt;Unknown, probably places an icon above an object&lt;/summary&gt;
+		    Icon,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+		    Connector,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+		    FlexibleObject,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+		    AnimalControls,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+		    AnimationObject,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+		    Cloth,
+            /// &lt;summary&gt;Project a beam from a source to a destination, such as
+            /// the one used when editing an object&lt;/summary&gt;
+		    Beam,
+            /// &lt;summary&gt;Not implemented yet&lt;/summary&gt;
+		    Glow,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+		    Point,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+		    Trail,
+            /// &lt;summary&gt;Create a swirl of particles around an object&lt;/summary&gt;
+		    Sphere,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+		    Spiral,
+            /// &lt;summary&gt;Unknown&lt;/summary&gt;
+		    Edit,
+            /// &lt;summary&gt;Cause an avatar to look at an object&lt;/summary&gt;
+		    LookAt,
+            /// &lt;summary&gt;Cause an avatar to point at an object&lt;/summary&gt;
+		    PointAt
+	    }
+
+        /// &lt;summary&gt;
+        /// The action an avatar is doing when looking at something, used in 
+        /// ViewerEffect packets for the LookAt effect
+        /// &lt;/summary&gt;
+        public enum LookAtTarget : byte
+        {
+            /// &lt;summary&gt;&lt;/summary&gt;
+	        None,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Idle,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            AutoListen,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            FreeLook,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Respond,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Hover,
+            /// &lt;summary&gt;Deprecated&lt;/summary&gt;
+            Conversation,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Select,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Focus,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Mouselook,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Clear
+        }
+
+        /// &lt;summary&gt;
+        /// The action an avatar is doing when pointing at something, used in
+        /// ViewerEffect packets for the PointAt effect
+        /// &lt;/summary&gt;
+        public enum PointAtType : byte
+        {
+            /// &lt;summary&gt;&lt;/summary&gt;
+            None,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Select,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Grab,
+            /// &lt;summary&gt;&lt;/summary&gt;
+            Clear
+        }
+
+
+        /// &lt;summary&gt;
+        /// Triggered on incoming chat messages
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;Message&quot;&gt;Text of chat message&lt;/param&gt;
+        /// &lt;param name=&quot;Audible&quot;&gt;Is this normal audible chat or not.&lt;/param&gt;
+        /// &lt;param name=&quot;Type&quot;&gt;Type of chat (whisper,shout,status,etc)&lt;/param&gt;
+        /// &lt;param name=&quot;Sourcetype&quot;&gt;Type of source (Agent / Object / ???)&lt;/param&gt;
+        /// &lt;param name=&quot;FromName&quot;&gt;Text name of sending Avatar/Object&lt;/param&gt;
+        /// &lt;param name=&quot;ID&quot;&gt;&lt;/param&gt;
+        public delegate void ChatCallback(string message, byte audible, byte type, byte sourcetype,
+            string fromName, LLUUID id, LLUUID ownerid, LLVector3 position);
+
+        /// &lt;summary&gt;
+        /// Triggered when a script pops up a dialog box
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;message&quot;&gt;The dialog box message&lt;/param&gt;
+        /// &lt;param name=&quot;objectName&quot;&gt;Name of the object that sent the dialog&lt;/param&gt;
+        /// &lt;param name=&quot;imageID&quot;&gt;Image to be displayed in the dialog&lt;/param&gt;
+        /// &lt;param name=&quot;objectID&quot;&gt;ID of the object that sent the dialog&lt;/param&gt;
+        /// &lt;param name=&quot;firstName&quot;&gt;First name of the object owner&lt;/param&gt;
+        /// &lt;param name=&quot;lastName&quot;&gt;Last name of the object owner&lt;/param&gt;
+        /// &lt;param name=&quot;chatChannel&quot;&gt;Chat channel that the object is communicating on&lt;/param&gt;
+        /// &lt;param name=&quot;buttons&quot;&gt;List of button labels&lt;/param&gt;
+        public delegate void ScriptDialogCallback(string message, string objectName, LLUUID imageID,
+            LLUUID objectID, string firstName, string lastName, int chatChannel, List&lt;string&gt; buttons);
+
+        /// &lt;summary&gt;
+        /// Triggered when the L$ account balance for this avatar changes
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;balance&quot;&gt;The new account balance&lt;/param&gt;
+        public delegate void BalanceCallback(int balance);
+
+        /// &lt;summary&gt;
+        /// Tiggered on incoming instant messages
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;fromAgentID&quot;&gt;Key of sender&lt;/param&gt;
+        /// &lt;param name=&quot;fromAgentName&quot;&gt;Name of sender&lt;/param&gt;
+        /// &lt;param name=&quot;toAgentID&quot;&gt;Key of destination Avatar&lt;/param&gt;
+        /// &lt;param name=&quot;parentEstateID&quot;&gt;ID of originating Estate&lt;/param&gt;
+        /// &lt;param name=&quot;regionID&quot;&gt;Key of originating Region&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;Coordinates in originating Region&lt;/param&gt;
+        /// &lt;param name=&quot;dialog&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;groupIM&quot;&gt;Group IM session toggle&lt;/param&gt;
+        /// &lt;param name=&quot;imSessionID&quot;&gt;Key of IM Session&lt;/param&gt;
+        /// &lt;param name=&quot;timestamp&quot;&gt;Timestamp of message&lt;/param&gt;
+        /// &lt;param name=&quot;message&quot;&gt;Text of message&lt;/param&gt;
+        /// &lt;param name=&quot;offline&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;binaryBucket&quot;&gt;&lt;/param&gt;
+        public delegate void InstantMessageCallback(LLUUID fromAgentID, string fromAgentName,
+            LLUUID toAgentID, uint parentEstateID, LLUUID regionID, LLVector3 position,
+            byte dialog, bool groupIM, LLUUID imSessionID, DateTime timestamp, string message,
+            byte offline, byte[] binaryBucket);
+
+        /// &lt;summary&gt;
+        /// Triggered for any status updates of a teleport (progress, failed, succeeded)
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;currentSim&quot;&gt;The simulator the avatar is currently residing in&lt;/param&gt;
+        /// &lt;param name=&quot;message&quot;&gt;A message about the current teleport status&lt;/param&gt;
+        /// &lt;param name=&quot;status&quot;&gt;The current status of the teleport&lt;/param&gt;
+        public delegate void TeleportCallback(Simulator currentSim, string message, TeleportStatus status);
+
+        /// &lt;summary&gt;
+        /// Reply to a request to join a group, informs whether it was successful or not
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;groupID&quot;&gt;The group we attempted to join&lt;/param&gt;
+        /// &lt;param name=&quot;success&quot;&gt;Whether we joined the group or not&lt;/param&gt;
+        public delegate void JoinGroupCallback(LLUUID groupID, bool success);
+
+        /// &lt;summary&gt;
+        /// Reply to a request to leave a group, informs whether it was successful or not
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;groupID&quot;&gt;The group we attempted to leave&lt;/param&gt;
+        /// &lt;param name=&quot;success&quot;&gt;Whether we left the group or not&lt;/param&gt;
+        public delegate void LeaveGroupCallback(LLUUID groupID, bool success);
+
+        /// &lt;summary&gt;
+        /// Informs the avatar that it is no longer a member of a group
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;groupID&quot;&gt;The group we are no longer a member of&lt;/param&gt;
+        public delegate void GroupDroppedCallback(LLUUID groupID);
+
+
+        /// &lt;summary&gt;Callback for incoming chat packets&lt;/summary&gt;
+        public event ChatCallback OnChat;
+        /// &lt;summary&gt;Callback for pop-up dialogs from scripts&lt;/summary&gt;
+        public event ScriptDialogCallback OnScriptDialog;
+        /// &lt;summary&gt;Callback for incoming IMs&lt;/summary&gt;
+        public event InstantMessageCallback OnInstantMessage;
+        /// &lt;summary&gt;Callback for Teleport request update&lt;/summary&gt;
+        public event TeleportCallback OnTeleport;
+        /// &lt;summary&gt;Callback for incoming change in L$ balance&lt;/summary&gt;
+        public event BalanceCallback OnBalanceUpdated;
+        /// &lt;summary&gt;Callback reply for an attempt to join a group&lt;/summary&gt;
+        public event JoinGroupCallback OnJoinGroup;
+        /// &lt;summary&gt;Callback reply for an attempt to leave a group&lt;/summary&gt;
+        public event LeaveGroupCallback OnLeaveGroup;
+        /// &lt;summary&gt;Callback for informing the avatar that it is no longer a member of a group&lt;/summary&gt;
+        public event GroupDroppedCallback OnGroupDropped;
+
+        /// &lt;summary&gt;Your (client) Avatar UUID, asset server&lt;/summary&gt;
+        public LLUUID ID = LLUUID.Zero;
+        /// &lt;summary&gt;Your (client) Avatar ID, local to Region/sim&lt;/summary&gt;
+        public uint LocalID;
+        /// &lt;summary&gt;Avatar First Name (i.e. Philip)&lt;/summary&gt;
+        public string FirstName = String.Empty;
+        /// &lt;summary&gt;Avatar Last Name (i.e. Linden)&lt;/summary&gt;
+        public string LastName = String.Empty;
+        /// &lt;summary&gt;Positive and negative ratings&lt;/summary&gt;
+        /// &lt;remarks&gt;This information is read-only and any changes will not be
+        /// reflected on the server&lt;/remarks&gt;
+        public Avatar.Statistics ProfileStatistics = new Avatar.Statistics();
+        /// &lt;summary&gt;Avatar properties including about text, profile URL, image IDs and 
+        /// publishing settings&lt;/summary&gt;
+        /// &lt;remarks&gt;If you change fields in this struct, the changes will not
+        /// be reflected on the server until you call SetAvatarInformation&lt;/remarks&gt;
+        public Avatar.Properties ProfileProperties = new Avatar.Properties();
+        /// &lt;summary&gt;Avatar interests including spoken languages, skills, and &quot;want to&quot;
+        /// choices&lt;/summary&gt;
+        /// &lt;remarks&gt;If you change fields in this struct, the changes will not
+        /// be reflected on the server until you call SetAvatarInformation&lt;/remarks&gt;
+        public Avatar.Interests ProfileInterests = new Avatar.Interests();
+        /// &lt;summary&gt;Current position of avatar&lt;/summary&gt;
+        public LLVector3 Position = LLVector3.Zero;
+        /// &lt;summary&gt;Current rotation of avatar&lt;/summary&gt;
+        public LLQuaternion Rotation = LLQuaternion.Identity;
+        /// &lt;summary&gt;The point the avatar is currently looking at
+        /// (may not stay updated)&lt;/summary&gt;
+        public LLVector3 LookAt = LLVector3.Zero;
+        /// &lt;summary&gt;Position avatar client will goto when login to 'home' or during
+        /// teleport request to 'home' region.&lt;/summary&gt;
+        public LLVector3 HomePosition = LLVector3.Zero;
+        /// &lt;summary&gt;LookAt point saved/restored with HomePosition&lt;/summary&gt;
+        public LLVector3 HomeLookAt = LLVector3.Zero;
+        /// &lt;summary&gt;Used for camera and control key state tracking&lt;/summary&gt;
+        public MainAvatarStatus Status;
+        /// &lt;summary&gt;The UUID of your root inventory folder&lt;/summary&gt;
+        public LLUUID InventoryRootFolderUUID;
+
+        
+        /// &lt;summary&gt;Gets the health of the agent&lt;/summary&gt;
+        public float Health
+        {
+            get { return health; }
+        }
+        
+        /// &lt;summary&gt;Gets the current balance of the agent&lt;/summary&gt;
+        public int Balance
+        {
+            get { return balance; }
+        }
+
+        /// &lt;summary&gt;Gets the local ID of the prim the avatar is sitting on,
+        /// zero if the avatar is not currently sitting&lt;/summary&gt;
+        public uint SittingOn
+        {
+            get { return sittingOn; }
+        }
+		
+		/// &lt;summary&gt;Gets the UUID of the active group.&lt;/summary&gt;
+		public LLUUID ActiveGroup
+		{
+			get { return activeGroup; }
+		}
+
+        internal uint sittingOn = 0;
+        internal string teleportMessage = String.Empty;
+
+        private SecondLife Client;
+        private TeleportCallback OnBeginTeleport;
+        private TeleportStatus TeleportStat;
+        private Timer TeleportTimer;
+        private bool TeleportTimeout;
+        private uint HeightWidthGenCounter;
+        private float health = 0.0f;
+        private int balance = 0;
+		private LLUUID activeGroup;
+
+        /// &lt;summary&gt;
+        /// Constructor, setup callbacks for packets related to our avatar
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
+        public MainAvatar(SecondLife client)
+        {
+            NetworkManager.PacketCallback callback;
+            Client = client;
+
+            Status = new MainAvatarStatus(Client);
+
+            // Coarse location callback
+            Client.Network.RegisterCallback(PacketType.CoarseLocationUpdate, new NetworkManager.PacketCallback(CoarseLocationHandler));
+
+            // Teleport callbacks
+            callback = new NetworkManager.PacketCallback(TeleportHandler);
+            Client.Network.RegisterCallback(PacketType.TeleportStart, callback);
+            Client.Network.RegisterCallback(PacketType.TeleportProgress, callback);
+            Client.Network.RegisterCallback(PacketType.TeleportFailed, callback);
+            Client.Network.RegisterCallback(PacketType.TeleportFinish, callback);
+
+            // Instant Message callback
+            Client.Network.RegisterCallback(PacketType.ImprovedInstantMessage, new NetworkManager.PacketCallback(InstantMessageHandler));
+
+            // Chat callback
+            Client.Network.RegisterCallback(PacketType.ChatFromSimulator, new NetworkManager.PacketCallback(ChatHandler));
+
+            // Script dialog callback
+            Client.Network.RegisterCallback(PacketType.ScriptDialog, new NetworkManager.PacketCallback(ScriptDialogHandler));
+
+            // Teleport timeout timer
+            TeleportTimer = new Timer(Client.Settings.TELEPORT_TIMEOUT);
+            TeleportTimer.Elapsed += new ElapsedEventHandler(TeleportTimerEvent);
+            TeleportTimeout = false;
+
+            // Movement complete callback
+            Client.Network.RegisterCallback(PacketType.AgentMovementComplete, new NetworkManager.PacketCallback(MovementCompleteHandler));
+
+            // Health callback
+            Client.Network.RegisterCallback(PacketType.HealthMessage, new NetworkManager.PacketCallback(HealthHandler));
+
+            // Money callbacks
+            callback = new NetworkManager.PacketCallback(BalanceHandler);
+            Client.Network.RegisterCallback(PacketType.MoneyBalanceReply, callback);
+            Client.Network.RegisterCallback(PacketType.MoneySummaryReply, callback);
+            Client.Network.RegisterCallback(PacketType.AdjustBalance, callback);
+
+            // Group callbacks
+            Client.Network.RegisterCallback(PacketType.JoinGroupReply, new NetworkManager.PacketCallback(JoinGroupHandler));
+            Client.Network.RegisterCallback(PacketType.LeaveGroupReply, new NetworkManager.PacketCallback(LeaveGroupHandler));
+            Client.Network.RegisterCallback(PacketType.AgentDropGroup, new NetworkManager.PacketCallback(DropGroupHandler));
+
+            // Viewer effect callback
+            Client.Network.RegisterCallback(PacketType.ViewerEffect, new NetworkManager.PacketCallback(ViewerEffectHandler));
+			
+			//Agent Update Callback
+			Client.Network.RegisterCallback(PacketType.AgentDataUpdate, new NetworkManager.PacketCallback(AgentDataUpdateHandler));
+
+	        // Event queue callback (used for Caps teleports currently)
+	        Client.Network.RegisterEventCallback(new Caps.EventQueueCallback(EventQueueHandler));
+        }
+
+        /// &lt;summary&gt;
+        /// Send an Instant Message
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
+        /// &lt;param name=&quot;message&quot;&gt;Text Message being sent.&lt;/param&gt;
+        public void InstantMessage(LLUUID target, string message)
+        {
+            InstantMessage(FirstName + &quot; &quot; + LastName, LLUUID.Random(), target, message, null, LLUUID.Random());
+        }
+
+		/// &lt;summary&gt;
+		/// Send an Instant Message, used for dialog responses.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
+		/// &lt;param name=&quot;dialog&quot;&gt;Dialog code to be sent.&lt;/param&gt;
+		public void InstantMessage(LLUUID target, InstantMessageDialog dialog)
+		{
+			InstantMessage(FirstName + &quot; &quot; + LastName, LLUUID.Random(), target, String.Empty, null, LLUUID.Random(), dialog);
+		}
+
+        /// &lt;summary&gt;
+        /// Send an Instant Message
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
+        /// &lt;param name=&quot;message&quot;&gt;Text Message being sent.&lt;/param&gt;
+        /// &lt;param name=&quot;IMSessionID&quot;&gt;IM Session ID&lt;/param&gt;
+        public void InstantMessage(LLUUID target, string message, LLUUID IMSessionID)
+        {
+            InstantMessage(FirstName + &quot; &quot; + LastName, LLUUID.Random(), target, message, null, IMSessionID);
+        }
+
+        /// &lt;summary&gt;
+        /// Send an Instant Message
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;fromName&quot;&gt;Client's Avatar&lt;/param&gt;
+        /// &lt;param name=&quot;sessionID&quot;&gt;SessionID of current connection to grid&lt;/param&gt;
+        /// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
+        /// &lt;param name=&quot;message&quot;&gt;Text Message being sent.&lt;/param&gt;
+        /// &lt;param name=&quot;conferenceIDs&quot;&gt;&lt;/param&gt;
+        public void InstantMessage(string fromName, LLUUID sessionID, LLUUID target, string message, LLUUID[] conferenceIDs)
+        {
+            InstantMessage(fromName, sessionID, target, message, conferenceIDs, LLUUID.Random());
+        }
+
+        /// &lt;summary&gt;
+        /// Send an Instant Message
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;fromName&quot;&gt;The name this IM will show up as being from&lt;/param&gt;
+        /// &lt;param name=&quot;sessionID&quot;&gt;Session ID of current connection to grid&lt;/param&gt;
+        /// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
+        /// &lt;param name=&quot;message&quot;&gt;Text message being sent&lt;/param&gt;
+        /// &lt;param name=&quot;conferenceIDs&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;IMSessionID&quot;&gt;IM session ID (to differentiate between IM windows)&lt;/param&gt;
+		public void InstantMessage(string fromName, LLUUID sessionID, LLUUID target, string message,
+			LLUUID[] conferenceIDs, LLUUID IMSessionID)
+		{
+			InstantMessage(fromName, sessionID, target, message, conferenceIDs, IMSessionID, InstantMessageDialog.MessageFromAgent);
+		}
+
+        /// &lt;summary&gt;
+        /// Send an Instant Message
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;fromName&quot;&gt;The name this IM will show up as being from&lt;/param&gt;
+        /// &lt;param name=&quot;sessionID&quot;&gt;Session ID of current connection to grid&lt;/param&gt;
+        /// &lt;param name=&quot;target&quot;&gt;Key of Avatar&lt;/param&gt;
+        /// &lt;param name=&quot;message&quot;&gt;Text message being sent&lt;/param&gt;
+        /// &lt;param name=&quot;conferenceIDs&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;IMSessionID&quot;&gt;IM session ID (to differentiate between IM windows)&lt;/param&gt;
+        public void InstantMessage(string fromName, LLUUID sessionID, LLUUID target, string message,
+            LLUUID[] conferenceIDs, LLUUID IMSessionID, InstantMessageDialog dialog)
+        {
+            ImprovedInstantMessagePacket im = new ImprovedInstantMessagePacket();
+            im.AgentData.AgentID = this.ID;
+            im.AgentData.SessionID = Client.Network.SessionID;
+            im.MessageBlock.Dialog = (byte)dialog;
+            im.MessageBlock.FromAgentName = Helpers.StringToField(fromName);
+            im.MessageBlock.FromGroup = false;
+            im.MessageBlock.ID = IMSessionID;
+            im.MessageBlock.Message = Helpers.StringToField(message);
+            im.MessageBlock.Offline = 1;
+            im.MessageBlock.ToAgentID = target;
+            if (conferenceIDs != null &amp;&amp; conferenceIDs.Length &gt; 0)
+            {
+                im.MessageBlock.BinaryBucket = new byte[16 * conferenceIDs.Length];
+
+                for (int i = 0; i &lt; conferenceIDs.Length; ++i)
+                {
+                    Array.Copy(conferenceIDs[i].Data, 0, im.MessageBlock.BinaryBucket, i * 16, 16);
+                }
+            }
+            else
+            {
+                im.MessageBlock.BinaryBucket = new byte[0];
+            }
+
+            // These fields are mandatory, even if we don't have valid values for them
+            im.MessageBlock.Position = LLVector3.Zero;
+            //TODO: Allow region id to be correctly set by caller or fetched from Client.*
+            im.MessageBlock.RegionID = LLUUID.Zero;
+
+            // Send the message
+            Client.Network.SendPacket(im);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;sourceAvatar&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;targetObject&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;globalOffset&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
+        public void PointAtEffect(LLUUID sourceAvatar, LLUUID targetObject, LLVector3d globalOffset, PointAtType type)
+        {
+            ViewerEffectPacket effect = new ViewerEffectPacket();
+            effect.Effect = new ViewerEffectPacket.EffectBlock[1];
+            effect.Effect[0] = new ViewerEffectPacket.EffectBlock();
+            effect.Effect[0].Color = LLColor.Black.GetBytes();
+            effect.Effect[0].Duration = (type == PointAtType.Clear) ? 0.0f : Single.MaxValue / 4.0f;
+            effect.Effect[0].ID = LLUUID.Random();
+            effect.Effect[0].Type = (byte)EffectType.PointAt;
+
+            byte[] typeData = new byte[57];
+            if (sourceAvatar != null)
+                Array.Copy(sourceAvatar.GetBytes(), typeData, 16);
+            if (targetObject != null)
+                Array.Copy(targetObject.GetBytes(), 0, typeData, 16, 16);
+            Array.Copy(globalOffset.GetBytes(), 0, typeData, 32, 24);
+            typeData[56] = (byte)type;
+
+            effect.Effect[0].TypeData = typeData;
+
+            Client.Network.SendPacket(effect);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;sourceAvatar&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;targetObject&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;globalOffset&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;color&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;duration&quot;&gt;&lt;/param&gt;
+        public void BeamEffect(LLUUID sourceAvatar, LLUUID targetObject, LLVector3d globalOffset, LLColor color, 
+            float duration)
+        {
+            ViewerEffectPacket effect = new ViewerEffectPacket();
+            effect.Effect = new ViewerEffectPacket.EffectBlock[1];
+            effect.Effect[0] = new ViewerEffectPacket.EffectBlock();
+            effect.Effect[0].Color = color.GetBytes();
+            effect.Effect[0].Duration = duration;
+            effect.Effect[0].ID = LLUUID.Random();
+            effect.Effect[0].Type = (byte)EffectType.Beam;
+
+            byte[] typeData = new byte[56];
+            if (sourceAvatar != null)
+                Array.Copy(sourceAvatar.GetBytes(), 0, typeData, 0, 16);
+            if (targetObject != null)
+                Array.Copy(targetObject.GetBytes(), 0, typeData, 16, 16);
+            Array.Copy(globalOffset.GetBytes(), 0, typeData, 32, 24);
+
+            effect.Effect[0].TypeData = typeData;
+
+            Client.Network.SendPacket(effect);
+        }
+
+        /// &lt;summary&gt;
+        /// 
+        /// &lt;/summary&gt;
+        public void LookAtEffect()
+        {
+        }
+
+        /// &lt;summary&gt;
+        /// Synchronize the local profile and interests information to the server
+        /// &lt;/summary&gt;
+        public void SetAvatarInformation()
+        {
+            // Basic profile properties
+            AvatarPropertiesUpdatePacket apup = new AvatarPropertiesUpdatePacket();
+
+            apup.AgentData.AgentID = this.ID;
+            apup.AgentData.SessionID = Client.Network.SessionID;
+            apup.PropertiesData.AboutText = Helpers.StringToField(this.ProfileProperties.AboutText);
+            apup.PropertiesData.AllowPublish = this.ProfileProperties.AllowPublish;
+            apup.PropertiesData.FLAboutText = Helpers.StringToField(this.ProfileProperties.FirstLifeText);
+            apup.PropertiesData.FLImageID = this.ProfileProperties.FirstLifeImage;
+            apup.PropertiesData.ImageID = this.ProfileProperties.ProfileImage;
+            apup.PropertiesData.MaturePublish = this.ProfileProperties.MaturePublish;
+            apup.PropertiesData.ProfileURL = Helpers.StringToField(this.ProfileProperties.ProfileURL);
+
+            // Interests
+            AvatarInterestsUpdatePacket aiup = new AvatarInterestsUpdatePacket();
+
+            aiup.AgentData.AgentID = this.ID;
+            aiup.AgentData.SessionID = Client.Network.SessionID;
+            aiup.PropertiesData.LanguagesText = Helpers.StringToField(this.ProfileInterests.LanguagesText);
+            aiup.PropertiesData.SkillsMask = this.ProfileInterests.SkillsMask;
+            aiup.PropertiesData.SkillsText = Helpers.StringToField(this.ProfileInterests.SkillsText);
+            aiup.PropertiesData.WantToMask = this.ProfileInterests.WantToMask;
+            aiup.PropertiesData.WantToText = Helpers.StringToField(this.ProfileInterests.WantToText);
+
+            //Send packets
+            Client.Network.SendPacket(apup);
+            Client.Network.SendPacket(aiup);
+        }
+
+        /// &lt;summary&gt;
+        /// Send a chat message
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;message&quot;&gt;The Message you're sending out.&lt;/param&gt;
+        /// &lt;param name=&quot;channel&quot;&gt;Channel number (0 would be default 'Say' message, other numbers 
+        /// denote the equivalent of /# in normal client).&lt;/param&gt;
+        /// &lt;param name=&quot;type&quot;&gt;Chat Type, see above.&lt;/param&gt;
+        public void Chat(string message, int channel, ChatType type)
+        {
+            ChatFromViewerPacket chat = new ChatFromViewerPacket();
+            chat.AgentData.AgentID = this.ID;
+            chat.AgentData.SessionID = Client.Network.SessionID;
+            chat.ChatData.Channel = channel;
+            chat.ChatData.Message = Helpers.StringToField(message);
+            chat.ChatData.Type = (byte)type;
+
+            Client.Network.SendPacket(chat);
+        }
+
+        /// &lt;summary&gt;
+        /// Set the height and the width of the client window. This is used
+        /// by the server to build a virtual camera frustum for our avatar
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;height&quot;&gt;New height of the viewer window&lt;/param&gt;
+        /// &lt;param name=&quot;width&quot;&gt;New width of the viewer window&lt;/param&gt;
+        public void SetHeightWidth(ushort height, ushort width)
+        {
+            AgentHeightWidthPacket heightwidth = new AgentHeightWidthPacket();
+            heightwidth.AgentData.AgentID = Client.Network.AgentID;
+            heightwidth.AgentData.SessionID = Client.Network.SessionID;
+            heightwidth.AgentData.CircuitCode = Client.Network.CurrentSim.CircuitCode;
+            heightwidth.HeightWidthBlock.Height = height;
+            heightwidth.HeightWidthBlock.Width = width;
+            heightwidth.HeightWidthBlock.GenCounter = HeightWidthGenCounter++;
+
+            Client.Network.SendPacket(heightwidth);
+        }
+
+        /// &lt;summary&gt;
+        /// Sends a request to sit on the specified object
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;targetID&quot;&gt;LLUUID of the object to sit on&lt;/param&gt;
+        /// &lt;param name=&quot;offset&quot;&gt;Sit at offset&lt;/param&gt;
+        public void RequestSit(LLUUID targetID, LLVector3 offset)
+        {
+            AgentRequestSitPacket requestSit = new AgentRequestSitPacket();
+            requestSit.AgentData.AgentID = Client.Network.AgentID;
+            requestSit.AgentData.SessionID = Client.Network.SessionID;
+            requestSit.TargetObject.TargetID = targetID;
+            requestSit.TargetObject.Offset = offset;
+            Client.Network.SendPacket(requestSit);
+        }
+
+        /// &lt;summary&gt;
+        /// Request the list of muted things for this avatar
+        /// &lt;/summary&gt;
+        public void RequestMuteList()
+        {
+            MuteListRequestPacket mute = new MuteListRequestPacket();
+            mute.AgentData.AgentID = Client.Network.AgentID;
+            mute.AgentData.SessionID = Client.Network.SessionID;
+            mute.MuteData.MuteCRC = 0;
+
+            Client.Network.SendPacket(mute);
+        }
+
+        /// &lt;summary&gt;
+        /// Request the current L$ balance
+        /// &lt;/summary&gt;
+        public void RequestBalance()
+        {
+            MoneyBalanceRequestPacket money = new MoneyBalanceRequestPacket();
+            money.AgentData.AgentID = Client.Network.AgentID;
+            money.AgentData.SessionID = Client.Network.SessionID;
+            money.MoneyData.TransactionID = LLUUID.Zero;
+
+            Client.Network.SendPacket(money);
+        }
+
+        /// &lt;summary&gt;
+        /// Set the always running toggle on the server
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;alwaysRun&quot;&gt;Whether the avatar should always run or not&lt;/param&gt;
+        public void SetAlwaysRun(bool alwaysRun)
+        {
+            SetAlwaysRunPacket run = new SetAlwaysRunPacket();
+            run.AgentData.AgentID = Client.Network.AgentID;
+            run.AgentData.SessionID = Client.Network.SessionID;
+            run.AgentData.AlwaysRun = alwaysRun;
+
+            Client.Network.SendPacket(run);
+        }
+
+        /// &lt;summary&gt;
+        /// Follows a call to RequestSit() to actually sit on the object
+        /// &lt;/summary&gt;
+        public void Sit()
+        {
+            AgentSitPacket sit = new AgentSitPacket();
+            sit.AgentData.AgentID = Client.Network.AgentID;
+            sit.AgentData.SessionID = Client.Network.SessionID;
+            Client.Network.SendPacket(sit);
+        }
+
+        /// &lt;summary&gt;
+        /// Give Money to destination Avatar
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;target&quot;&gt;UUID of the Target Avatar&lt;/param&gt;
+        /// &lt;param name=&quot;amount&quot;&gt;Amount in L$&lt;/param&gt;
+        /// &lt;param name=&quot;description&quot;&gt;Reason (optional normally)&lt;/param&gt;
+        public void GiveMoney(LLUUID target, int amount, string description)
+        {
+            // 5001 - transaction type for av to av money transfers
+            if (amount &gt; 0)
+                GiveMoney(target, amount, description, 5001);
+            else
+                Client.Log(&quot;Attempted to pay zero or negative value &quot; + amount, Helpers.LogLevel.Warning);
+        }
+
+        /// &lt;summary&gt;
+        /// Give Money to destionation Object or Avatar
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;target&quot;&gt;UUID of the Target Object/Avatar&lt;/param&gt;
+        /// &lt;param name=&quot;amount&quot;&gt;Amount in L$&lt;/param&gt;
+        /// &lt;param name=&quot;description&quot;&gt;Reason (Optional normally)&lt;/param&gt;
+        /// &lt;param name=&quot;transactiontype&quot;&gt;The type of transaction.  Currently only 5001 is
+        /// documented for Av-&gt;Av money transfers.&lt;/param&gt;
+        public void GiveMoney(LLUUID target, int amount, string description, int transactiontype)
+        {
+            MoneyTransferRequestPacket money = new MoneyTransferRequestPacket();
+            money.AgentData.AgentID = this.ID;
+            money.AgentData.SessionID = Client.Network.SessionID;
+            money.MoneyData.Description = Helpers.StringToField(description);
+            money.MoneyData.DestID = target;
+            money.MoneyData.SourceID = this.ID;
+            money.MoneyData.TransactionType = transactiontype;
+            money.MoneyData.AggregatePermInventory = 0; //TODO: whats this?
+            money.MoneyData.AggregatePermNextOwner = 0; //TODO: whats this?
+            money.MoneyData.Flags = 0; //TODO: whats this?
+            money.MoneyData.Amount = amount;
+
+            Client.Network.SendPacket(money);
+        }
+
+        /// &lt;summary&gt;
+        /// Send an AgentAnimation packet that toggles a single animation on
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;animation&quot;&gt;The animation to start playing&lt;/param&gt;
+        public void AnimationStart(LLUUID animation)
+        {
+            Dictionary&lt;LLUUID, bool&gt; animations = new Dictionary&lt;LLUUID, bool&gt;();
+            animations[animation] = true;
+
+            Animate(animations);
+        }
+
+        /// &lt;summary&gt;
+        /// Send an AgentAnimation packet that toggles a single animation off
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;animation&quot;&gt;The animation to stop playing&lt;/param&gt;
+        public void AnimationStop(LLUUID animation)
+        {
+            Dictionary&lt;LLUUID, bool&gt; animations = new Dictionary&lt;LLUUID, bool&gt;();
+            animations[animation] = false;
+
+            Animate(animations);
+        }
+
+        /// &lt;summary&gt;
+        /// Send an AgentAnimation packet that will toggle animations on or off
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;animations&quot;&gt;A list of animation UUIDs, and whether to
+        /// turn that animation on or off&lt;/param&gt;
+        public void Animate(Dictionary&lt;LLUUID, bool&gt; animations)
+        {
+            AgentAnimationPacket animate = new AgentAnimationPacket();
+
+            animate.AgentData.AgentID = Client.Network.AgentID;
+            animate.AgentData.SessionID = Client.Network.SessionID;
+            animate.AnimationList = new AgentAnimationPacket.AnimationListBlock[animations.Count];
+            int i = 0;
+
+            foreach (KeyValuePair&lt;LLUUID, bool&gt; animation in animations)
+            {
+                animate.AnimationList[i] = new AgentAnimationPacket.AnimationListBlock();
+                animate.AnimationList[i].AnimID = animation.Key;
+                animate.AnimationList[i].StartAnim = animation.Value;
+
+                i++;
+            }
+
+            Client.Network.SendPacket(animate);
+        }
+
+        /// &lt;summary&gt;
+        /// Use the autopilot sim function to move the avatar to a new position
+        /// &lt;/summary&gt;
+        /// &lt;remarks&gt;The z value is currently not handled properly by the simulator&lt;/remarks&gt;
+        /// &lt;param name=&quot;globalX&quot;&gt;Integer value for the global X coordinate to move to&lt;/param&gt;
+        /// &lt;param name=&quot;globalY&quot;&gt;Integer value for the global Y coordinate to move to&lt;/param&gt;
+        /// &lt;param name=&quot;z&quot;&gt;Floating-point value for the Z coordinate to move to&lt;/param&gt;
+        /// &lt;example&gt;AutoPilot(252620, 247078, 20.2674);&lt;/example&gt;
+        public void AutoPilot(ulong globalX, ulong globalY, float z)
+        {
+            GenericMessagePacket autopilot = new GenericMessagePacket();
+
+            autopilot.AgentData.AgentID = Client.Network.AgentID;
+            autopilot.AgentData.SessionID = Client.Network.SessionID;
+            autopilot.MethodData.Invoice = LLUUID.Zero;
+            autopilot.MethodData.Method = Helpers.StringToField(&quot;autopilot&quot;);
+            autopilot.ParamList = new GenericMessagePacket.ParamListBlock[3];
+            autopilot.ParamList[0] = new GenericMessagePacket.ParamListBlock();
+            autopilot.ParamList[0].Parameter = Helpers.StringToField(globalX.ToString());
+            autopilot.ParamList[1] = new GenericMessagePacket.ParamListBlock();
+            autopilot.ParamList[1].Parameter = Helpers.StringToField(globalY.ToString());
+            autopilot.ParamList[2] = new GenericMessagePacket.ParamListBlock();
+            // TODO: Do we need to prevent z coordinates from being sent in 1.4827e-18 notation?
+            autopilot.ParamList[2].Parameter = Helpers.StringToField(z.ToString());
+
+            Client.Network.SendPacket(autopilot);
+        }
+
+        /// &lt;summary&gt;
+        /// Use the autopilot sim function to move the avatar to a new position
+        /// &lt;/summary&gt;
+        /// &lt;remarks&gt;The z value is currently not handled properly by the simulator&lt;/remarks&gt;
+        /// &lt;param name=&quot;localX&quot;&gt;Integer value for the local X coordinate to move to&lt;/param&gt;
+        /// &lt;param name=&quot;localY&quot;&gt;Integer value for the local Y coordinate to move to&lt;/param&gt;
+        /// &lt;param name=&quot;z&quot;&gt;Floating-point value for the Z coordinate to move to&lt;/param&gt;
+        /// &lt;example&gt;AutoPilot(252620, 247078, 20.2674);&lt;/example&gt;
+        public void AutoPilotLocal(int localX, int localY, float z)
+        {
+            uint x, y;
+            Helpers.LongToUInts(Client.Network.CurrentSim.Region.Handle, out x, out y);
+            AutoPilot((ulong)(x + localX), (ulong)(y + localY), z);
+        }
+
+        /// &lt;summary&gt;
+        /// Start a teleport process
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
+        /// &lt;param name=&quot;tc&quot;&gt;Callback ID&lt;/param&gt;
+        public void BeginTeleport(ulong regionHandle, LLVector3 position, TeleportCallback tc)
+        {
+            BeginTeleport(regionHandle, position, new LLVector3(position.X + 1.0f, position.Y, position.Z), tc);
+        }
+
+        /// &lt;summary&gt;
+        /// Start a teleport process
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
+        /// &lt;param name=&quot;lookAt&quot;&gt;Target to look at&lt;/param&gt;
+        /// &lt;param name=&quot;tc&quot;&gt;Callback ID&lt;/param&gt;
+        public void BeginTeleport(ulong regionHandle, LLVector3 position, LLVector3 lookAt, TeleportCallback tc)
+        {
+            OnBeginTeleport = tc;
+
+            TeleportLocationRequestPacket teleport = new TeleportLocationRequestPacket();
+            teleport.AgentData.AgentID = Client.Network.AgentID;
+            teleport.AgentData.SessionID = Client.Network.SessionID;
+            teleport.Info.LookAt = lookAt;
+            teleport.Info.Position = position;
+            teleport.Info.RegionHandle = regionHandle;
+
+            Client.Log(&quot;Teleporting to region &quot; + regionHandle.ToString(), Helpers.LogLevel.Info);
+
+            Client.Network.SendPacket(teleport);
+        }
+
+        /// &lt;summary&gt;
+        /// Start a teleport process
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public bool Teleport(ulong regionHandle, LLVector3 position)
+        {
+            return Teleport(regionHandle, position, new LLVector3(position.X + 1.0f, position.Y, position.Z));
+        }
+
+        /// &lt;summary&gt;
+        /// Start a teleport process
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;regionHandle&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
+        /// &lt;param name=&quot;lookAt&quot;&gt;Target to look at&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public bool Teleport(ulong regionHandle, LLVector3 position, LLVector3 lookAt)
+        {
+            TeleportStat = TeleportStatus.None;
+
+            TeleportLocationRequestPacket teleport = new TeleportLocationRequestPacket();
+            teleport.AgentData.AgentID = Client.Network.AgentID;
+            teleport.AgentData.SessionID = Client.Network.SessionID;
+            teleport.Info.LookAt = lookAt;
+            teleport.Info.Position = position;
+
+            teleport.Info.RegionHandle = regionHandle;
+
+            Client.Log(&quot;Teleporting to region &quot; + regionHandle.ToString(), Helpers.LogLevel.Info);
+
+            // Start the timeout check
+            TeleportTimeout = false;
+            TeleportTimer.Start();
+
+            Client.Network.SendPacket(teleport);
+
+            // FIXME: Use a ManualResetEvent, Client.Tick() is bad
+            while (TeleportStat != TeleportStatus.Failed &amp;&amp; TeleportStat != TeleportStatus.Finished &amp;&amp; !TeleportTimeout)
+            {
+                Client.Tick();
+            }
+
+            TeleportTimer.Stop();
+
+            if (TeleportTimeout)
+            {
+                teleportMessage = &quot;Teleport timed out.&quot;;
+                TeleportStat = TeleportStatus.Failed;
+
+                if (OnTeleport != null) { OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat); }
+            }
+            else
+            {
+                if (OnTeleport != null) { OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat); }
+            }
+
+            return (TeleportStat == TeleportStatus.Finished);
+        }
+
+        /// &lt;summary&gt;
+        /// Generic Teleport Function
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simName&quot;&gt;Region name&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public bool Teleport(string simName, LLVector3 position)
+        {
+            //position.Z = 0; //why was this here?
+            return Teleport(simName, position, new LLVector3(0, 1.0F, 0));
+        }
+
+        /// &lt;summary&gt;
+        /// Teleport Function
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simName&quot;&gt;Region name&lt;/param&gt;
+        /// &lt;param name=&quot;position&quot;&gt;Position for Teleport&lt;/param&gt;
+        /// &lt;param name=&quot;lookAt&quot;&gt;Target to look at&lt;/param&gt;
+        /// &lt;returns&gt;&lt;/returns&gt;
+        public bool Teleport(string simName, LLVector3 position, LLVector3 lookAt)
+        {
+            int attempts = 0;
+            TeleportStat = TeleportStatus.None;
+
+            simName = simName.ToLower();
+
+            GridRegion region = Client.Grid.GetGridRegion(simName);
+
+            if (region != null)
+            {
+                return Teleport(region.RegionHandle, position, lookAt);
+            }
+            else
+            {
+                while (attempts++ &lt; 5)
+                {
+                    region = Client.Grid.GetGridRegion(simName);
+
+                    if (region != null)
+                    {
+                        return Teleport(region.RegionHandle, position, lookAt);
+                    }
+                    else
+                    {
+                        // Request the region info again
+                        Client.Grid.AddSim(simName);
+
+                        // FIXME: We shouldn't be sleeping in the library at all, hopefully this goes away soon
+                        System.Threading.Thread.Sleep(1000);
+                    }
+                }
+            }
+
+            if (OnTeleport != null)
+            {
+                teleportMessage = &quot;Unable to resolve name: &quot; + simName;
+                TeleportStat = TeleportStatus.Failed;
+                OnTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
+            }
+
+            return false;
+        }
+
+        /// &lt;summary&gt;
+        /// Respond to a teleport lure by either accepting it and initiating 
+        /// the teleport, or denying it
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;requesterID&quot;&gt;UUID of the avatar requesting the teleport&lt;/param&gt;
+        /// &lt;param name=&quot;accept&quot;&gt;Accept the teleport request or deny it&lt;/param&gt;
+        public void TeleportLureRespond(LLUUID requesterID, bool accept)
+        {
+			InstantMessage(requesterID, accept ? InstantMessageDialog.AcceptTeleport : InstantMessageDialog.DenyTeleport);
+
+            if (accept)
+            {
+                TeleportLureRequestPacket lure = new TeleportLureRequestPacket();
+
+                lure.Info.AgentID = Client.Network.AgentID;
+                lure.Info.SessionID = Client.Network.SessionID;
+                lure.Info.LureID = Client.Network.AgentID;
+                lure.Info.TeleportFlags = 4; // TODO: What does this mean?
+
+                Client.Network.SendPacket(lure);
+            }
+        }
+
+        /// &lt;summary&gt;
+        /// Grabs an object
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;objectLocalID&quot;&gt;Local ID of Object to grab&lt;/param&gt;
+        public void Grab(uint objectLocalID)
+        {
+            ObjectGrabPacket grab = new ObjectGrabPacket();
+            grab.AgentData.AgentID = Client.Network.AgentID;
+            grab.AgentData.SessionID = Client.Network.SessionID;
+            grab.ObjectData.LocalID = objectLocalID;
+            grab.ObjectData.GrabOffset = new LLVector3(0, 0, 0);
+            Client.Network.SendPacket(grab);
+        }
+
+        /// &lt;summary&gt;
+        /// Drags on an object
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;objectID&quot;&gt;Strangely, LLUID instead of local ID&lt;/param&gt;
+        /// &lt;param name=&quot;grabPosition&quot;&gt;Drag target in region coordinates&lt;/param&gt;
+        public void GrabUpdate(LLUUID objectID, LLVector3 grabPosition)
+        {
+            ObjectGrabUpdatePacket grab = new ObjectGrabUpdatePacket();
+            grab.AgentData.AgentID = Client.Network.AgentID;
+            grab.AgentData.SessionID = Client.Network.SessionID;
+            grab.ObjectData.ObjectID = objectID;
+            grab.ObjectData.GrabOffsetInitial = new LLVector3(0, 0, 0);
+            grab.ObjectData.GrabPosition = grabPosition;
+            grab.ObjectData.TimeSinceLast = 0;
+            Client.Network.SendPacket(grab);
+        }
+
+        /// &lt;summary&gt;
+        /// Releases a grabbed object
+        /// &lt;/summary&gt;
+        public void DeGrab(uint objectLocalID)
+        {
+            ObjectDeGrabPacket degrab = new ObjectDeGrabPacket();
+            degrab.AgentData.AgentID = Client.Network.AgentID;
+            degrab.AgentData.SessionID = Client.Network.SessionID;
+            degrab.ObjectData.LocalID = objectLocalID;
+            Client.Network.SendPacket(degrab);
+        }
+
+        /// &lt;summary&gt;
+        /// Touches an object
+        /// &lt;/summary&gt;
+        public void Touch(uint objectLocalID)
+        {
+            Client.Self.Grab(objectLocalID);
+            Client.Self.DeGrab(objectLocalID);
+        }
+
+        /// &lt;summary&gt;
+        /// Request to join a group. If there is an enrollment fee it will 
+        /// automatically be deducted from your balance
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;groupID&quot;&gt;The group to attempt to join&lt;/param&gt;
+        public void RequestJoinGroup(LLUUID groupID)
+        {
+            JoinGroupRequestPacket join = new JoinGroupRequestPacket();
+
+            join.AgentData.AgentID = Client.Network.AgentID;
+            join.AgentData.SessionID = Client.Network.SessionID;
+            join.GroupData.GroupID = groupID;
+
+            Client.Network.SendPacket(join);
+        }
+
+        /// &lt;summary&gt;
+        /// Request to leave a group
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;groupID&quot;&gt;The group to attempt to leave&lt;/param&gt;
+        public void RequestLeaveGroup(LLUUID groupID)
+        {
+            LeaveGroupRequestPacket leave = new LeaveGroupRequestPacket();
+
+            leave.AgentData.AgentID = Client.Network.AgentID;
+            leave.AgentData.SessionID = Client.Network.SessionID;
+            leave.GroupData.GroupID = groupID;
+
+            Client.Network.SendPacket(leave);
+        }
+
+        /// &lt;summary&gt;
+        /// Set our current active group
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;groupID&quot;&gt;The group we are a member of that we want to 
+        /// activate&lt;/param&gt;
+        public void ActivateGroup(LLUUID groupID)
+        {
+            ActivateGroupPacket activate = new ActivateGroupPacket();
+
+            activate.AgentData.AgentID = Client.Network.AgentID;
+            activate.AgentData.SessionID = Client.Network.SessionID;
+            activate.AgentData.GroupID = groupID;
+
+            Client.Network.SendPacket(activate);
+        }
+
+        /// &lt;summary&gt;
+        /// Move an agent in to a simulator. This packet is the last packet
+        /// needed to complete the transition in to a new simulator
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        public void CompleteAgentMovement(Simulator simulator)
+        {
+            CompleteAgentMovementPacket move = new CompleteAgentMovementPacket();
+
+            move.AgentData.AgentID = Client.Network.AgentID;
+            move.AgentData.SessionID = Client.Network.SessionID;
+            move.AgentData.CircuitCode = simulator.CircuitCode;
+
+            Client.Network.SendPacket(move, simulator);
+        }
+
+        /// &lt;summary&gt;
+        /// Sends camera and action updates to the server including the 
+        /// position and orientation of our camera, and a ControlFlags field
+        /// specifying our current movement actions
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;reliable&quot;&gt;Whether to ensure this packet makes it to the server&lt;/param&gt;
+        public void UpdateCamera(Avatar.AgentUpdateFlags controlFlags, LLVector3 position, LLVector3 forwardAxis,
+            LLVector3 leftAxis, LLVector3 upAxis, LLQuaternion bodyRotation, LLQuaternion headRotation, float farClip,
+            bool reliable)
+        {
+            AgentUpdatePacket update = new AgentUpdatePacket();
+
+            update.AgentData.AgentID = Client.Network.AgentID;
+            update.AgentData.SessionID = Client.Network.SessionID;
+            update.AgentData.State = 0;
+            update.AgentData.BodyRotation = bodyRotation;
+            update.AgentData.HeadRotation = headRotation;
+            update.AgentData.CameraCenter = position;
+            update.AgentData.CameraAtAxis = forwardAxis;
+            update.AgentData.CameraLeftAxis = leftAxis;
+            update.AgentData.CameraUpAxis = upAxis;
+            update.AgentData.Far = farClip;
+            update.AgentData.ControlFlags = (uint)controlFlags;
+            update.AgentData.Flags = 0;
+            update.Header.Reliable = reliable;
+
+            Client.Network.SendPacket(update);
+        }
+
+        /// &lt;summary&gt;
+        /// [UNUSED - for now]
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;packet&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
+        private void CoarseLocationHandler(Packet packet, Simulator simulator)
+        {
+            if (packet.Type == PacketType.CoarseLocationUpdate)
+	    {
+                CoarseLocationUpdatePacket p = (CoarseLocationUpdatePacket) packet;
+
+                if (p.Index.You &lt; 0 || p.Index.You &gt;= p.Location.Length) return;
+                /* 1.5 and 6 represent a 50% fudge factor (hysteresis) -- bushing */
+                if (Math.Abs(Position.X-p.Location[p.Index.You].X) &gt; 1.5) Position.X=p.Location[p.Index.You].X;
+                if (Math.Abs(Position.Y-p.Location[p.Index.You].Y) &gt; 1.5) Position.Y=p.Location[p.Index.You].Y;
+                if (Math.Abs(Position.Z-(p.Location[p.Index.You].Z*4)) &gt; 6) Position.Z=p.Location[p.Index.You].Z*4;
+            }
+        }
+
+        /// &lt;summary&gt;
+        /// Take an incoming ImprovedInstantMessage packet, auto-parse, and if
+        ///   OnInstantMessage is defined call that with the appropriate arguments.
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;packet&quot;&gt;Incoming ImprovedInstantMessagePacket&lt;/param&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
+        private void InstantMessageHandler(Packet packet, Simulator simulator)
+        {
+            if (packet.Type == PacketType.ImprovedInstantMessage)
+            {
+                ImprovedInstantMessagePacket im = (ImprovedInstantMessagePacket)packet;
+
+                if (OnInstantMessage != null)
+                {
+                    OnInstantMessage(
+                        im.AgentData.AgentID
+                        , Helpers.FieldToString(im.MessageBlock.FromAgentName),
+                        im.MessageBlock.ToAgentID
+                        , im.MessageBlock.ParentEstateID
+                        , im.MessageBlock.RegionID
+                        , im.MessageBlock.Position
+                        , im.MessageBlock.Dialog
+                        , im.MessageBlock.FromGroup
+                        , im.MessageBlock.ID
+                        , new DateTime(im.MessageBlock.Timestamp)
+                        , Helpers.FieldToString(im.MessageBlock.Message)
+                        , im.MessageBlock.Offline
+                        , im.MessageBlock.BinaryBucket
+                        );
+                }
+            }
+        }
+
+        /// &lt;summary&gt;
+        /// Take an incoming Chat packet, auto-parse, and if OnChat is defined call 
+        ///   that with the appropriate arguments.
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;packet&quot;&gt;Incoming ChatFromSimulatorPacket&lt;/param&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
+        private void ChatHandler(Packet packet, Simulator simulator)
+        {
+            if (OnChat != null)
+            {
+                ChatFromSimulatorPacket chat = (ChatFromSimulatorPacket)packet;
+
+                OnChat(Helpers.FieldToFilteredString(chat.ChatData.Message, new char())
+                    , chat.ChatData.Audible
+                    , chat.ChatData.ChatType
+                    , chat.ChatData.SourceType
+                    , Helpers.FieldToString(chat.ChatData.FromName)
+                    , chat.ChatData.SourceID
+                    , chat.ChatData.OwnerID
+                    , chat.ChatData.Position
+                    );
+            }
+        }
+
+        /// &lt;summary&gt;
+        /// Used for parsing llDialog's
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;packet&quot;&gt;Incoming ScriptDialog packet&lt;/param&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
+        private void ScriptDialogHandler(Packet packet, Simulator simulator)
+        {
+            if (OnScriptDialog != null)
+            {
+                ScriptDialogPacket dialog = (ScriptDialogPacket)packet;
+                List&lt;string&gt; buttons = new List&lt;string&gt;();
+
+                foreach (ScriptDialogPacket.ButtonsBlock button in dialog.Buttons)
+                {
+                    buttons.Add(Helpers.FieldToString(button.ButtonLabel));
+                }
+
+                OnScriptDialog(Helpers.FieldToString(dialog.Data.Message),
+                    Helpers.FieldToString(dialog.Data.ObjectName),
+                    dialog.Data.ImageID,
+                    dialog.Data.ObjectID,
+                    Helpers.FieldToString(dialog.Data.FirstName),
+                    Helpers.FieldToString(dialog.Data.LastName),
+                    dialog.Data.ChatChannel,
+                    buttons);
+            }
+        }
+
+        /// &lt;summary&gt;
+        /// Update client's Position, LookAt and region handle from incoming packet
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;packet&quot;&gt;Incoming AgentMovementCompletePacket&lt;/param&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
+        private void MovementCompleteHandler(Packet packet, Simulator simulator)
+        {
+            AgentMovementCompletePacket movement = (AgentMovementCompletePacket)packet;
+
+            this.Position = movement.Data.Position;
+            this.LookAt = movement.Data.LookAt;
+            simulator.Region.Handle = movement.Data.RegionHandle;
+        }
+
+        /// &lt;summary&gt;
+        /// Update Client Avatar's health via incoming packet
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;packet&quot;&gt;Incoming HealthMessagePacket&lt;/param&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
+        private void HealthHandler(Packet packet, Simulator simulator)
+        {
+            health = ((HealthMessagePacket)packet).HealthData.Health;
+        }
+
+        private void JoinGroupHandler(Packet packet, Simulator simulator)
+        {
+            if (OnJoinGroup != null)
+            {
+                JoinGroupReplyPacket reply = (JoinGroupReplyPacket)packet;
+
+                OnJoinGroup(reply.GroupData.GroupID, reply.GroupData.Success);
+            }
+        }
+
+        private void LeaveGroupHandler(Packet packet, Simulator simulator)
+        {
+            if (OnLeaveGroup != null)
+            {
+                LeaveGroupReplyPacket reply = (LeaveGroupReplyPacket)packet;
+
+                OnLeaveGroup(reply.GroupData.GroupID, reply.GroupData.Success);
+            }
+        }
+
+        public void AgentDataUpdateHandler(Packet packet, Simulator simulator)
+        {
+            AgentDataUpdatePacket p = (AgentDataUpdatePacket)packet;
+            if (p.AgentData.AgentID == simulator.Client.Network.AgentID) {
+                activeGroup = p.AgentData.ActiveGroupID;
+            }
+        }
+		
+        private void DropGroupHandler(Packet packet, Simulator simulator)
+        {
+            if (OnGroupDropped != null)
+            {
+                OnGroupDropped(((AgentDropGroupPacket)packet).AgentData.GroupID);
+            }
+        }
+
+        /// &lt;summary&gt;
+        /// Update Client Avatar's L$ balance from incoming packet
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;packet&quot;&gt;Incoming MoneyBalanceReplyPacket&lt;/param&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;Unused&lt;/param&gt;
+        private void BalanceHandler(Packet packet, Simulator simulator)
+        {
+            if (packet.Type == PacketType.MoneyBalanceReply)
+            {
+                balance = ((MoneyBalanceReplyPacket)packet).MoneyData.MoneyBalance;
+            }
+            else if (packet.Type == PacketType.MoneySummaryReply)
+            {
+                balance = ((MoneySummaryReplyPacket)packet).MoneyData.Balance;
+            }
+            else if (packet.Type == PacketType.AdjustBalance)
+            {
+                balance += ((AdjustBalancePacket)packet).AgentData.Delta;
+            }
+
+            if (OnBalanceUpdated != null)
+            {
+                OnBalanceUpdated(balance);
+            }
+        }
+
+	    private void EventQueueHandler(string message, object body)
+        {
+	        if(message == &quot;TeleportFinish&quot;)
+            {
+		        Hashtable tpt = (Hashtable)body;
+		        Hashtable info = (Hashtable)tpt[&quot;Info&quot;];
+
+		        // FIXME: quick and dirty hack
+		        TeleportFinishPacket packet = new TeleportFinishPacket();
+
+		        packet.Info.SimIP = Helpers.BytesToUInt((byte[])info[&quot;SimIP&quot;]);
+                packet.Info.LocationID = Helpers.BytesToUInt((byte[])info[&quot;LocationID&quot;]);
+                packet.Info.TeleportFlags = Helpers.BytesToUInt((byte[])info[&quot;TeleportFlags&quot;]);
+		        packet.Info.AgentID = (LLUUID)info[&quot;AgentID&quot;];
+                packet.Info.RegionHandle = Helpers.BytesToUInt64((byte[])info[&quot;RegionHandle&quot;]);
+		        packet.Info.SeedCapability = Helpers.StringToField((string)info[&quot;SeedCapability&quot;]);
+		        packet.Info.SimPort = (ushort)(long)info[&quot;SimPort&quot;];
+		        packet.Info.SimAccess = (byte)(long)info[&quot;SimAccess&quot;];
+
+		        TeleportHandler(packet,Client.Network.CurrentSim);
+	        }
+	    }
+
+        /// &lt;summary&gt;
+        /// Process an incoming effect
+        /// &lt;/summary&gt;
+        private void ViewerEffectHandler(Packet packet, Simulator simulator)
+        {
+            ViewerEffectPacket effect = (ViewerEffectPacket)packet;
+
+            foreach (ViewerEffectPacket.EffectBlock block in effect.Effect)
+            {
+                EffectType type;
+
+                try
+                {
+                    type = (EffectType)block.Type;
+                }
+                catch (Exception)
+                {
+                    Client.Log(&quot;Received a ViewerEffect block with an unknown type &quot; + block.Type, 
+                        Helpers.LogLevel.Warning);
+                    continue;
+                }
+
+                //LLColor color;
+                //if (block.Color.Length == 4)
+                //{
+                //    color = new LLColor(block.Color, 0);
+                //}
+                //else
+                //{
+                //    Client.Log(&quot;Received a ViewerEffect.EffectBlock.Color array with &quot; + block.Color.Length + &quot; bytes&quot;,
+                //        Helpers.LogLevel.Warning);
+                //    color = new LLColor();
+                //}
+
+                // Each ViewerEffect type uses it's own custom binary format for additional data. Fun eh?
+                switch (type)
+                {
+                    case EffectType.Text:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.Icon:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.Connector:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.FlexibleObject:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.AnimalControls:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.AnimationObject:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.Cloth:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.Beam:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.Glow:
+                        Client.Log(&quot;Received a Glow ViewerEffect which is not implemented yet&quot;,
+                            Helpers.LogLevel.Warning);
+                        break;
+		            case EffectType.Point:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.Trail:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.Sphere:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.Spiral:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.Edit:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+		            case EffectType.LookAt:
+                        Client.DebugLog(&quot;Received a ViewerEffect of type &quot; + type.ToString() + &quot;, implement me!&quot;);
+                        break;
+                    case EffectType.PointAt:
+                        if (block.TypeData.Length == 57)
+                        {
+                            LLUUID sourceAvatar = new LLUUID(block.TypeData, 0);
+                            LLUUID targetObject = new LLUUID(block.TypeData, 16);
+                            LLVector3d targetPos = new LLVector3d(block.TypeData, 32);
+                            PointAtType pointAt;
+                            try
+                            {
+                                pointAt = (PointAtType)block.TypeData[56];
+                            }
+                            catch (Exception)
+                            {
+                                Client.Log(&quot;Unrecognized PointAtType &quot; + block.TypeData[56], Helpers.LogLevel.Warning);
+                                pointAt = PointAtType.Clear;
+                            }
+
+                            // TODO: Create OnAvatarPointAt event and call it here
+                        }
+                        else
+                        {
+                            Client.Log(&quot;Received a PointAt ViewerEffect with an incorrect TypeData size of &quot; +
+                                block.TypeData.Length + &quot; bytes&quot;, Helpers.LogLevel.Warning);
+                        }
+                        break;
+                }
+            }
+        }
+
+        /// &lt;summary&gt;
+        /// Handler for teleport Requests
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;packet&quot;&gt;Incoming TeleportHandler packet&lt;/param&gt;
+        /// &lt;param name=&quot;simulator&quot;&gt;Simulator sending teleport information&lt;/param&gt;
+        private void TeleportHandler(Packet packet, Simulator simulator)
+        {
+            if (packet.Type == PacketType.TeleportStart)
+            {
+                Client.DebugLog(&quot;TeleportStart received from &quot; + simulator.ToString());
+
+                teleportMessage = &quot;Teleport started&quot;;
+                TeleportStat = TeleportStatus.Start;
+
+                if (OnBeginTeleport != null)
+                {
+                    OnBeginTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
+                }
+            }
+            else if (packet.Type == PacketType.TeleportProgress)
+            {
+                Client.DebugLog(&quot;TeleportProgress received from &quot; + simulator.ToString());
+
+                teleportMessage = Helpers.FieldToString(((TeleportProgressPacket)packet).Info.Message);
+                TeleportStat = TeleportStatus.Progress;
+
+                if (OnBeginTeleport != null)
+                {
+                    OnBeginTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
+                }
+            }
+            else if (packet.Type == PacketType.TeleportFailed)
+            {
+                Client.DebugLog(&quot;TeleportFailed received from &quot; + simulator.ToString());
+
+                teleportMessage = Helpers.FieldToString(((TeleportFailedPacket)packet).Info.Reason);
+                TeleportStat = TeleportStatus.Failed;
+
+                if (OnBeginTeleport != null)
+                {
+                    OnBeginTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
+                }
+
+                OnBeginTeleport = null;
+            }
+            else if (packet.Type == PacketType.TeleportFinish)
+            {
+                Client.DebugLog(&quot;TeleportFinish received from &quot; + simulator.ToString());
+
+                TeleportFinishPacket finish = (TeleportFinishPacket)packet;
+                Simulator previousSim = Client.Network.CurrentSim;
+
+                // Connect to the new sim
+				String seedcaps = Encoding.UTF8.GetString(finish.Info.SeedCapability).Replace(&quot;\x00&quot;,&quot;&quot;);
+                Simulator sim = Client.Network.Connect(new IPAddress((long)finish.Info.SimIP), finish.Info.SimPort,
+                    simulator.CircuitCode, true, seedcaps);
+
+                if (sim != null)
+                {
+                    teleportMessage = &quot;Teleport finished&quot;;
+                    TeleportStat = TeleportStatus.Finished;
+
+                    // Move the avatar in to the new sim
+                    CompleteAgentMovementPacket move = new CompleteAgentMovementPacket();
+                    move.AgentData.AgentID = Client.Network.AgentID;
+                    move.AgentData.SessionID = Client.Network.SessionID;
+                    move.AgentData.CircuitCode = simulator.CircuitCode;
+                    Client.Network.SendPacket(move, sim);
+
+                    // Disconnect from the previous sim
+                    Client.Network.DisconnectSim(previousSim);
+
+                    Client.Log(&quot;Moved to new sim &quot; + sim.ToString(), Helpers.LogLevel.Info);
+
+                    if (OnBeginTeleport != null)
+                    {
+                        OnBeginTeleport(sim, teleportMessage, TeleportStat);
+                    }
+                    else
+                    {
+                        // Sleep a little while so we can collect parcel information
+                        // NOTE: This doesn't belong in libsecondlife
+                        // System.Threading.Thread.Sleep(1000);
+                    }
+                }
+                else
+                {
+                    teleportMessage = &quot;Failed to connect to the new sim after a teleport&quot;;
+                    TeleportStat = TeleportStatus.Failed;
+
+                    // FIXME: Set the previous CurrentSim to the current simulator again
+
+                    Client.Log(teleportMessage, Helpers.LogLevel.Warning);
+
+                    if (OnBeginTeleport != null)
+                    {
+                        OnBeginTeleport(Client.Network.CurrentSim, teleportMessage, TeleportStat);
+                    }
+                }
+
+                OnBeginTeleport = null;
+            }
+        }
+
+        /// &lt;summary&gt;
+        /// Teleport Timer Event Handler. Used for enforcing timeouts.
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;ea&quot;&gt;&lt;/param&gt;
+        private void TeleportTimerEvent(object source, System.Timers.ElapsedEventArgs ea)
+        {
+            TeleportTimeout = true;
+        }
+    }
+}

Modified: trunk/libsecondlife-cs/NetworkManager.cs
===================================================================
--- trunk/libsecondlife-cs/NetworkManager.cs	2007-01-19 13:15:12 UTC (rev 859)
+++ trunk/libsecondlife-cs/NetworkManager.cs	2007-01-19 13:30:56 UTC (rev 860)
@@ -53,15 +53,33 @@
     /// &lt;/summary&gt;
     public class Caps
     {
+        /// &lt;summary&gt;
+        /// Triggered when an event is received via the EventQueueGet capability;
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;body&quot;&gt;&lt;/param&gt;
+        public delegate void EventQueueCallback(string message, object body);
+
+        /// &lt;summary&gt;Reference to the SecondLife client this system is connected to&lt;/summary&gt;
         public SecondLife Client;
+        /// &lt;summary&gt;Reference to the region this system is connected to&lt;/summary&gt;
         public Region Region;
+
+
         private string Seedcaps;
         private StringDictionary Capabilities = new StringDictionary();
         private bool Dead = false;
         private Thread EventThread;
-        private List&lt;NetworkManager.EventQueueCallback&gt; Callbacks;
+        private List&lt;EventQueueCallback&gt; Callbacks;
 
-        public Caps(SecondLife client, Region region, string seedcaps, List&lt;NetworkManager.EventQueueCallback&gt; callbacks)
+        /// &lt;summary&gt;
+        /// Default constructor
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;region&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;seedcaps&quot;&gt;&lt;/param&gt;
+        /// &lt;param name=&quot;callbacks&quot;&gt;&lt;/param&gt;
+        public Caps(SecondLife client, Region region, string seedcaps, List&lt;EventQueueCallback&gt; callbacks)
         {
             Client = client; Region = region;
             this.Seedcaps = seedcaps; Callbacks = callbacks;
@@ -90,7 +108,9 @@
         {
             bool gotresp = false; long ack = 0;
             string cap = Capabilities[&quot;EventQueueGet&quot;];
+
             while (!Dead)
+            {
                 try
                 {
                     Hashtable req = new Hashtable();
@@ -116,23 +136,28 @@
 
                         if (!Dead)
                         {
-                            foreach (NetworkManager.EventQueueCallback callback in Callbacks)
-                                callback(msg, body);
+                            foreach (EventQueueCallback callback in Callbacks)
+                            {
+                                try { callback(msg, body); }
+                                catch (Exception e) { Client.Log(e.ToString(), Helpers.LogLevel.Error); }
+                            }
                         }
                     }
                 }
                 catch (WebException e)
                 {
-                    // perfectly normal
-                    Client.Log(&quot;In EventQueueGet: &quot; + e.Message, Helpers.LogLevel.Info);
+                    // Perfectly normal
+                    Client.DebugLog(&quot;EventQueueGet: &quot; + e.Message);
                 }
+            }
         }
 
         private static object LLSDRequest(string uri, object req)
         {
             byte[] data = LLSD.LLSDSerialize(req);
             WebRequest wreq = WebRequest.Create(uri);
-            wreq.Method = &quot;POST&quot;; wreq.ContentLength = data.Length;
+            wreq.Method = &quot;POST&quot;;
+            wreq.ContentLength = data.Length;
             Stream reqStream = wreq.GetRequestStream();
             reqStream.Write(data, 0, data.Length);
             reqStream.Close();
@@ -164,7 +189,7 @@
 
     /// &lt;summary&gt;
     /// Simulator is a wrapper for a network connection to a simulator and the
-    /// Region class representing the block of land in the metaverse.
+    /// Region class representing the block of land in the metaverse
     /// &lt;/summary&gt;
     public class Simulator
     {
@@ -177,14 +202,14 @@
 
         /// &lt;summary&gt;
         /// Used internally to track sim disconnections, do not modify this 
-        /// variable.
+        /// variable
         /// &lt;/summary&gt;
         public bool DisconnectCandidate = false;
 
         /// &lt;summary&gt;
         /// The ID number associated with this particular connection to the 
         /// simulator, used to emulate TCP connections. This is used 
-        /// internally for packets that have a CircuitCode field.
+        /// internally for packets that have a CircuitCode field
         /// &lt;/summary&gt;
         public uint CircuitCode
         {
@@ -193,7 +218,7 @@
         }
 
         /// &lt;summary&gt;
-        /// The IP address and port of the server.
+        /// The IP address and port of the server
         /// &lt;/summary&gt;
         public IPEndPoint IPEndPoint
         {
@@ -202,7 +227,7 @@
 
         /// &lt;summary&gt;
         /// A boolean representing whether there is a working connection to the
-        /// simulator or not.
+        /// simulator or not
         /// &lt;/summary&gt;
         public bool Connected
         {
@@ -746,12 +771,6 @@
         /// &lt;param name=&quot;simulator&quot;&gt;&lt;/param&gt;
         public delegate void PacketCallback(Packet packet, Simulator simulator);
         /// &lt;summary&gt;
-        /// Triggered when an event is received via the EventQueueGet capability;
-        /// &lt;/summary&gt;
-        /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;
-        /// &lt;param name=&quot;body&quot;&gt;&lt;/param&gt;
-        public delegate void EventQueueCallback(string message, object body);
-        /// &lt;summary&gt;
         /// Triggered when a simulator other than the simulator that is currently
         /// being occupied disconnects for whatever reason
         /// &lt;/summary&gt;
@@ -842,7 +861,7 @@
         private System.Timers.Timer DisconnectTimer;
         private System.Timers.Timer LogoutTimer;
         private bool connected;
-        private List&lt;EventQueueCallback&gt; EventQueueCallbacks = new List&lt;EventQueueCallback&gt;();
+        private List&lt;Caps.EventQueueCallback&gt; EventQueueCallbacks = new List&lt;Caps.EventQueueCallback&gt;();
 
         private const int NetworkTrafficTimeout = 15000;
 
@@ -917,7 +936,7 @@
         /// 
         /// &lt;/summary&gt;
         /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt;
-        public void RegisterEventCallback(EventQueueCallback callback)
+        public void RegisterEventCallback(Caps.EventQueueCallback callback)
         {
             EventQueueCallbacks.Add(callback);
         }
@@ -1620,20 +1639,15 @@
 
                 if (OnCurrentSimChanged != null)
                 {
-                    try
-                    {
-                        OnCurrentSimChanged(oldSim);
-                    }
-                    catch (Exception e)
-                    {
-                        Client.Log(&quot;Caught an exception in OnCurrentSimChanged(): &quot; + e.ToString(),
-                            Helpers.LogLevel.Error);
-                    }
+                    try { OnCurrentSimChanged(oldSim); }
+                    catch (Exception e) { Client.Log(e.ToString(), Helpers.LogLevel.Error); }
                 }
             }
+
             if (CurrentCaps != null)
             {
-                CurrentCaps.Disconnect(); CurrentCaps = null;
+                CurrentCaps.Disconnect();
+                CurrentCaps = null;
             }
 
             connected = false;

Modified: trunk/libsecondlife-cs/examples/TestClient/TestClient.cs
===================================================================
--- trunk/libsecondlife-cs/examples/TestClient/TestClient.cs	2007-01-19 13:15:12 UTC (rev 859)
+++ trunk/libsecondlife-cs/examples/TestClient/TestClient.cs	2007-01-19 13:30:56 UTC (rev 860)
@@ -117,7 +117,7 @@
 
 		public void DoCommand(string cmd, LLUUID fromAgentID, LLUUID imSessionID)
         {
-			string[] tokens = Parsing.ParseArguments(cmd);//cmd.Trim().Split(new char[] { ' ', '\t' });
+			string[] tokens = Parsing.ParseArguments(cmd);
 
             if (tokens.Length == 0)
                 return;

Modified: trunk/libsecondlife-cs/examples/TestClient/TestClient.csproj
===================================================================
--- trunk/libsecondlife-cs/examples/TestClient/TestClient.csproj	2007-01-19 13:15:12 UTC (rev 859)
+++ trunk/libsecondlife-cs/examples/TestClient/TestClient.csproj	2007-01-19 13:30:56 UTC (rev 860)
@@ -80,6 +80,7 @@
     &lt;Compile Include=&quot;Commands\WhoCommand.cs&quot;&gt;
       &lt;SubType&gt;Code&lt;/SubType&gt;
     &lt;/Compile&gt;
+    &lt;Compile Include=&quot;Parsing.cs&quot; /&gt;
     &lt;Compile Include=&quot;Program.cs&quot; /&gt;
     &lt;Compile Include=&quot;TestClient.cs&quot; /&gt;
     &lt;Compile Include=&quot;Properties\AssemblyInfo.cs&quot; /&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000282.html">[Libsecondlife-commits] r859 - in trunk: data libsecondlife-cs	libsecondlife-cs/examples/ParcelDownload	libsecondlife-cs/libsecondlife.Utilities
</A></li>
	<LI>Next message: <A HREF="000284.html">[Libsecondlife-commits] [Patch #1840] Patch for endianness of IP	address in TeleportFinish
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#283">[ date ]</a>
              <a href="thread.html#283">[ thread ]</a>
              <a href="subject.html#283">[ subject ]</a>
              <a href="author.html#283">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/libsecondlife-commits">More information about the Libsecondlife-commits
mailing list</a><br>
</body></html>
